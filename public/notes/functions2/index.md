# Функции в Python. Часть II


Вторая часть функций в Python (совсем базу вряд-ли буду выкладывать). Типы аргументов, некоторые встроенные и lambda функции
&lt;!--more--&gt;
## **Необязательные и именованные аргументы**
### Позиционные аргументы
Когда мы вызываем функции c позиционными аргументами, значения в них подставляются согласно позиции их имен в определении функции. Например код ниже выведет число 7. При вызове функции `diff()` первому параметру x будет соответствовать первый переданный аргумент – 10, а второму параметру y – второй аргумент – 3.
```py
def diff(x, y):
    return x - y


res = diff(10, 3)  # используем позиционные аргументы
print(res)
```

---
### Именованные аргументы
Аргументы, передаваемые с именами, называются именованными. Чтобы передать именованные аргументы в функцию, нужно указать их имена, которые были заданы при объявлении функции:
```py
def bar(length, char1, char2):
    return (char1 &#43; char2) * length &#43; char1

print(bar(length=3, char1=&#39;-&#39;, char2=&#39;*&#39;))
# =&gt; -*-*-*-
print(bar(char1=&#39;-&#39;, char2=&#39;*&#39;, length=3))
# =&gt; -*-*-*-
print(bar(char2=&#39;*&#39;, length=3, char1=&#39;-&#39;))
# =&gt; -*-*-*-
```

При вызове функции меняется порядок передаваемых аргументов. Когда функции назначаются соответствующие значения именованных аргументов, Python учитывает их имена, а не позиции. В результате функция будет всегда выводить одно и то же значение независимо от позиций переданных ей аргументов.

{{&lt; admonition tip &gt;}}
**Рекомендация** по тому, когда стоит использовать именованные аргументы: если функция принимает больше трёх аргументов, нужно хотя бы часть из них указать по имени.
{{&lt; /admonition &gt;}}
```py
def make_circle(x, y, radius, line_width, fill):
    # тело функции

make_circle(x=200, y=300, radius=17, line_width=2.5, fill=True)
```

{{&lt; admonition warning &gt;}}
Мы можем вызывать функции, используя именованные и позиционные аргументы одновременно. Но позиционные значения должны быть указаны до любых именованных!
{{&lt; /admonition &gt;}}

---
### Необязательные аргументы
Бывает, что какой-то параметр функции часто принимает одно и то же значение. Например, для функции `print()` установили значения параметров `sep` и `end` равными символу пробела и символу перевода строки, поскольку эти значения используют наиболее часто.  
Другим примером служит функция `int()`, преобразующая строку в число. Она принимает два аргумента: первый аргумент – строка, которую нужно преобразовать в число, второй аргумент – основание системы счисления, значение по умолчанию которого равно 10.  

Чтобы задать значение параметра по умолчанию, в списке параметров функции достаточно после имени переменной написать &lt;b&gt;знак равенства и нужное значение&lt;/b&gt;.  
&lt;u&gt;Параметры со значением по умолчанию идут последними.&lt;/u&gt;

#### Изменяемые типы данных в качестве значений по умолчанию
Рассмотрим определение функции `append()`, где в качестве значения по умолчанию используется изменяемый тип данных:
```py
def append(element, seq=[]):
    seq.append(element)
    return seq
```

Если вызвать функцию так, то мы получим неожиданный результат:
```py
print(append(10))
print(append(5))
print(append(1))
```

```
# Вывод:
[10]
[10, 5]
[10, 5, 1]
```

Значение по умолчанию для параметра создается **единожды** при определении функции (обычно при загрузке модуля) и становится её атрибутом (свойством). Поэтому, если значение по умолчанию изменяемый объект, то его изменение повлияет на каждый следующий вызов функции.  
Для решения проблемы можно использовать константу `None` в качестве значения параметра по умолчанию, а в теле функции устанавливать нужное значение:
```py
def append(element, seq=None):
    if seq is None:
        seq = []
    seq.append(element)
    return seq

print(append(10))
print(append(5))
print(append(1))
```

```
# Вывод:
[10]
[5]
[1]
```

---
## **Функции с переменным количеством аргументов**
### Позиционные аргументы – *args
Рассмотрим определение функции `my_func()`:
```py
def my_func(*args):
    print(type(args))
    print(args)


my_func()
my_func(1, 2, 3)
my_func(&#39;a&#39;, &#39;b&#39;)
```

```
# Вывод:
&lt;class &#39;tuple&#39;&gt;
()
&lt;class &#39;tuple&#39;&gt;
(1, 2, 3)
&lt;class &#39;tuple&#39;&gt;
(&#39;a&#39;, &#39;b&#39;)
```

* В заголовке функции `my_func()` указан всего один параметр `args`, но со звездочкой перед ним. Звездочка в определении функции означает, что переменная (параметр) `args` получит в виде кортежа все аргументы, переданные в функцию при ее вызове от текущей позиции и до конца.  
* При описании функции можно использовать только один параметр помеченный звездочкой, причем располагаться он должен в конце списка параметров, иначе последующим параметрам не достанется значений.  
* Параметр со звёздочкой работает, даже если не передать аргументов.

Если мы хотим просуммировать несколько разных значений, не упаковывая их в список, можем написать следующую функцию (списки и кортежи при вызове нужно распаковывать):
```py
def my_sum(*args):
    return sum(args)

print(my_sum(1, 2, *[3, 4, 5], *(7, 8, 9), 10))

# Вывод: 49
```

---
### Именованные аргументы – **kwargs
```py
def my_func(**kwargs):
    print(type(kwargs))
    print(kwargs)

my_func()
my_func(a=1, b=2)
my_func(name=&#39;Timur&#39;, job=&#39;Teacher&#39;)
```

```
# Вывод:
&lt;class &#39;dict&#39;&gt;
{}
&lt;class &#39;dict&#39;&gt;
{&#39;a&#39;: 1, &#39;b&#39;: 2}
&lt;class &#39;dict&#39;&gt;
{&#39;name&#39;: &#39;Timur&#39;, &#39;job&#39;: &#39;Teacher&#39;}
```

* Именованные аргументы получаются в виде словаря, что позволяет сохранить имена аргументов в ключах. 
* Именованные аргументы можно передавать в функцию &#34;пачкой&#34; в виде словаря. Для этого нужно перед словарём поставить две звёздочки.
* Параметр `**kwargs` пишется в самом конце, после последнего аргумента со значением по умолчанию. При этом функция может содержать и `*args` и `**kwargs` параметры:
```py
def my_func(a, b, *args, name=&#39;Gvido&#39;, age=17, **kwargs):
    print(a, b)
    print(args)
    print(name, age)
    print(kwargs)

my_func(1, 2, 3, 4, name=&#39;Timur&#39;, age=28, job=&#39;Teacher&#39;, language=&#39;Python&#39;)
my_func(1, 2, name=&#39;Timur&#39;, age=28, job=&#39;Teacher&#39;, language=&#39;Python&#39;)
my_func(1, 2, 3, 4, job=&#39;Teacher&#39;, language=&#39;Python&#39;)
```

```
# Вывод:
1 2
(3, 4)
Timur 28
{&#39;job&#39;: &#39;Teacher&#39;, &#39;language&#39;: &#39;Python&#39;}

1 2
()
Timur 28
{&#39;job&#39;: &#39;Teacher&#39;, &#39;language&#39;: &#39;Python&#39;}

1 2
(3, 4)
Gvido 17
{&#39;job&#39;: &#39;Teacher&#39;, &#39;language&#39;: &#39;Python&#39;}
```

---
## **Keyword-only аргументы**
В Python 3 добавили возможность пометить именованные аргументы функции так, чтобы вызвать функцию можно было, только передав эти аргументы по именам. Такие аргументы называются `keyword-only` и их нельзя передать в функцию в виде позиционных:
```py
def make_circle(x, y, radius, *, line_width=1, fill=True):
    #код

make_circle(10, 20, 5)                                    # x=10, y=20, radius=5,  line_width=1, fill=True
make_circle(x=10, y=20, radius=7)                         # x=10, y=20, radius=7,  line_width=1, fill=True
make_circle(10, 20, radius=10, line_width=2, fill=False)  # x=10, y=20, radius=10, line_width=2, fill=False
make_circle(x=10, y=20, radius=17, line_width=3)          # x=10, y=20, radius=17, line_width=3, fill=True
```
Здесь `*` выступает разделителем: отделяет обычные аргументы (их можно указывать по имени и позиционно) от строго именованных.  
То есть аргументы `x`, `y` и `radius` могут быть переданы в качестве как позиционных, так и именованных аргументов. При этом аргументы `line_width` и `fill` могут быть переданы только как именованные аргументы.  
Такой разделитель можно использовать только один раз в определении функции. Его нельзя применять в функциях с неограниченным количеством позиционных аргументов `*args`.

---
## **Функции как объекты**
Встроенные функции имеют следующий тип объекта:
```py
print(type(print))

# &lt;class &#39;builtin_function_or_method&#39;&gt;
```

Тогда как функции, объявленные программистом, имеют тип `&lt;class &#39;function&#39;&gt;`.

Поскольку функции тоже объекты, работать с ними можно как с остальными объектами: записывать их в переменные, передавать в качестве аргументов другим функциям, возвращать из функций и т.д.
```py
def hello():
    print(&#39;Hello from function&#39;)


func = hello  #  присваиваем переменной func функцию hello
func()        #  вызываем функцию

# Вывод: Hello from function
```

```py
writeln = print

writeln(&#39;Hello world!&#39;)
writeln(&#39;Python&#39;)
```

```
# Вывод:
Hello world!
Python
```

Присваивание переменной списка функций:
```py
def f(x):
    return x**2


def g(x):
    return x**3


funcs = [f, g]
print(funcs[0](5), funcs[1](5))

# Вывод: 25 125
```

{{&lt; admonition info &gt;}}
Функции, способные в качестве аргумента принимать или/и возвращать другие функции, называются функциями **высшего порядка**.  
Функция, определяющая условия сравнения элементов, называется **компаратор**.
{{&lt; /admonition &gt;}}

Такие встроенные функции, как `min()`, `max()`, `sorted()` могут принимать необязательный аргумент `key` – функцию, определяющую, по какому правилу будут сравниваться элементы (значение `key` должно быть функцией, принимающей один аргумент и возвращающей на его основе ключ для сравнения).
```py
numbers = [10, -7, 8, -100, -50, 32, 87, 117, -210]

print(max(numbers, key=abs))
print(min(numbers, key=abs))
print(sorted(numbers, key=abs))
```

```
# Вывод:
-210  # максимальный по модулю элемент
-7    # минимальный по модулю элемент
[-7, 8, 10, 32, -50, 87, -100, 117, -210] 
```

```py
def compare_by_second(point):
    return point[1]


def compare_by_sum(point):
    return point[0] &#43; point[1]


points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]

print(sorted(points, key=compare_by_second))  # сортируем по второму значению кортежа
print(sorted(points, key=compare_by_sum))     # сортируем по сумме кортежа
```

---
### Функции в качестве возвращаемых значений других функций
В Python можно определять функцию внутри функции, ведь функция это объект:
```py
def generator():
    def hello():
        print(&#39;Hello from function!&#39;)
    return hello

func = generator()
func()

# Вывод: Hello from function!
```

Мы можем написать генератор функций, который по параметрам a,b,c, построит и вернет нам конкретный квадратный трехчлен:
```py
def generator_square_polynom(a, b, c):
    def square_polynom(x):
        return a * x**2 &#43; b * x &#43; c

    return square_polynom

f = generator_square_polynom(a=1, b=2, c=1)
g = generator_square_polynom(a=2, b=0, c=-3)
h = generator_square_polynom(a=-3, b=-10, c=50)

print(f(1))
print(g(2))
print(h(-1))
```

```
# Вывод:
4
5
57
```

Вложенную функцию (`square_polynom()`), которая использует параметры внешней функции (`generator_square_polynom()`), называют **замыканием**.

---
### Пользовательские атрибуты функций
У объектов функций есть дополнительный атрибут `__dict__`, являющийся словарем и использующийся для динамического наделения функций дополнительным функционалом. Устанавливать и получать значения из данного атрибута можно, используя два синтаксиса:
* в стиле словаря: `func.__dict__[&#39;attr&#39;] = value`
* через точечную нотацию: `func.attr = value`
```py
def greet():
    greet.age = 17

print(greet.__dict__)

greet.value = 777
greet.numbers = [1, 2, 3]
greet.name = &#39;Timur&#39;

print(greet.__dict__)

greet()

print(greet.__dict__)
```
```
# Вывод:
{}
{&#39;value&#39;: 777, &#39;numbers&#39;: [1, 2, 3], &#39;name&#39;: &#39;Timur&#39;}
{&#39;value&#39;: 777, &#39;numbers&#39;: [1, 2, 3], &#39;name&#39;: &#39;Timur&#39;, &#39;age&#39;: 17}
```

Словарь атрибутов может быть использован для кэширования уже вычисленных значений функции:
```py
def fib(num):
    if num &lt; 2:
        return num
    if num not in fib.__dict__:
        fib.__dict__[num] = fib(num - 1) &#43; fib(num - 2)
    return fib.__dict__[num]
```

---
## **Функции высшего порядка**
Функции, которые принимают и/или возвращают другие функции, называются **функциями высшего порядка**.

### Функция `map()`
Функция, преобразующая каждый элемент переданного итерируемого объекта (можно воспринимать как классическое представление функции в математике – отображение множества в другое множество).  
Возможная реализация:
```py
def map(function, items):
    result = []
    for item in items:
        new_item = function(item)
        result.append(new_item)

    return result
```

Мы можем совершать преобразования, используя функцию высшего порядка `map()`:
```py
def square(x):
    return x**2


def cube(x):
    return x**3


numbers = [1, 2, -3, 4, -5, 6, -9, 0]

strings = map(str, numbers)      # используем в качестве преобразователя функцию str
abs_numbers = map(abs, numbers)  # используем в качестве преобразователя функцию abs

squares = map(square, numbers)   # используем в качестве преобразователя функцию square
cubes = map(cube, numbers)       # используем в качестве преобразователя функцию cube

print(strings)
print(abs_numbers)
print(squares)
print(cubes)
```

```
# Вывод:
[&#39;1&#39;, &#39;2&#39;, &#39;-3&#39;, &#39;4&#39;, &#39;-5&#39;, &#39;6&#39;, &#39;-9&#39;, &#39;0&#39;]
[1, 2, 3, 4, 5, 6, 9, 0]
[1, 4, 9, 16, 25, 36, 81, 0]
[1, 8, -27, 64, -125, 216, -729, 0]
```

Мы также можем строить цепочки преобразований, несколько раз вызывая функцию `map()` (сначала мы преобразуем список строк в список чисел, затем находим их модуль внешней функцией `map()`):
```py
numbers = [&#39;-1&#39;, &#39;20&#39;, &#39;3&#39;, &#39;-94&#39;, &#39;65&#39;, &#39;6&#39;, &#39;-970&#39;, &#39;8&#39;]
new_numbers = map(abs, map(int, numbers))
print(new_numbers)

# Вывод: [1, 20, 3, 94, 65, 6, 970, 8]
```

---
### Функция `filter()`
Эта функция отображает часть элементов итерируемого объекта по определённому критерию.  
Возможная реализация:
```py
def filter(function, items):
    result = []
    for item in items:
        if function(item):        
            result.append(item)  # добавляем элемент item если функция function вернула значение True

    return result
```

Функция `filter()` применяет предикат `function` к каждому элементу и добавляет в итоговый список только те элементы, для которых предикат вернул `True`.
```py
def is_odd(num):
    return num % 2


def is_word_long(word):
    return len(word) &gt; 6


numbers = list(range(15))
words = [&#39;В&#39;, &#39;новом&#39;, &#39;списке&#39;, &#39;останутся&#39;, &#39;только&#39;, &#39;длинные&#39;, &#39;слова&#39;]

odd_numbers = filter(is_odd, numbers)
large_words = filter(is_word_long, words)

print(odd_numbers)
print(large_words)
```

```
# Вывод:
[1, 3, 5, 7, 9, 11, 13]
[&#39;останутся&#39;, &#39;длинные&#39;]
```

---
### Функция `reduce()`
Функция, применяющая указанную функцию к элементам последовательности, сводя её к единственному значению.  
Возможная реализация:
```py
def reduce(operation, items, initial_value):
    acc = initial_value
    for item in items:
        acc = operation(acc, item)

    return acc
```

```py
def add(x, y):
    return x&#43;y


def mult(x, y):
    return x*y


numbers = [1, 2, 3, 4, 5]

total = reduce(add, numbers, 0)
product = reduce(mult, numbers, 1)

print(total)
print(product)
```

```
# Вывод:
15
120
```

---
## **Встроенные функции map(), filter(), reduce()**

### Встроенная функция `map()`
Функция, применяющая другую функцию к итерируемому объекту. Имеет сигнатуру `map(func, *iterables)`. В отличии от нашей реализации она может принимать сразу несколько последовательностей, переменное количество аргументов. Под подпоследовательностями имеются ввиду &lt;u&gt;списки, строки, кортежи, множества, словари&lt;/u&gt;.
```py
def increase(num):
    return num &#43; 7


numbers = [1, 2, 3, 4, 5, 6]
new_numbers = map(increase, numbers)  # используем встроенную функцию map()

print(new_numbers)

# Вывод: &lt;map object at 0x...&gt;
```

Вернулся итерируемый объект `&lt;map object at 0x...&gt;`. Подобные ему объекты называются **итераторами**. Если мы хотим получить список/кортеж из итератора, нужно воспользоваться функцией `list()`/`tuple()`, а если распаковать, то `*` (при этом сделать эти действия возможно только единожды, т.к. итератор &#34;исчерпывает&#34; себя).

Функции `map()` можно передать несколько последовательностей. В этом случае в функцию обратного вызова `func` будут передаваться сразу несколько элементов, расположенных в последовательностях на одинаковых позициях. При этом, если в последовательностях разное количество элементов, то последовательность с минимальным количеством элементов становится ограничителем.
```py
def func(elem1, elem2, elem3):
    return elem1 &#43; elem2 &#43; elem3


numbers1 = [1, 2, 3, 4, 5]
numbers2 = [10, 20, 30, 40, 50]
numbers3 = [100, 200, 300, 400, 500]

new_numbers = list(map(func, numbers1, numbers2, numbers3))  # преобразуем итератор в список

print(new_numbers)

# Вывод: [111, 222, 333, 444, 555]
```

Пример удобного использования функции `map()`, которой передано две последовательности:
```py
circle_areas = [3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213]

result1 = list(map(round, circle_areas, [1]*6))        # округляем числа до 1 знака после запятой
result2 = list(map(round, circle_areas, range(1, 7)))  # округляем числа до 1,2,...,6 знаков после запятой

print(circle_areas)
print(result1)
print(result2)
```

```
# Вывод:
[3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213]
[3.6, 5.6, 4.3, 6.2, 91.0, 32.0]
[3.6, 5.58, 4.319, 6.2024, 91.01344, 32.01213]
```

---
### Встроенная функция `filter()`
Функция отображает часть элементов итерируемого объекта по определённому критерию. Имеет сигнатуру `filter(func, iterable)`. В отличии от нашей реализации она может принимать любой итерируемый объект (список, строку, кортеж, и т.д.). 
```py
def func(elem):
    return elem &gt;= 0


numbers = [-1, 2, -3, 4, 0, -20, 10]
positive_numbers = list(filter(func, numbers))  # преобразуем итератор в список

print(positive_numbers)

# Вывод: [2, 4, 0, 10]
```

Функция `filter()` также возвращает итератор.  

Встроенной функции `filter()` можно в качестве первого параметра `func` передать значение `None`. В таком случае каждый элемент последовательности будет проверен на соответствие значению `True`. Если элемент в логическом контексте возвращает значение `False`, то он не будет добавлен в возвращаемый результат. В следующем коде значения списка `[0, &#39;&#39;, None, [], ()]` позиционируется как `False`:
```py
true_values = filter(None, [1, 0, 10, &#39;&#39;, None, [], [1, 2, 3], ()])

for value in true_values:
    print(value)
```

```
# Вывод:
1
10
[1, 2, 3]
```

---
### Функция `reduce()`
Для использования: `from functools import reduce`.

Функция, применяющая указанную функцию к элементам последовательности, сводя её к единственному значению. Имеет сигнатуру `reduce(func, iterable, initializer=None)`.  Если начальное значение не установлено, то в его качестве используется первое значение из последовательности `iterable`.
```py
from functools import reduce


def func(a, b):
    return a &#43; b


numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
total = reduce(func, numbers, 0)  # в качестве начального значения 0
print(total)

# Вывод: 55
```

---
## **Анонимные функции**
`lambda` – безымянные однострочные функции (называются анонимными или лямбда-функциями). По сути эти функции являются выражениями, при этом они имеют такой же тип данных, как обычные функции – `&lt;class &#39;function&#39;&gt;`. После определения их можно сразу вызвать: `print((lambda х, у: х &#43; у)(5, 10))     # 5 &#43; 10`.
Общий формат определения: `lambda список_параметров: выражение`. В теле лямбда-функции нельзя использовать несколько действий и циклы, но можно использовать тернарный условный оператор.
Применение таких функций оправдано в следующих случаях:
* однократное использование функции;
* передача функций в качестве аргумента другим функциям;
* возвращение функции в качестве результата другой функции.
```py
def standard_function(x):        #  стандартное объявление функции
    return x*2

lambda_function = lambda x: x*2  #  объявление анонимной функции

print(standard_function(7))
print(lambda_function(7))
```

```
# Вывод:
14
14
```

```py
f1 = lambda: 10 &#43; 20            # функция без параметров
f2 = lambda х, у: х &#43; у         # функция с двумя параметрами
f3 = lambda х, у, z: х &#43; у &#43; z  # функция с тремя параметрами

print(f1())
print(f2(5, 10))
print(f3(5, 10, 30))
```

Лямбда-функции для нетипичной сортировки кортежей:
```py
points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]

print(sorted(points, key=lambda point: point[1]))             # сортируем по второму значению кортежа
print(sorted(points, key=lambda point: point[0] &#43; point[1]))  # сортируем по сумме элементов кортежа
```

---
### Передача лямбда-функций в качестве аргументов
* Функция `map()`:
```py
numbers = [1, 2, 3, 4, 5, 6]

new_numbers1 = list(map(lambda x: x&#43;1, numbers))   # увеличиваем на 1
new_numbers2 = list(map(lambda x: x*2, numbers))   # удваиваем
new_numbers3 = list(map(lambda x: x**2, numbers))  # возводим в квадрат


strings = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
numbers = [3, 2, 1, 4, 5]

new_strings = list(map(lambda x, y: x*y, strings, numbers))
```

* Функция `filter()`:
```py
numbers = [-1, 2, -3, 4, 0, -20, 10, 30, -40, 50, 100, 90]

positive_numbers = list(filter(lambda x: x &gt; 0, numbers))   # положительные числа
large_numbers = list(filter(lambda x: x &gt; 50, numbers))     # числа, большие 50
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # четные числа


words = [&#39;python&#39;, &#39;stepik&#39;, &#39;beegeek&#39;, &#39;iq-option&#39;]

new_words1 = list(filter(lambda w: len(w) &gt; 6, words))  # слова длиною больше 6 символов
new_words2 = list(filter(lambda w: &#39;e&#39; in w, words))    # слова содержащие букву e
```

* Функция `reduce()`:
```py
from functools import reduce

words = [&#39;python&#39;, &#39;stepik&#39;, &#39;beegeek&#39;, &#39;iq-option&#39;]
numbers = [1, 2, 3, 4, 5, 6]

summa = reduce(lambda x, y: x &#43; y, numbers, 0)
product = reduce(lambda x, y: x * y, numbers, 1)
sentence = reduce(lambda x, y: x &#43; &#39; loves &#39; &#43; y, words, &#39;Everyone&#39;)
```

```
# Вывод:
21
720
Everyone loves python loves stepik loves beegeek loves iq-option
```

---
### Возвращение лямбда-функции в качестве результата другой функции
Следующий пример показывает, что анонимные функции являются **замыканиями**, т.е. возвращаемая функция запоминает значения переменных `a, b, c` из внешнего окружения:
```py
def generator_square_polynom(a, b, c):
    return lambda x: a*x**2 &#43; b*x &#43; c
```

---
### Условный оператор в теле лямбда-функции
Общий вид: `значение1 if условие else значение2`.
```py
numbers = [-2, 0, 1, 2, 17, 4, 5, 6]

result = list(map(lambda x: &#39;even&#39; if x % 2 == 0 else &#39;odd&#39;, numbers))

print(result)

# Вывод: [&#39;even&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;]
```

---
### Передача аргументов в анонимную функцию
Анонимные функции поддерживают все способы передачи аргументов:
- позиционные;
- именованные;
- `*args` – переменный список позиционных аргументов;
- `**kwargs` – переменный список именованных аргументов;
- `*` – обязательные аргументы.

```py
f1 = lambda x, y, z: x &#43; y &#43; z
f2 = lambda x, y, z=3: x &#43; y &#43; z
f3 = lambda *args: sum(args)
f4 = lambda **kwargs: sum(kwargs.values())
f5 = lambda x, *, y=0, z=0: x &#43; y &#43; z


print(f1(1, 2, 3))
print(f2(1, 2))
print(f2(1, y=2))
print(f3(1, 2, 3, 4, 5))
print(f4(one=1, two=2, three=3))
print(f5(1))
print(f5(1, y=2, z=3))
```

```
# Вывод:
6
6
6
15
6
1
6
```

---
## **Функции any(), all(), zip(), enumerate()**
### Функция `all()`
Встроенная функция `all()` возвращает значение `True`, если &lt;b&gt;все элементы&lt;/b&gt; переданной ей коллекции истинны, и `False` в противном случае. При работе со словарями функция `all()` проверяет на соответствие параметрам `True` **ключи** словаря.
```py
print(all([1, 2, 3]))   
print(all([1, 2, 3, 0, 5]))
print(all([True, 0, 1]))
print(all((&#39;&#39;, &#39;red&#39;, &#39;green&#39;)))
print(all({0j, 3&#43;4j}))

print()

dict1 = {0: &#39;Zero&#39;, 1: &#39;One&#39;, 2: &#39;Two&#39;}
dict2 = {&#39;Zero&#39;: 0, &#39;One&#39;: 1, &#39;Two&#39;: 2}
print(all(dict1))
print(all(dict2))
```

```
# Вывод:
True
False
False
False
False

False
True
```

Если переданный итерируемый объект пуст, то функция `all()` возвращает значение **`True`**.
```py
print(all([]))        # передаем пустой список
print(all(()))        # передаем пустой кортеж
print(all(&#39;&#39;))        # передаем пустую строку
print(all([[], []]))  # передаем список, содержащий пустые списки
```

```
# Вывод:
True
True
True
False
```

---
### Функция `any()`
Встроенная функция `any()` возвращает значение `True`, если &lt;b&gt;хотя бы один элемент&lt;/b&gt; переданной ей коллекции является истинным, и `False` в противном случае. При работе со словарями функция `any()` проверяет на соответствие `True` ключи словаря.
```py
print(any([0, 0, 0]))
print(any([0, 1, 0]))
print(any([False, 0, 1]))
print(any([&#39;&#39;, [], &#39;green&#39;]))
print(any({0j, 3&#43;4j, 0.0}))

print()

dict1 = {0: &#39;Zero&#39;}
dict2 = {&#39;Zero&#39;: 0, &#39;One&#39;: 1}
print(any(dict1))
print(any(dict2))
```

```
# Вывод:
False
True
True
True
True

False
True
```

Если переданный итерируемый объект пуст, то функция `any()` возвращает значение **`False`**.
```py
print(any([]))        # передаем пустой список
print(any(()))        # передаем пустой кортеж
print(any(&#39;&#39;))        # передаем пустую строку
print(any([[], []]))  # передаем список, содержащий пустые списки
```

```
# Вывод:
False
False
False
False
```

---
### Функции `all()`, `any()` в связке с `map()`
Следующий код проверяет, все ли элементы списка больше 10:
```py
numbers = [17, 90, 78, 56, 231, 45, 5, 89, 91, 11, 19]

result = all(map(lambda x: True if x &gt; 10 else False, numbers))  # анонимную функцию можно упростить до lambda x: x &gt; 10

if result:
    print(&#39;Все числа больше 10&#39;)
else:
    print(&#39;Хотя бы одно число меньше или равно 10&#39;)
```

Следующий код проверяет, чётен ли хотя бы один элемент коллекции:
```py
numbers = [17, 91, 78, 55, 231, 45, 5, 89, 99, 11, 19]

result = any(map(lambda x: x % 2 == 0, numbers))

if result:
    print(&#39;Хотя бы одно число четное&#39;)
else:
    print(&#39;Все числа нечетные&#39;)
```

---
### Функция `enumerate()`
Встроенная функция `enumerate()` возвращает кортеж из индекса элемента и самого элемента переданной ей коллекции: `enumerate(iterable, start)`, где `iterable` – итерируемый объект (коллекция), а `start` – необязательный параметр, задающий начальное значение индекса (по умолчанию `start = 0`). Эта функция возвращает объект-итератор, который можно перебрать, преобразовать в список функцией `list()` или распаковать `*`.
```py
colors = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
print(list(enumerate(colors, start=1)))

# Вывод: [(1, &#39;red&#39;), (2, &#39;green&#39;), (3, &#39;blue&#39;)]
```

---
### Функция `zip()`
Встроенная функция `zip()` объединяет отдельные элементы из каждой переданной ей коллекции в кортежи. Также возвращает итератор, который можно перебрать, преобразовать или распаковать. Если функции `zip()` передать итерируемые объекты, имеющие разную длину, то объект с наименьшим количеством элементов определяет итоговую длину.
```py
numbers = [1, 2, 3, 4]
words = [&#39;one&#39;, &#39;two&#39;]
romans = [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;]

result = zip(numbers, words, romans)
print(list(result))

# Вывод: [(1, &#39;one&#39;, &#39;I&#39;), (2, &#39;two&#39;, &#39;II&#39;)]
```

```py
numbers = [1, 2, 3]
words = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
romans = [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;]

result = zip(numbers, words, romans)
print(list(result))

# Вывод: [(1, &#39;one&#39;, &#39;I&#39;), (2, &#39;two&#39;, &#39;II&#39;), (3, &#39;three&#39;, &#39;III&#39;)]
```

Частые случаи использования `zip()`:
* Для создания словарей, если ключи и значения находятся в разных списках:
```py
keys = [&#39;name&#39;, &#39;age&#39;, &#39;gender&#39;]
values = [&#39;Timur&#39;, 28, &#39;male&#39;]

info = dict(zip(keys, values))
print(info)

# Вывод: {&#39;name&#39;: &#39;Timur&#39;, &#39;age&#39;: 28, &#39;gender&#39;: &#39;male&#39;}
```

* Для параллельного итерирования по разным коллекциям:
```py
name = [&#39;Timur&#39;, &#39;Ruslan&#39;, &#39;Rustam&#39;]
age = [28, 21, 19]

for x, y in zip(name, age):
    print(x, y)
```

```
# Вывод:
Timur 28
Ruslan 21
Rustam 19
```


---

> Автор: [NoisyCake](https://t.me/noisycake)  
> URL: http://localhost:1313/notes/functions2/  

