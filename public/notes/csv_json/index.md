# Работа с csv и json файлами в Python


Управление текстовыми файлами формата `csv, tsv, dtv, json` в языке программирования Python
&lt;!--more--&gt;
## Формат CSV
CSV (от англ. Comma-Separated Values — значения, разделённые запятыми) — текстовый формат, предназначенный для представления табличных данных. Строка таблицы соответствует строке текста, которая содержит одно или несколько полей, разделенных запятыми.

К примеру, следующая таблица:
|Rank|Language|Share|
|:--:|:--:|:--:|
|1|Python|31.17%|
|2|Java|17.75%|
|3|JavaScript|8%|
|4|C#|7.05%|
|5|PHP|6.09%|

в формате `csv` будет выглядеть следующим образом:
```
Rank,Language,Share
1,Python,31.17%
2,Java,17.75%
3,JavaScript,8%
4,C#,7.05%
5,PHP,6.09%
```

Подобные файлы можно обрабатывать вручную подобно `txt` — считывать, разделять на строки и отдельные элементы по разделителям с помощью `split()`, но в Python есть отдельный модуль для работы с файлами формата `dsv`.

{{&lt; admonition info &gt;}}
`dsv` (англ. delimiter separated values — «значения, разграниченные разделителем») общий формат для форм `csv`, `tsv` (англ. tab separated values — «значения, разделенные табуляцией») и других.
{{&lt; /admonition &gt;}}

---
## Модуль `csv`
Для использования: `import csv`

В данном модуле есть два основных объекта: `reader` и `writer`, созданные, чтобы читать и создавать `csv` файлы соответственно.

### Чтение через `reader`
Рассмотрим файл `products.csv`, содержащий информацию о товарах интернет магазина:
```
keywords,price,product_name
Садовый стул,1699,ВЭДДО
Садовый стул,2999,ЭПЛАРО
Садовый табурет,1699,ЭПЛАРО
Садовый стол,1999,ТЭРНО
Складной стол,7499,ЭПЛАРО
Настил,1299,РУННЕН
Стеллаж,1299,ХИЛЛИС
Кружка,39,СТЕЛЬНА
Молочник,299,ВАРДАГЕН
Термос для еды,699,ЭФТЕРФРОГАД
Ситечко,59,ИДЕАЛИСК
Чайник заварочный,499,РИКЛИГ
Кофе-пресс,699,УПХЕТТА
Чашка с блюдцем,249,ИКЕА
Кружка,249,ЭМНТ
Ситечко,199,САККУННИГ
Кружка,199,ФИНСТИЛТ
Тарелка,269,ЭВЕРЕНС
```

Код ниже читает содержимое файла и выводит его построчно:
```py
import csv

with open(&#39;products.csv&#39;, encoding=&#39;utf-8&#39;) as file:
    rows = csv.reader(file)  # создаём reader объект
    for row in rows:
        print(row)
```

```
# Вывод:
[&#39;keywords&#39;, &#39;price&#39;, &#39;product_name&#39;]
[&#39;Садовый стул&#39;, &#39;1699&#39;, &#39;ВЭДДО&#39;]
[&#39;Садовый стул&#39;, &#39;2999&#39;, &#39;ЭПЛАРО&#39;]
[&#39;Садовый табурет&#39;, &#39;1699&#39;, &#39;ЭПЛАРО&#39;]
[&#39;Садовый стол&#39;, &#39;1999&#39;, &#39;ТЭРНО&#39;]
[&#39;Складной стол&#39;, &#39;7499&#39;, &#39;ЭПЛАРО&#39;]
[&#39;Настил&#39;, &#39;1299&#39;, &#39;РУННЕН&#39;]
[&#39;Стеллаж&#39;, &#39;1299&#39;, &#39;ХИЛЛИС&#39;]
[&#39;Кружка&#39;, &#39;39&#39;, &#39;СТЕЛЬНА&#39;]
[&#39;Молочник&#39;, &#39;299&#39;, &#39;ВАРДАГЕН&#39;]
[&#39;Термос для еды&#39;, &#39;699&#39;, &#39;ЭФТЕРФРОГАД&#39;]
[&#39;Ситечко&#39;, &#39;59&#39;, &#39;ИДЕАЛИСК&#39;]
[&#39;Чайник заварочный&#39;, &#39;499&#39;, &#39;РИКЛИГ&#39;]
[&#39;Кофе-пресс&#39;, &#39;699&#39;, &#39;УПХЕТТА&#39;]
[&#39;Чашка с блюдцем&#39;, &#39;249&#39;, &#39;ИКЕА&#39;]
[&#39;Кружка&#39;, &#39;249&#39;, &#39;ЭМНТ&#39;]
[&#39;Ситечко&#39;, &#39;199&#39;, &#39;САККУННИГ&#39;]
[&#39;Кружка&#39;, &#39;199&#39;, &#39;ФИНСТИЛТ&#39;]
[&#39;Тарелка&#39;, &#39;269&#39;, &#39;ЭВЕРЕНС&#39;]
```

Объект `reader` дает доступ к построчному итератору, полностью аналогичному работе с файлом или списком.

После выполнения строки `rows = csv.reader(file)` в переменную `rows` будет записан итератор, с помощью которого можно «пробежаться» циклом по файлу. В каждой итерации цикла при этом будет доступна соответствующая строка файла, уже разбитая по запятым и представляющая собой список. При этом автоматически будут учтены все нюансы с запятыми внутри кавычек и самими кавычками.

При создании `reader` объекта можно указать:
- аргумент `delimiter` — односимвольная строка, используемая для разделения полей, по умолчанию имеет значение `&#39;,&#39;`
- аргумент `quotechar` — односимвольная строка, используемая для кавычек в полях, содержащих специальные символы, по умолчанию имеет значение `&#39;&#34;&#39;`.

---
### Чтение через `DictReader`
В модуле `csv` есть специальный объект `DictReader`, который поддерживает создание объекта-словаря на основе названий столбцов. С помощью `DictReader` объекта можно обращаться к полям не по индексу, а по названию, что делает код более понятным.

Немного поменяем содержимое файла `products.csv`. Теперь разделителем будет точка с запятой, также заключим текст с запятыми в кавычки во избежание ошибок при разделении строки на элементы:
```
keywords;price;product_name
&#34;Садовый стул, стул для дачи&#34;;1699;ВЭДДО
Садовый стул;2999;ЭПЛАРО
Садовый табурет;1699;ЭПЛАРО
Садовый стол;1999;ТЭРНО
&#34;Складной стол, обеденный стол&#34;;7499;ЭПЛАРО
Настил;1299;РУННЕН
Стеллаж;1299;ХИЛЛИС
&#34;Кружка, сосуд, стакан с ручкой&#34;;39;СТЕЛЬНА
Молочник;299;ВАРДАГЕН
Термос для еды;699;ЭФТЕРФРОГАД
Ситечко;59;ИДЕАЛИСК
Чайник заварочный;499;РИКЛИГ
Кофе-пресс;699;УПХЕТТА
Чашка с блюдцем;249;ИКЕА
&#34;Кружка, стакан с ручкой&#34;;249;ЭМНТ
Ситечко;199;САККУННИГ
Кружка;199;ФИНСТИЛТ
&#34;Тарелка, блюдце&#34;;269;ЭВЕРЕНС
```

Теперь прочитаем этот файл, используя `DictReader`:
```py
import csv

with open(&#39;products.csv&#39;, encoding=&#39;utf-8&#39;) as file:
    rows = csv.DictReader(file, delimiter=&#39;;&#39;, quotechar=&#39;&#34;&#39;)
    for row in rows:
        print(row)
```

```
# Вывод:
{&#39;keywords&#39;: &#39;Садовый стул, стул для дачи&#39;, &#39;price&#39;: &#39;1699&#39;, &#39;product_name&#39;: &#39;ВЭДДО&#39;}
{&#39;keywords&#39;: &#39;Садовый стул&#39;, &#39;price&#39;: &#39;2999&#39;, &#39;product_name&#39;: &#39;ЭПЛАРО&#39;}
{&#39;keywords&#39;: &#39;Садовый табурет&#39;, &#39;price&#39;: &#39;1699&#39;, &#39;product_name&#39;: &#39;ЭПЛАРО&#39;}
{&#39;keywords&#39;: &#39;Садовый стол&#39;, &#39;price&#39;: &#39;1999&#39;, &#39;product_name&#39;: &#39;ТЭРНО&#39;}
{&#39;keywords&#39;: &#39;Складной стол, обеденный стол&#39;, &#39;price&#39;: &#39;7499&#39;, &#39;product_name&#39;: &#39;ЭПЛАРО&#39;}
{&#39;keywords&#39;: &#39;Настил&#39;, &#39;price&#39;: &#39;1299&#39;, &#39;product_name&#39;: &#39;РУННЕН&#39;}
{&#39;keywords&#39;: &#39;Стеллаж&#39;, &#39;price&#39;: &#39;1299&#39;, &#39;product_name&#39;: &#39;ХИЛЛИС&#39;}
{&#39;keywords&#39;: &#39;Кружка, сосуд, стакан с ручкой&#39;, &#39;price&#39;: &#39;39&#39;, &#39;product_name&#39;: &#39;СТЕЛЬНА&#39;}
{&#39;keywords&#39;: &#39;Молочник&#39;, &#39;price&#39;: &#39;299&#39;, &#39;product_name&#39;: &#39;ВАРДАГЕН&#39;}
{&#39;keywords&#39;: &#39;Термос для еды&#39;, &#39;price&#39;: &#39;699&#39;, &#39;product_name&#39;: &#39;ЭФТЕРФРОГАД&#39;}
{&#39;keywords&#39;: &#39;Ситечко&#39;, &#39;price&#39;: &#39;59&#39;, &#39;product_name&#39;: &#39;ИДЕАЛИСК&#39;}
{&#39;keywords&#39;: &#39;Чайник заварочный&#39;, &#39;price&#39;: &#39;499&#39;, &#39;product_name&#39;: &#39;РИКЛИГ&#39;}
{&#39;keywords&#39;: &#39;Кофе-пресс&#39;, &#39;price&#39;: &#39;699&#39;, &#39;product_name&#39;: &#39;УПХЕТТА&#39;}
{&#39;keywords&#39;: &#39;Чашка с блюдцем&#39;, &#39;price&#39;: &#39;249&#39;, &#39;product_name&#39;: &#39;ИКЕА&#39;}
{&#39;keywords&#39;: &#39;Кружка, стакан с ручкой&#39;, &#39;price&#39;: &#39;249&#39;, &#39;product_name&#39;: &#39;ЭМНТ&#39;}
{&#39;keywords&#39;: &#39;Ситечко&#39;, &#39;price&#39;: &#39;199&#39;, &#39;product_name&#39;: &#39;САККУННИГ&#39;}
{&#39;keywords&#39;: &#39;Кружка&#39;, &#39;price&#39;: &#39;199&#39;, &#39;product_name&#39;: &#39;ФИНСТИЛТ&#39;}
{&#39;keywords&#39;: &#39;Тарелка, блюдце&#39;, &#39;price&#39;: &#39;269&#39;, &#39;product_name&#39;: &#39;ЭВЕРЕНС&#39;}
```

При создании `DictReader` объекта значениями по умолчанию для аргументов `delimiter` и `quotechar` являются `&#39;,&#39;` (символ запятой) и `&#39;&#34;&#39;` (символ двойной кавычки) соответственно.

{{&lt; admonition info &gt;}}
Названия столбцов сохраняются в атрибуте `fieldnames` объекта `DictReader`
{{&lt; /admonition &gt;}}

---
### Запись через `writer`
Для записи данных в `csv` файл можно использовать специальный `writer` объект:
```py
import csv

columns = [&#39;first_name&#39;, &#39;second_name&#39;, &#39;class_number&#39;, &#39;class_letter&#39;]
data = [[&#39;Тимур&#39;, &#39;Гуев&#39;, 11, &#39;А&#39;], [&#39;Руслан&#39;, &#39;Чаниев&#39;, 9, &#39;Б&#39;], [&#39;Артур&#39;, &#39;Харисов&#39;, 10, &#39;В&#39;]]

with open(&#39;students.csv&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;&#39;) as file:
    writer = csv.writer(file)
    writer.writerow(columns)                 # запись заголовков
    for row in data:                         # запись строк
        writer.writerow(row)
```

```
# Создаётся файл students.csv с содержимым:
first_name,second_name,class_number,class_letter
Тимур,Гуев,11,А
Руслан,Чаниев,9,Б
Артур,Харисов,10,В
```

При открытии файла функцией `open()` был использован параметр `newline` со значением `&#39;&#39;` (пустая строка), который отвечает за переводы строк при чтении или записи в текстовый файл. По умолчанию имеет значение `None`, в этом случае все разделители строк преобразуются в `&#39;\n&#39;`. Если в файле оказывается лишний перевод строки, то следует использовать этот параметр в режиме `newline=&#39;&#39;`, тогда `&#39;\n&#39;` будет преобразован в пустую строку.

При создании `writer` объекта так же можно его настраивать, задавая `delimiter` и многие другие параметры.

```py
import csv

columns = [&#39;first_name&#39;, &#39;second_name&#39;, &#39;class_number&#39;, &#39;class_letter&#39;]
data = [[&#39;Тимур&#39;, &#39;Гуев&#39;, 11, &#39;А&#39;], [&#39;Руслан&#39;, &#39;Чаниев&#39;, 9, &#39;Б&#39;], [&#39;Роман&#39;, &#39;Белых&#39;, 10, &#39;В&#39;]]

with open(&#39;students.csv&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;&#39;) as file:
    writer = csv.writer(file, delimiter=&#39;;&#39;, quoting=csv.QUOTE_NONNUMERIC)
    writer.writerow(columns)
    for row in data:
        writer.writerow(row)
```

```
# Создаётся файл students.csv с содержимым:
&#34;first_name&#34;;&#34;second_name&#34;;&#34;class_number&#34;;&#34;class_letter&#34;
&#34;Тимур&#34;;&#34;Гуев&#34;;11;&#34;А&#34;
&#34;Руслан&#34;;&#34;Чаниев&#34;;9;&#34;Б&#34;
&#34;Роман&#34;;&#34;Белых&#34;;10;&#34;В&#34;
```

Значение аргумента `quoting=csv.QUOTE_NONNUMERIC` означает, что в кавычки будут браться все нечисловые значения. По умолчанию символом кавычки является `&#34;`, если нужно поменять символ, используется уже знакомый нам именованный аргумент `quotechar`.

Для `quoting` существуют и другие константы из модуля `csv`:
* `QUOTE_ALL`: указывает объектам записи указывать все поля
* `QUOTE_MINIMAL`: указывает объектам записи заключать в кавычки только те поля, которые содержат специальные символы, такие как разделитель `delimiter`, кавычка `quotechar` или любой из символов в `lineterminator`
* `QUOTE_NONNUMERIC`: указывает объектам записи указывать все нечисловые поля
* `QUOTE_NONE`: указывает объектам записи никогда не заключать в кавычки поля

Помимо метода `writerow()` можно использовать и метод `writerows()`, чтобы записать сразу несколько строк. Единственным аргументом этого метода может быть коллекция коллекций. То есть, каждый элемент списка `rows` в нашем случае должен быть коллекцией. Если `rows` будет, например, списком чисел, программа завершится с ошибкой.

---
### Запись через `DictWriter`
Для записи данных в `csv` файл также можно использовать `DictWriter` объект, который позволяет записывать содержимое словаря в файл.

```py
import csv

data = [{&#39;first_name&#39;: &#39;Тимур&#39;, &#39;second_name&#39;: &#39;Гуев&#39;, &#39;class_number&#39;: 11, &#39;class_letter&#39;: &#39;А&#39;},
        {&#39;first_name&#39;: &#39;Руслан&#39;, &#39;second_name&#39;: &#39;Чаниев&#39;, &#39;class_number&#39;: 9, &#39;class_letter&#39;: &#39;Б&#39;},
        {&#39;first_name&#39;: &#39;Роман&#39;, &#39;second_name&#39;: &#39;Белых&#39;, &#39;class_number&#39;: 10, &#39;class_letter&#39;: &#39;В&#39;}]

columns = [&#39;first_name&#39;, &#39;second_name&#39;, &#39;class_number&#39;, &#39;class_letter&#39;]

with open(&#39;students.csv&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;&#39;) as file:
    writer = csv.DictWriter(file, fieldnames=columns, delimiter=&#39;;&#39;, quoting=csv.QUOTE_NONNUMERIC)
    writer.writeheader()                 # запись заголовков
    for row in data:                     # запись строк
        writer.writerow(row)
```

```
# Создаётся файл students.csv с содержимым:
&#34;first_name&#34;;&#34;second_name&#34;;&#34;class_number&#34;;&#34;class_letter&#34;
&#34;Тимур&#34;;&#34;Гуев&#34;;11;&#34;А&#34;
&#34;Руслан&#34;;&#34;Чаниев&#34;;9;&#34;Б&#34;
&#34;Роман&#34;;&#34;Белых&#34;;10;&#34;В&#34;
```

{{&lt; admonition danger &gt;}}
Ключи словарей, которые записываются в файл, должны совпадать с названиями полей, которые переданы в качестве аргумента `fieldnames`, иначе будет возникать ошибка `ValueError`.
{{&lt; /admonition &gt;}}

---
## Формат json
JSON (англ. JavaScript Object Notation, читается как &#34;джЕйсон&#34;) — текстовый формат обмена данными, основанный на синтаксисе объекта в языке программирования JavaScript. Как и многие другие текстовые форматы, JSON легко читается людьми. Несмотря на происхождение от JavaScript, формат считается независимым от языка и может использоваться практически с любым языком программирования.

В отличие от формата `csv`, данные в формате `json` не просто разделены запятыми, а чаще всего имеют структуру ключ-значение. Это напоминает словарь Python, но в отличие от словаря, ключи в `json` могут быть только строками, заключенными в **двойные кавычки**:
```json
{
   &#34;firstName&#34;: &#34;Тимур&#34;,
   &#34;lastName&#34;: &#34;Гуев&#34;,
   &#34;gender&#34;: &#34;мужской&#34;
}
```

Преимущества, которые сделали этот формат популярным:
1. не занимает много места, является компактным в написании и быстро компилируется
2. создание текстового содержимого понятно человеку, просто в реализации, а чтение со стороны среды разработки не вызывает никаких проблем. Чтение может осуществляться и человеком, поскольку ничего сложного в представлении данных нет
3. структура преобразуется для чтения на любых языках программирования
4. практически все языки имеют соответствующие библиотеки или другие инструменты для чтения данных JSON

В качестве значений в JSON могут быть использованы:
* число (целое или вещественное);
* литералы `true` (истина), `false` (ложь), `null` (отсутствие значения);
* строка (последовательность символов, заключенная в двойные кавычки);
* список (заключается в квадратные скобки `[ ]`, значения разделяются запятыми). Список может быть пустым, значения в пределах одного списка могут иметь разный тип;
* вложенный объект (неупорядоченное множество пар ключ: значение, заключённое в фигурные скобки `{ }`). Ключ описывается строкой, между ним и значением стоит символ `:`. Пары ключ-значение отделяются друг от друга запятыми.
```json
{
   &#34;firstName&#34;: &#34;Тимур&#34;,
   &#34;lastName&#34;: &#34;Гуев&#34;,
   &#34;age&#34;: 29,
   &#34;gender&#34;: &#34;мужской&#34;,
   &#34;smoke&#34;: false,
   &#34;address&#34;: {
       &#34;streetAddress&#34;: &#34;Часовая 25, кв. 127&#34;,
       &#34;city&#34;: &#34;Москва&#34;,
       &#34;postalCode&#34;: 125315
   },
   &#34;phoneNumbers&#34;: [&#34;&#43;7 (919) 424-84-34&#34;, &#34;&#43;7 (916) 928-92-34&#34;]
}
```

{{&lt; admonition info &gt;}}
Вложенность данных может быть бесконечной
{{&lt; /admonition &gt;}}

Также, переносы строк и отступы в формате `json` необязательны. Они нужны только для удобства чтения.
```json
{&#34;firstName&#34;: &#34;Тимур&#34;, &#34;lastName&#34;: &#34;Гуев&#34;, &#34;gender&#34;: &#34;мужской&#34;}
```

{{&lt; admonition info &gt;}}
JSON — это текстовый формат, который может быть представлен не только в виде пар ключ-значение (объектов). Он так же может содержать список, строку, число и т.д. Тем не менее, чаще всего используется структура ключ-значение. При этом, объекты являются неупорядоченными, списки же, наоборот, упорядочены
{{&lt; /admonition &gt;}}

---
## Модуль `json`
Для использования: `import json`

Преобразование переменных программы (Python-объектов) в формат для хранения называется [«сериализацией»](https://noisycake.ru/notes/zip_pkl), а обратное преобразование — «десериализацией». В Python для сериализации и десериализации в формат `json` есть одноимённый модуль.

### Функция `dumps()`
Для сериализации данных в `json` строку используется функция `dumps()` из модуля `json`. Для того, чтобы сериализовать данные с ее помощью, достаточно передать в нее аргументом любой сериализуемый Python-объект. 
```py
import json

data = {&#39;name&#39;: &#39;Russia&#39;, &#39;phone_code&#39;: 7, &#39;capital&#39;: &#39;Moscow&#39;, &#39;currency&#39;: &#39;RUB&#39;}

json_data = json.dumps(data)            # сериализуем словарь data в json строку

print(type(json_data))
print(json_data)
```

```
# Вывод:
&lt;class &#39;str&#39;&gt;
{&#34;name&#34;: &#34;Russia&#34;, &#34;phone_code&#34;: 7, &#34;capital&#34;: &#34;Moscow&#34;, &#34;currency&#34;: &#34;RUB&#34;}
```

{{&lt; admonition info &gt;}}
Независимо от того, какие кавычки использовались в Python-объекте, в результате данные будут в двойных кавычках (стандарт `json`)
{{&lt; /admonition &gt;}}

### Функция `dump()`
В отличие от функции `dumps()`, которая сериализует Python-объект в `json` строку, функция `dump()` записывает переданный Python-объект в файл.
```py
import json

data = {&#39;name&#39;: &#39;Russia&#39;, &#39;phone_code&#39;: 7, &#39;capital&#39;: &#39;Moscow&#39;, &#39;currency&#39;: &#39;RUB&#39;}

with open(&#39;countries.json&#39;, &#39;w&#39;) as file:
    json.dump(data, file)
```

```json
// Создаётся файл countries.json с содержимым:
{&#34;name&#34;: &#34;Russia&#34;, &#34;phone_code&#34;: 7, &#34;capital&#34;: &#34;Moscow&#34;, &#34;currency&#34;: &#34;RUB&#34;}
```

{{&lt; admonition info &gt;}}
Возможно сериализовать любой объект, поддерживаемый форматом `json`, например число, список, строку и т.д
{{&lt; /admonition &gt;}}

#### `indent`, `sort_keys` и `separators`
Функции записи `dumps()` и `dump()` имеют необязательные аргументы `indent`, `sort_keys` и `separators`, которые можно использовать для более удобного чтения человеком.

* Аргумент `indent` задает отступ от левого края. По умолчанию имеет значение `None` для более компактного представления без отступов. Если значением `indent` является строка, то она используется в качестве отступа.

* Аргумент `sort_keys` задает сортировку ключей в результирующем `json`. По умолчанию имеет значение `False` для более быстрого выполнения. Если установить значение аргумента в `True`, то ключи будут отсортированы в алфавитном порядке, что особенно удобно, когда ключей много.

* Аргумент `separators` задает кортеж, состоящий из двух элементов `(item_separator, key_separator)`, которые представляют разделители для элементов и ключей. По умолчанию аргумент имеет значение `(&#39;, &#39;, &#39;: &#39;)`.

```py
import json

data = {&#39;name&#39;: &#39;Russia&#39;, &#39;phone_code&#39;: 7, &#39;capital&#39;: &#39;Moscow&#39;, &#39;currency&#39;: &#39;RUB&#39;}

json_data1 = json.dumps(data)
json_data2 = json.dumps(data, indent=3, separators=(&#39;;&#39;, &#39; = &#39;), sort_keys=True)

print(json_data1)
print(json_data2)
```

```
# Вывод:
{&#34;name&#34;: &#34;Russia&#34;, &#34;phone_code&#34;: 7, &#34;capital&#34;: &#34;Moscow&#34;, &#34;currency&#34;: &#34;RUB&#34;}
{
   &#34;capital&#34; = &#34;Moscow&#34;;
   &#34;currency&#34; = &#34;RUB&#34;;
   &#34;name&#34; = &#34;Russia&#34;;
   &#34;phone_code&#34; = 7
}
```

---
### Функция `loads()`
Для десериализации данных нужно использовать функцию `loads()`. Ее аргумент — это строка с данными в формате `json`.
```py
import json

json_data = &#39;{&#34;name&#34;: &#34;Russia&#34;, &#34;phone_code&#34;: 7, &#34;capital&#34;: &#34;Moscow&#34;, &#34;currency&#34;: &#34;RUB&#34;}&#39;

data = json.loads(json_data)
print(type(data))
print(data)
```

```
# Вывод:
&lt;class &#39;dict&#39;&gt;
{&#39;name&#39;: &#39;Russia&#39;, &#39;phone_code&#39;: 7, &#39;capital&#39;: &#39;Moscow&#39;, &#39;currency&#39;: &#39;RUB&#39;}
```

{{&lt; admonition danger &gt;}}
В случае если строка для десериализации содержит данные с ошибкой, то модуль `json` не сможет правильно прочитать такую строку, и программа завершится с ошибкой `json.decoder.JSONDecodeError`
{{&lt; /admonition &gt;}}

---
### Функция `load()`
В отличие от функции `loads()`, которая в качестве аргумента принимает строку с данными в формате `json`, функция `load()` принимает файловый объект и возвращает его десериализованное содержимое.

Пусть файл `data.json` имеет следующее содержимое:
```json
{
  &#34;name&#34;: &#34;Russia&#34;,
  &#34;phone_code&#34;: 7,
  &#34;capital&#34;: &#34;Moscow&#34;,
  &#34;cities&#34;: [&#34;Abakan&#34;, &#34;Almetyevsk&#34;, &#34;Anadyr&#34;, &#34;Anapa&#34;, &#34;Arkhangelsk&#34;, &#34;Astrakhan&#34;],
  &#34;currency&#34;: &#34;RUB&#34;
}
```

Тогда следующий код преобразует `data.json` в словарь `data` и выведет его элементы:
```py
import json

with open(&#39;data.json&#39;) as file:
    data = json.load(file)                # передаем файловый объект
    for key, value in data.items():
        if type(value) == list:
            print(f&#39;{key}: {&#34;, &#34;.join(value)}&#39;)
        else:
            print(f&#39;{key}: {value}&#39;)
```

```
# Вывод:
name: Russia
phone_code: 7
capital: Moscow
cities: Abakan, Almetyevsk, Anadyr, Anapa, Arkhangelsk, Astrakhan
currency: RUB
```

### Типы данных в `json`
Модуль `json` автоматически определяет тип значения при десериализации. Такая автоматическая работа с типами данных выгодно отличает `json` от `csv`, при работе с которым таких автоматических преобразований нет.

Важно также понимать, что при преобразовании данных в формат JSON, данные не всегда будут того же типа, что исходные данные в Python. Например, кортежи при записи в JSON превращаются в списки. Так происходит из-за того, что в JSON используются другие типы данных, и не для всех типов данных Python есть соответствия.

Таблица конвертации типов данных Python в JSON:
|Python|JSON|
|:--:|:--:|
|`dict`|`object`|
|`list, tuple`|`array`|
|`str`|`string`|
|`int, float`|`number`|
|`True`|`true`|
|`False`|`false`|
|`None`|`null`|

Таблица конвертации JSON в типы данных Python:
|JSON|Python|
|:--:|:--:|
|`object`|`dict`|
|`array`|`list`|
|`string`|`str`|
|`number (int)`|int|
|`number (real)`|`float`|
|`true`|`True`|
|`false`|`False`|
|`null`|`None`|

### Ограничение по типам данных
В формат JSON нельзя записать словарь, у которого ключи – кортежи. Поэтому есть необязательный аргумент `skipkeys`, который игнорирует элементы с подобными ключами:
```py
import json

data = {
        &#39;beegeek&#39;: 2018,
        (&#39;Timur&#39;, &#39;Guev&#39;): 29,
        (&#39;Arthur&#39;, &#39;Kharisov&#39;): 20,
        &#39;stepik&#39;: 2013
       }

json_data = json.dumps(data, skipkeys=True)        # преобразуем dict в json

print(json_data)
```

```
# Вывод:
{&#34;beegeek&#34;: 2018, &#34;stepik&#34;: 2013}
```

{{&lt; admonition info &gt;}}
В JSON ключами словаря могут быть только строки. Но, если в словаре Python использовались числа, булевы значения или `None`, то ошибки не будет, вместо этого они будут преобразованы в строки.
{{&lt; /admonition &gt;}}

### Кириллические символы в json
Вывод следующего кода может вызвать смущение:
```py
import json

data = {&#39;firstName&#39;: &#39;Иван&#39;, &#39;lastName&#39;: &#39;Иванов&#39;}
s = json.dumps(data)
print(s)
```

```
# Вывод:
{&#34;firstName&#34;: &#34;\u0418\u0432\u0430\u043d&#34;, &#34;lastName&#34;: &#34;\u0418\u0432\u0430\u043d\u043e\u0432&#34;}
```

Каждая буква из строк `Иван` и `Иванов` будет заменена на её код. Эти коды стандартны, и код для каждой из букв индивидуален. Например `0438` — код буквы `и`. Обратное преобразование из строки в словарь вернет закодированное значение в первоначальный вид.

С помощью необязательного аргумента `ensure_ascii` функций `dumps()` и `dump()` можно отказаться от такого кодирования:
```py
import json

data = {&#39;firstName&#39;: &#39;Тимур&#39;, &#39;lastName&#39;: &#39;Гуев&#39;}
s = json.dumps(data, ensure_ascii=False)
print(s)
result = json.loads(s)
print(result)
```

```
# Вывод:
{&#34;firstName&#34;: &#34;Тимур&#34;, &#34;lastName&#34;: &#34;Гуев&#34;}
{&#39;firstName&#39;: &#39;Тимур&#39;, &#39;lastName&#39;: &#39;Гуев&#39;}
```

Python преобразует такую строку обратно в словарь без проблем (поскольку использует Unicode по умолчанию), но нужно помнить, что это может привести к проблемам с преобразованием в программах, написанных на других языках программирования.

---

> Автор: [NoisyCake](https://t.me/noisycake)  
> URL: http://localhost:1313/notes/csv_json/  

