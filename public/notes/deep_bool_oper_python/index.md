# Углубление в логические операторы Python


![](feature.png)

Конспект посвящён скрытым особенностям и неочевидным деталям логических операторов в Python
&lt;!--more--&gt;
## Truthy и falsy объекты

`Falsy` — объекты, которые могут быть оценены как значение `False`. К ним относятся следующие объекты:
* Значение `False`
* Значение `None`
* Числовые нули: `0`, `0.0`, `0j`, `Decimal(0)`, `Fraction(0, 1)`
* Пустые последовательности и коллекции: `b&#39;&#39;`, `bytearray(b&#39;&#39;)`, `&#39;&#39;`, `[]`, `()`, `{}`, `set()`, `range(0)`

`Truthy` — объекты, которые могут быть оценены как значение `True`. К ним относятся все объекты, не относящиеся к `falsy`.

Чтобы представить такие объекты в булевом виде, можно использовать функцию `bool()`.

---
## Операторы `and` и `or`
Операторы `and` и `or` не приводят свои результаты принудительно к значениям `True` или `False`, а возвращают **один из своих операндов**. Такой подход позволяет использовать эти операторы в более общих операциях, а не только в булевых.

Для начала посмотрим на оператор `or`:
```py
print(None or 0)
print(0 or 5)
print(&#39;beegeek&#39; or None)
print([1, 2, 3] or [6, 9])

print(1 or &#39;beegeek&#39; or None)
print(0.0 or &#39;habr&#39; or {&#39;one&#39;: 1})
print(0 or &#39;&#39; or [6, 9])
print(0 or &#39;&#39; or [])
print(0 or &#39;&#39; or [] or {})
```

```
# Вывод:
0
5
beegeek
[1, 2, 3]
1
habr
[6, 9]
[]
{}
```

Как можно видеть, оператор `or` оценивает каждый свой операнд как `truthy` или `falsy` объект, однако возвращает не значение `True` или `False`, а сам объект по определенному правилу — первый `truthy` объект либо последний объект, если `truthy` объекты в логическом выражении не найдены.

Подобным образом с помощью `or` можно определять значение по умолчанию, к примеру:
```py
greet = input(&#34;Ваше имя &gt;&gt; &#34;) or &#34;noname&#34;
print(f&#34;Привет, {greet}!&#34;)
```

Если пользователь ничего не передаст в функцию `input()`, в переменную `greet` попадёт строка `&#34;noname&#34;`.

Перейдём к оператору `and`:
```py
print(None and 10)
print(5 and 0.0)
print(&#39;beegeek&#39; and {})
print([1, 2, 3] and [6, 9])

print(1 and &#39;beegeek&#39; and None)
print(&#39;habr&#39; and 0 and {&#39;one&#39;: 1})
print(10 and [6, 9] and [])
```

```
# Вывод:
None
0.0
{}
[6, 9]
None
0
[]
```

Оператор `and` возвращает первый `falsy` объект либо последний объект, если `falsy` объекты в логическом выражении не найдены.

---
## Short-circuit evaluation
Операторы `and` и `or` укорачивают вычисление своих операндов (т.е. используют замыкания): правый операнд вычисляется лишь в том случае, если его значение необходимо для получения истинного значения в операциях `and` или `or`. Другими словами, замыкания в логических операциях используются для запуска второй части или последующих частей логического выражения только в том случае, если это актуально!
* Если левый операнд оператора `or` является `truthy` объектом, то общим результатом логического выражения является `True`, независимо от значения правого операнда.
* Если левый операнд оператора `and` является `falsy` объектом, то общим результатом логического выражения является `False`, независимо от значения правого операнда.

Данный механизм называется вычислением по короткой схеме (short-circuit evaluation) и используется интерпретатором для оптимизации вычислений. Рассмотрим пример:
```py
def f():
    print(&#39;bee&#39;)
    return 3
  
if True or f():
    print(&#39;geek&#39;)

# Вывод: geek
```

Левым операндом оператора or является `truthy` объект, значит, для вычисления общего результата логического выражения нет необходимости вычислять правый операнд, то есть вызывать функцию `f()`. Поскольку вызова функции не происходит, в выводе отсутствует строка `bee`.

И наоборот, если заменить `or` на `and`, в выводе будут обе строки.

---
## Приоритет логических операторов
Приоритет указан от наивысшего к наименьшему:
1. `not`
2. `and`
3. `or`

По отношению к другим операторам Python (за исключением оператора присваивания `=`) **логические операторы имеют самый низкий приоритет**. 
```py
a = 5
b = 7
print(not a == b)  # True
```

В этом коде сначала сравниваются значения переменных, затем применяется оператор `not`.

Стоит упомянуть, что подобная запись будет вызывать исключение `SyntaxError`:
```py
a = 5
b = 7
print(a == not b)
```

Рассмотрим ещё один пример:
```py
print(not 1 == 2 or 3 == 3 and 5 == 6)

# Вывод: True
```

Согласно приоритету операторов в первую очередь вычисляются выражения `1 == 2`, `3 == 3` и `5 == 6`, в результате чего исходное выражение принимает вид `not False or True and False`. Далее выполняется оператор `not`, возвращая значение `True`, после него — оператор `and`, возвращая значение `False`. Выражение принимает вид `True or False`. Последним выполняется оператор `or`, возвращая общий результат выражения — значение `True`.  
P.S. На самом деле после вычисления `not 1 == 2` оператор `or` сразу вернёт `True`, не вычисляя правую часть.

---
## Цепочки сравнений
Как известно, сравнивать объекты в Python можно в укороченной форме, например вместо `a &lt; b and b &lt; c` писать `a &lt; b &lt; c`

Поскольку оператор `and` реализует вычисление по короткой схеме, все сравнения, которые располагаются правее сравнения, вернувшего ложный результат, не выполняются, и их операнды не вычисляются:
```py
def f():
    print(&#39;bee&#39;)
    return 3

if 5 &lt; 1 &lt; f():
    print(&#39;geek&#39;)
else:
    print(&#39;beegeek&#39;)

# Вывод: beegeek
```

Пояснение: выражение `5 &lt; 1 &lt; f()` эквивалентно выражению `5 &lt; 1 and 1 &lt; f()`. Сравнение `5 &lt; 1` возвращает `False`. В результате сравнение `1 &lt; f()` не выполняется, и функция `f()` не вызывается.

Тем не менее между сокращенным и расширенным вариантами записи цепочек сравнений существует важное отличие. В сокращенном выражении значение, стоящее по середине (между операторами сравнения), будет вычислено один раз (если его вообще нужно вычислять), а в развёрнутом выражении — два раза:
```py
def f():
    print(&#39;bee&#39;)
    return 3

if 1 &lt; f() &lt; 5:
    print(&#39;geek&#39;)

print()

if 1 &lt; f() and f() &lt; 5:
    print(&#39;geek&#39;)
```

```
# Вывод:
bee
geek

bee
bee
geek
```

Помимо операторов сравнения, в цепочку операторов могут объединяться и другие операторы Python.
```py
lst = [1, 2, 3]
num = 2

print(num in lst == True)

# Вывод: False
```

Данное выражение на самом деле эквивалентно выражению `num in lst and lst == True`, которое, в свою очередь, эквивалентно выражению `True and False`. Следовательно, результатом данной цепочки операторов является значение `False`.

Рассмотрим ещё один пример:
```py
a = 5
b = 5
c = 10

print(a &lt; c is True)        
print(a == b in [True])
```

```
# Вывод:
False
False
```

---

**Основной источник:** https://habr.com/ru/articles/824170/  

Доп. источники: 
* [Russian Python Docs](https://docs-python.ru/tutorial/operatsii-and-or-not-python/)
* [Stackoverflow](https://stackoverflow.com/questions/39983695/what-is-truthy-and-falsy-how-is-it-different-from-true-and-false)

---

> Автор: [NoisyCake](https://t.me/noisycake)  
> URL: http://localhost:1313/notes/deep_bool_oper_python/  

