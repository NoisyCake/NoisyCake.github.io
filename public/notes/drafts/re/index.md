# Модуль re


Конспект посвящён регулярным выражениям и модулю `re`
&lt;!--more--&gt;

## Регулярные выражения

**Регулярные выражения** (regexp, regex) — формальный язык, используемый в программах для поиска и осуществления манипуляций с подстрокой в тексте, используя шаблон (pattern).

Регулярное выражение состоит из обычных символов и специальных последовательностей. Оно обычно используется для:
* Поиска подстрок в строке;
* Разделения строки на подстроки;
* Замены части строки.

Любая строка сама по себе уже является регулярным выражением, так, шаблону `Soup` будет соответствовать подстрока `Soup`. Регулярные выражения являются регистрозависимыми. В них присутствуют специальные символы, которые нужно экранировать, если их требуется использовать по прямому назначению (просто как символы): `.^$*&#43;?{}[]\|()`.

### Основные символы
|Pattern|Description|
|:--:|--|
|`.`|Любой символ, кроме `\n`|
|`^`|Начало строки|
|`$`|Конец строки|
|`*`|0 или более повторений предшествующего элемента|
|`&#43;`|1 или более повторений предшествующего элемента|
|`?`|0 или 1 повторение предшествующего элемента|
|`{n}`|Ровно n повторений предшествующего элемента|
|`{n,}`|n или более повторений предшествующего элемента|
|`{n,m}`|От n до m повторений предшествующего элемента|
|`[]`|Любой одиночный символ из указанных в квадратных скобках|
|`[^]`|Любой одиночный символ, не указанный в квадратных скобках|
|`\`|Экранирование специальных символов|
|`\|`|Логическое ИЛИ|
|`()`|Группировка выражений и сохранение совпадений|

### Метасимволы
|Pattern|Description|
|:--:|--|
|`\d`|Любая цифра|
|`\D`|Любой символ, кроме цифры|
|`\w`|Любой алфавитный символ, цифра или `_`|
|`\W`|Любой символ, кроме алфавитного, цифры и `_`|
|`\s`|Любой пробельный символ (`[ \f\n\r\t\v]`)|
|`\S`|Любой непробельный символ|
|`\b`|Граница слова. Соответствует позиции, а не символу|
|`\B`|Не начало и не конец слова|

### Наборы и диапазоны
В регулярных выражениях набор символов определяется с помощью специальных символов `[` и `]`. Они часто используются для выполнения поиска, не зависящего от регистра.

{{&lt; admonition info &gt;}}
В пределах `[` `]` символ `.` можно не экранировать
{{&lt; /admonition &gt;}}

Так, регулярному выражению `[ns]a.\.csv` будет соответствовать:
&lt;pre&gt;&lt;code&gt;sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
&lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;sam.csv&lt;/span&gt;&lt;/b&gt;
&lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;na1.csv&lt;/span&gt;&lt;/b&gt;
&lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;na2.csv&lt;/span&gt;&lt;/b&gt;
&lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;sa1.csv&lt;/span&gt;&lt;/b&gt;
ca1.csv
&lt;/code&gt;&lt;/pre&gt;

Для указания диапазона символов используется `-`. Например: [а-яА-Я] (буквы `ё` и `Ё` не включаются). Если в набор требуется включить `-`, нужно указывать его вне диапазона.

Так, регулярному выражению `[ns]a[0-9]\.csv` будет соответствовать:
&lt;pre&gt;&lt;code&gt;sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
sam.csv
&lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;na1.csv&lt;/span&gt;&lt;/b&gt;
&lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;na2.csv&lt;/span&gt;&lt;/b&gt;
&lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;sa1.csv&lt;/span&gt;&lt;/b&gt;
ca1.csv
&lt;/code&gt;&lt;/pre&gt;

{{&lt; admonition info &gt;}}
При использовании диапазонов нужно следить, чтобы конец диапазона не был меньше, чем его начало. К примеру, диапазоны `[4-1]` или `[z-a]` недопустимы.
{{&lt; /admonition &gt;}}

Если нужно соответствие с чем угодно, кроме некоторых символов, можно поставить `^` перед набором или диапазоном.

Так, регулярному выражению `[ns]a[^0-9]\.csv` будет соответствовать:
&lt;pre&gt;&lt;code&gt;sales1.csv
orders3.csv
sales2.csv
sales3.csv
apac1.csv
europe2.csv
&lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;sam.csv&lt;/span&gt;&lt;/b&gt;
na1.csv
na2.csv
sa1.csv
ca1.csv
&lt;/code&gt;&lt;/pre&gt;

### Соответствие нескольким символам
Символ `&#43;` устанавливает соответствие с одним или более символами. Таким образом, если регулярное выражение `a` соответствует одному символу `a`, то регулярное выражение `a&#43;` соответствует одному или нескольким символам `a`. Точно так же, учитывая, что регулярное выражение `[0-9]` соответствует любой цифре, регулярное выражение `[0-9]&#43;` соответствует последовательности, состоящей из одной или нескольких цифр.

Для того чтобы установить соответствие с необязательными символами в регулярных выражениях используется специальный символ `*`. Он используется в точности так, как `&#43;`: записывается сразу после символа или набора и соответствует нулю или большему количеству вхождений.

Чтобы установить соответствие с необязательным символом, используется `?`. 

Так, регулярному выражению `https?://[\w./]&#43;` будет соответствовать: &lt;pre&gt;&lt;code&gt;URL &lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;http://stepik.org/&lt;/span&gt;&lt;/b&gt; уже не безопасен. Для безопасного подключения вместо него используйте &lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;https://stepik.org/&lt;/span&gt;&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;

Поскольку перечисленные специальные символы не позволяют явно установить минимальное и максимальное количество совпадений, существуют **интервалы**, которые определяются `{` и `}`. 
* Чтобы указать точное количество совпадений, нужно вставить число в фигурные скобки: `#[0-9A-Fa-f]{6}`.
* Чтобы указать интервал-диапазон, нужно указать два числа через запятую: `\d{1,2}[-/]\d{1,2}[-/]\d{2,4}`.
* Чтобы указать &#34;не более&#34; или &#34;не менее&#34;, нужно ставить запятые перед или после числа-границы: `\d{,2}` или `\d{2,}`.

{{&lt; admonition info &gt;}}
При использовании интервал-диапазона не нужно ставить пробелы между запятой и числом
{{&lt; /admonition &gt;}}

### Жадность и ленивость
Специальные символы `*` и `&#43;` являются жадными. Они ищут наибольшее возможное соответствие. Например, есть регулярное выражение `&lt;B&gt;.*&lt;/B&gt;`: &lt;pre&gt;&lt;code&gt;Подписку нельзя оформить клиентам, живущим в &lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;\&lt;B&gt;России\&lt;/B&gt;, а также \&lt;B&gt;Беларуси\&lt;/B&gt;&lt;/span&gt;&lt;/b&gt;. Приносим свои извинения.&lt;/code&gt;&lt;/pre&gt;

Если требуется использовать ленивое поведение, нужно ставить `?` после символа:
|Жадный|Ленивый|
|`*`|`*?`|
|`&#43;`|`&#43;?`|
|`?`|`??`|
|`{m,n}`|`{m,n}?`|
|`{,n}`|`{,n}?`|
|`{m,}`|`{m,}?`|

Теперь рассмотрим регулярное выражение `&lt;B&gt;.*?&lt;/B&gt;`: &lt;pre&gt;&lt;code&gt;Подписку нельзя оформить клиентам, живущим в &lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;\&lt;B&gt;России\&lt;/B&gt;&lt;/span&gt;&lt;/b&gt;, а также &lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;\&lt;B&gt;Беларуси\&lt;/B&gt;&lt;/span&gt;&lt;/b&gt;. Приносим свои извинения.&lt;/code&gt;&lt;/pre&gt;

### Группы
**Группа** — часть регулярного выражения (подвыражение), заключённое в круглые скобки: `(` и `)`. Группы обрабатываются как единый объект, поэтому, например, выражение `(\daf){2}` будет означать повторение `\daf` два раза. 

Таким образом, если нужно найти в строке IP-адрес (без проверки на правильность), можно использовать `(\d{1,3}\.){3}\d{1,3}`.

Группы можно вкладывать друг в друга, поэтому, если для уже озвученной задачи также необходима проверка на правильность адреса, можно использовать: `(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((2[0-4]\d)|(25[0-5])|(1\d{2})|(\d{1,2}))`

Чтобы сослаться на существующую группу, нужно экранировать её порядковый номер. Номера распределяются по открывающим скобкам, начиная с 1. Например, регулярному выражению `(\b\w&#43;\b)[ ]&#43;\1` соответствует:
&lt;pre&gt;&lt;code&gt;Это текст, в &lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;котором котором&lt;/span&gt;&lt;/b&gt; несколько &lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;слов    слов&lt;/span&gt;&lt;/b&gt; повторяются, хотя они и &lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;не   не&lt;/span&gt;&lt;/b&gt; должны &lt;b&gt;&lt;span style=&#34;color: rgb(51, 153, 102)&#34;&gt;повторяться повторяться&lt;/span&gt;&lt;/b&gt;.&lt;/code&gt;&lt;/pre&gt;

В новых реализациях регулярных выражений можно именовать группу. В Python это делается так: `(?P&lt;name&gt;&lt;regex&gt;)`.

---
## Модуль `re`

Для использования: `import re`

`re` — модуль Python, предназначенный для работы с регулярными выражениями.

### Объект `Match`
Объект типа `Match` представляет собой результат поиска, выполненного с использованием регулярных выражений. Когда используются функции, такие как `re.search()`, `re.match()` и т.п., они возвращают объект типа `Match`, если совпадение найдено.

Рассмотрим методы объекта.

#### `group()`
Метод `Match.group([group1, ...])` возвращает одну или несколько подгрупп совпадения.
```py
from re import search

match = search(&#39;(\w&#43;),(\w&#43;),(\w&#43;)&#39;, &#39;foo,bar,baz&#39;)

print(match.group())
print(match.group(0))
print(match.group(1))
print(match.group(2))
print(match.group(3))
print(match.group(1, 2, 3))
```
```
# Вывод:
foo,bar,baz
foo,bar,baz
foo
bar
baz
(&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;)
```

{{&lt; admonition bug &gt;}}
Если методу передать индекс несуществующей группы, будет возбуждено исключение `IndexError`
{{&lt; /admonition &gt;}}

Переданная в качестве аргумента группа может появляться несколько раз, при этом можно указывать любые группы в любом порядке:
```py
from re import search

match = search(&#39;(\w&#43;),(\w&#43;),(\w&#43;)&#39;, &#39;foo,bar,baz&#39;)

print(match.group(1, 2, 3, 1, 2, 2, 3, 3, 3, 3))

# Вывод: (&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;baz&#39;, &#39;baz&#39;, &#39;baz&#39;)
```

Именованные группы также могут использоваться:
```py
from re import search

match = search(&#39;(?P&lt;w1&gt;\w&#43;),(?P&lt;w2&gt;\w&#43;),(?P&lt;w3&gt;\w&#43;)&#39;, &#39;foo,bar,baz&#39;)

print(match.group())
print(match.group(&#39;w1&#39;))
print(match.group(&#39;w2&#39;))
print(match.group(&#39;w3&#39;))
print(match.group(&#39;w1&#39;, &#39;w2&#39;, &#39;w3&#39;, &#39;w2&#39;, &#39;w3&#39;))
```

#### `groups()`
Метод `Match.groups(default=None)` возвращает кортеж, содержащий все захваченные группы.
```py
from re import search

match = search(&#39;(\w&#43;),(\w&#43;),(\w&#43;)?&#39;, &#39;foo,bar,&#39;)

print(match.groups())

# Вывод: (&#39;foo&#39;, &#39;bar&#39;, None)
```

Группы, которые не смогли захватить какой-либо результат, по умолчанию будут иметь значение `None`. Если в такой ситуации требуется вернуть значение, отличное от `None`, то используется необязательный аргумент `default`.

#### `groupdict()`
Метод `Match.groupdict(default=None)` возвращает словарь, содержащий все захваченные именованные группы.

Если именованных групп в исходном регулярном выражении нет, метод `groupdict()` возвращает пустой словарь.

#### `start()` и `end()`
Методы `Match.start([group])` и `Match.stop([group])` возвращают индексы начала и конца подстроки, которая совпала с регулярным выражением.

В них также можно передать номер или название группы. В этом случае методы вернут индексы начала и конца подстроки, совпадающей с нужной группой.

#### `span()`
Метод `Match.span([group]) возвращает индексы начала и конца подстроки в виде кортежа, которая совпала с регулярным выражением. В него также можно передать номер или название группы, в этом случае метод вернет индексы начала и конца подстроки в виде кортежа, совпадающей с нужной группой.

### Функция `search()`
Функция `re.search(pattern, string, flags=0)` сканирует строку в поисках **первого совпадения** с регулярным выражением и возвращает объект типа `Match` или значение `None`, если ни одна позиция в строке не соответствует регулярному выражению. 

Аргументы:
* `pattern` — шаблон регулярного выражения
* `string` — строка для поиска
* `flags` — один или несколько флагов

```py
from re import search

match1 = search(&#39;super&#39;, &#39;superstition&#39;)
match2 = search(&#39;super&#39;, &#39;insuperable&#39;)
match3 = search(&#39;super&#39;, &#39;without&#39;)

print(match1)
print(match2)
print(match3)
```
```
# Вывод:
&lt;re.Match object; span=(0, 5), match=&#39;super&#39;&gt;
&lt;re.Match object; span=(2, 7), match=&#39;super&#39;&gt;
None
```

### Функция `match()`
Функция `re.match(pattern, string, flags=0)` возвращает объект типа `Match`, если начало строки соответствуют регулярному выражению, или значение `None` в противном случае.

```py
from re import match

match1 = match(&#39;super&#39;, &#39;superstition&#39;)
match2 = match(&#39;super&#39;, &#39;insuperable&#39;)

print(match1)
print(match2)
```
```
&lt;re.Match object; span=(0, 5), match=&#39;super&#39;&gt;
None
```

### Функция `fullmatch()`
Функция `re.fullmatch(pattern, string, flags=0)` возвращает объект типа `Match`, если вся строка соответствует регулярному выражению, или значение `None` в противном случае. Её удобно использовать для валидации правильности данных.

```py
from re import fullmatch

match1 = fullmatch(&#39;\d&#43;&#39;, &#39;123foo&#39;)
match2 = fullmatch(&#39;\d&#43;&#39;, &#39;foo123&#39;)
match3 = fullmatch(&#39;\d&#43;&#39;, &#39;foo123bar&#39;)
match4 = fullmatch(&#39;\d&#43;&#39;, &#39;123&#39;)

print(match1)
print(match2)
print(match3)
print(match4)
```
```
# Вывод:
None
None
None
&lt;re.Match object; span=(0, 3), match=&#39;123&#39;&gt;
```

### Функция `escape()`
Функция `re.escape(pattern)` экранирует специальные символы в строке.

```py
from re import escape

print(escape(&#39;http://www.stepik.org&#39;))

# Вывод: http://www\.stepik\.org
```

### Функция `findall()`
Функция `re.findall(pattern, string, flags=0)` возвращает все неперекрывающиеся совпадения с регулярным выражением в виде списка строк. Строка сканируется слева направо, и совпадения возвращаются в найденном порядке.

```py
import re

text = &#39;ул. Часовая, дом № 25, корпус 2, квартира 69&#39;
result = re.findall(&#39;\d&#43;&#39;, text)

print(result)

# Вывод: [&#39;25&#39;, &#39;2&#39;, &#39;69&#39;]
```

Если регулярное выражение содержит одну группу, то `findall()` вернёт список соответствующих групп, а не список полных совпадений с регулярным выражением:
```py
import re

result = re.findall(&#39;#(\w&#43;)#&#39;, &#39;#foo#.#bar#.#baz#&#39;)

print(result)

# Вывод: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]
```

Если регулярное выражение содержит несколько групп, то `findall()` вернёт список кортежей, каждый из которых содержит захваченные группы. При этом длина каждого кортежа равна указанному количеству групп:
```py
import re

result1 = re.findall(&#39;(\w&#43;),(\w&#43;)&#39;, &#39;foo,bar,baz,qux,quux,corge&#39;)
result2 = re.findall(&#39;(\w&#43;),(\w&#43;),(\w&#43;)&#39;, &#39;foo,bar,baz,qux,quux,corge&#39;)

print(result1)
print(result2)
```
```
[(&#39;foo&#39;, &#39;bar&#39;), (&#39;baz&#39;, &#39;qux&#39;), (&#39;quux&#39;, &#39;corge&#39;)]
[(&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;), (&#39;qux&#39;, &#39;quux&#39;, &#39;corge&#39;)]
```

### Функция `finditer()`
Функция `re.finditer(pattern, string, flags=0)` возвращает все неперекрывающиеся совпадения с регулярным выражением в виде итератора, содержащего объекты типа `Match`. Строка сканируется слева направо, и совпадения возвращаются в найденном порядке.

```py
import re

text = &#39;ул. Часовая, дом № 25, корпус 2, квартира 69&#39;
result = re.finditer(&#39;\d&#43;&#39;, text)

print(type(result))
print(list(result))
```
```
# Вывод:
&lt;class &#39;callable_iterator&#39;&gt;
[&lt;re.Match object; span=(19, 21), match=&#39;25&#39;&gt;, &lt;re.Match object; span=(30, 31), match=&#39;2&#39;&gt;, &lt;re.Match object; span=(42, 44), match=&#39;69&#39;&gt;]
```
Функции `findall()` и `finditer()` очень похожи, но есть два отличия:\
* `findall()` возвращает список, в то время как `finditer()` возвращает итератор;
* `findall()` возвращает список, содержащий фактические строки, в то время как элементами итератора, который возвращает `finditer()`, являются объекты типа `Match`.

### Функция `sub()`
Функция `re.sub(pattern, repl, string, count=0, flags=0)` возвращает строку, полученную путем замены всех найденных неперекрывающихся вхождений регулярного выражения `pattern` в строке `string` на строку замены `repl`. Если шаблон регулярного выражения не найден, строка возвращается без изменений.

Аргумент `repl` может быть строкой или функцией. Если `repl` это строка, то в ней обрабатываются все обратные слеши, то есть `\n` преобразуется в символ новой строки, `\r` преобразуется в возврат каретки и т. д.

Аргумент `count` используется для ограничения количеств замен.

#### Замена строкой
Если `repl` является строкой, то `sub()` вставляет ее в строку поиска `string` вместо любых последовательностей, соответствующих регулярному выражению `pattern`.
```py
import re

text = &#39;foo.123.bar.456.baz.789.geek&#39;

result1 = re.sub(r&#39;\d&#43;&#39;, r&#39;#&#39;, text)
result2 = re.sub(r&#39;[a-z]&#43;&#39;, r&#39;(*)&#39;, text)

print(result1)
print(result2)
```
```
# Вывод:
foo.#.bar.#.baz.#.geek
(*).123.(*).456.(*).789.(*)
```

При использовании функции `sub()` также можно использовать пронумерованные обратные ссылки (`\&lt;n&gt;`) в аргументе `repl`, которым будет соответствовать текст захваченной группы. Обратные ссылки, такие как `\2`, заменяются подстрокой, соответствующей группе №2 в шаблоне регулярного выражения:
```py
import re

result = re.sub(r&#39;(\w&#43;),bar,baz,(\w&#43;)&#39;, r&#39;\2,bar,baz,\1&#39;, r&#39;foo,bar,baz,qux&#39;)

print(result)

# Вывод: qux,bar,baz,foo
```

Аналогично работает и с именованными группами.

#### Замена с помощью функции
Если в качестве аргумента `repl` использовать функцию, то `sub()` вызовет эту функцию для каждого найденного совпадения. Она передает каждый соответствующий объект типа `Match` в качестве аргумента функции для предоставления информации о совпадении, при этом возвращаемое из функции значение становится строкой замены.

```py
import re
def func(match_obj):
    s = match_obj.group(0)         # строка совпадения
    if s.isdigit():
        return str(int(s) * 10)
    else:
        return s.upper()

result = re.sub(r&#39;\w&#43;&#39;, func, r&#39;foo.10.bar.20.baz30.40&#39;)

print(result)

# Вывод: FOO.100.BAR.200.BAZ30.400
```

### Функция `subn()`
Функция `re.subn(pattern, repl, string, count=0, flags=0)` идентична функции `sub()`, за тем исключением, что она возвращает кортеж, состоящий из изменённой строки и количества сделанных замен.

```py
import re

text = &#39;foo.123.bar.456.baz.789.geek&#39;

result1 = re.subn(r&#39;\d&#43;&#39;, r&#39;#&#39;, text)
result2 = re.subn(r&#39;[a-z]&#43;&#39;, r&#39;(*)&#39;, text, count=2)

print(result1)
print(result2)
```
```
# Вывод:
(&#39;foo.#.bar.#.baz.#.geek&#39;, 3)
(&#39;(*).123.(*).456.baz.789.geek&#39;, 2)
```

### Функция `split()`
Функция `re.split(pattern, string, maxsplit=0, flags=0)` разбивает строку на подстроки, используя регулярное выражение в качестве разделителя, и возвращает подстроки в виде списка.

Аргумент `maxsplit` используется для ограничения количества разбиений.

```py
import re

result = re.split(r&#39;[,;.]&#39;, &#39;foo,bar.baz;qux;stepik,beegeek&#39;)

print(result)

# Вывод: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;qux&#39;, &#39;stepik&#39;, &#39;beegeek&#39;]
```

Если шаблон регулярного выражения содержит группы захвата, то возвращаемый список помимо подстрок также включает в себя эти группы:
```py
import re

result1 = re.split(r&#39;\s*([,;.])\s*&#39;, &#39;foo,   bar. baz   ;    qux ;  stepik   ,   beegeek&#39;)
result2 = re.split(r&#39;(\s*[,;.]\s*)&#39;, &#39;foo,   bar. baz   ;    qux ;  stepik   ,   beegeek&#39;)

print(result1)
print(result2)
```
```
# Вывод:
[&#39;foo&#39;, &#39;,&#39;, &#39;bar&#39;, &#39;.&#39;, &#39;baz&#39;, &#39;;&#39;, &#39;qux&#39;, &#39;;&#39;, &#39;stepik&#39;, &#39;,&#39;, &#39;beegeek&#39;]
[&#39;foo&#39;, &#39;,   &#39;, &#39;bar&#39;, &#39;. &#39;, &#39;baz&#39;, &#39;   ;    &#39;, &#39;qux&#39;, &#39; ;  &#39;, &#39;stepik&#39;, &#39;   ,   &#39;, &#39;beegeek&#39;]
```

Если нужно использовать группы, но при этом не нужно, чтобы разделители включались в результирующий список, то можно использовать группы без захвата, используя синтаксис `(?:&lt;regex&gt;)`:
```py
import re

result = re.split(r&#39;(?:\s*[,;.]\s*)&#39;, &#39;foo,   bar. baz   ;    qux ;  stepik   ,   beegeek&#39;)

print(result)

# Вывод: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;qux&#39;, &#39;stepik&#39;, &#39;beegeek&#39;]
```

### Функция `compile()`
Функция `re.compile(pattern, flags=0)` предварительно компилирует регулярное выражение в специальный объект (`Pattern`), который можно повторно использовать позже.

Таким образом, если одно и то же регулярное выражение используется несколько раз, предварительная компиляция позволяет отделить определение регулярного выражения от его использования, что повышает читабельность кода.

{{&lt; admonition info &gt;}}
Модуль `re` компилирует и кэширует регулярное выражение, когда оно используется в вызове функции. Если одно и то же регулярное выражение используется впоследствии в том же коде, оно не перекомпилируется. Вместо этого скомпилированное значение извлекается из кэша. В общем, нет никаких веских причин для компиляции регулярного выражения. Это всего лишь еще один инструмент в вашем наборе инструментов, который вы можете использовать, если считаете, что он улучшит читабельность или структуру вашего кода.
{{&lt; /admonition &gt;}}

```py
import re

s1, s2, s3, s4 = &#39;foo.bar&#39;, &#39;foo123bar&#39;, &#39;baz99&#39;, &#39;qux &amp; grault&#39;

regex_obj = re.compile(&#39;\d&#43;&#39;)

print(regex_obj.search(s1))
print(regex_obj.search(s2))
print(regex_obj.search(s3))
print(regex_obj.search(s4))
```

Скомпилированный объект регулярного выражения поддерживает следующие методы:
* `search(string, pos, endpos)`
* `match(string, pos, endpos)`
* `fullmatch(string, pos, endpos)`
* `findall(string, pos, endpos)`
* `finditer(string, pos, endpos)`

Данные методы ведут себя так же, как соответствующие (одноименные) им функции модуля `re`, за исключением того, что они также поддерживают необязательные аргументы `pos` и `endpos`.

Существует два способа использования скомпилированного объекта регулярного выражения.

#### 1 способ
Можно указать объект в качестве первого аргумента для функций модуля `re`, вместо шаблона регулярного выражения:
```py
import re

regex_obj = re.compile(&#39;\d&#43;&#39;)
text = &#39;ул. Часовая, дом № 25, корпус 2, квартира 69&#39;
result = re.findall(regex_obj, text)

print(result)

# Вывод: [&#39;25&#39;, &#39;2&#39;, &#39;69&#39;]
```

#### 2 способ
Можно вызывать функции как методы непосредственно из объекта регулярного выражения:
```py
import re

regex_obj = re.compile(&#39;\d&#43;&#39;)
text = &#39;ул. Часовая, дом № 25, корпус 2, квартира 69&#39;
result = regex_obj.findall(text)

print(result)

# Вывод: [&#39;25&#39;, &#39;2&#39;, &#39;69&#39;]
```




### Флаги
Некоторые рассмотренные функции принимают необязательный аргумент `flags`. Использование флагов изменяет поведение синтаксического анализа регулярных выражений, позволяя еще больше уточнить сопоставление с образцом.  
В приведенной ниже таблице кратко перечислены доступные флаги:
|Shortname|Fullname|Purpose|
|:--:|:--:|--|
|**`re.I`**|**`re.IGNORECASE`**|Игнорирует регистр символов|
|**`re.M`**|**`re.MULTILINE`**|Используется совместно со специальными символами `^` и `$`, в первом случае возвращает совпадения в начале каждой новой строки `\n`, во втором – в конце `\n`|
|**`re.S`**|**`re.DOTALL`**|Заставляет символ `.` возвращать совпадения по абсолютно всем символам, включая `\n`|
|`re.X`|`re.VERBOSE`|Разрешает комментарии в регулярном выражении|
|`-`|`re.DEBUG`|Показывает отладочную информацию о скомпилированном регулярном выражении|
|`re.A`|`re.ASCII`|Указывает кодировку ASCII для классификации символов `\w`, `\W`, `\b`, `\B`, `\d`, `\D`, `\s`, `\S`|
|`re.U`|`re.UNICODE`|Указывает кодировку Unicode для классификации символов  `\w`, `\W,` `\b`, `\B`, `\d`, `\D`, `\s`, `\S`|
|`re.L`|`re.LOCALE`|Учитывает региональные настройки при использовании метасимволов `\w`, `\W`, `\b`, `\B`, `\s`, `\S`|

{{&lt; admonition info &gt;}}
Чтобы использовать несколько флагов одновременно, нужно перечислить их через оператор `|`
{{&lt; /admonition &gt;}}

```py
import re

match = re.search(&#39;^bar&#39;, &#39;FOO\nBAR\nBAZ&#39;, re.I | re.M)

print(match)

# Вывод: &lt;re.Match object; span=(4, 7), match=&#39;BAR&#39;&gt;
```

---

**Основной источник:** https://stepik.org/course/82541

Дополнительные источники:
* [Python Docs](https://docs.python.org/3/library/re.html)
* [Habr](https://habr.com/ru/articles/349860/)

---

> Автор: [NoisyCake](https://t.me/noisycake)  
> URL: http://localhost:1313/notes/drafts/re/  

