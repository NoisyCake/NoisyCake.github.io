[{"categories":null,"content":"\rДисклеймер: Материл носит исключительно информационный характер. Автор не призывает к каким-либо действиям. Статья-гайд, посвящённая установке своего VPN-сервера(вернее прокси) на удалённом хостинге с помощью 3X-UI панели и протокола VLESS/XTLS-Reality А вот и гайдик подъехал. Плюсы своего VPN-сервера, что такое VPS и VLESS мы обговаривали в предыдущей статье, сейчас же пошагово разберёмся, как его настроить, также обсудим некоторую теоретическую часть по ходу установки. Тут будет много работы с терминалом, поэтому желательно понимать, как взаимодействовать с этой сущностью. В Windows можно работать через PowerShell/cmd от имени администраторы, в macOS — через стандартный терминал. Если у вас Linux — вы и без меня всё знаете :) ","date":"30-12-2024","objectID":"/articles/vpn_server/:0:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Аренда сервера\rПокупаем VPS/VDS. Я пользуюсь HSHP, но он может затянуть с выдачей IP. Примеры хороших хостингов, которые можно оплатить из рф или криптой можно найти здесь и здесь. Разумеется, при покупке нужно выбирать расположение сервера вне России. Для личного пользования хватит 1 ядра и 1гб RAM, желательно хотя бы 10гб на диске, ОС — Ubuntu 22.04 (для других дальнейшие инструкции могут не подойти). Также важным фактором для нас является скорость передачи данных. По-хорошему нужно брать от 500мбит/сек, но для тестового показа я арендую дешёвенький VPS со 100мбит/сек. ","date":"30-12-2024","objectID":"/articles/vpn_server/:1:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Первое подключение к серверу\rНа своём пк открываем терминал/Bash/PowerShell от имени администратора. Пишем следующую команду ssh root@ip_сервера, где вместо “ip_сервера”, соответственно, вставляем ip своего сервера. Терминал сначала спросит, точно ли мы хотим подключиться — пишем “yes”, затем предложит ввести пароль, скорее всего при покупке хостинг самостоятельно сгенерировал его, ищем на почте или на странице купленной услуги. Инфо\rВставка текста в терминал осуществляется либо клавишами Ctrl + Shift + V, либо правой кнопкой мыши (PowerShell/cmd/PuTTY). При вбивании пароля символы отображаться не будут, поэтому удобнее делать копи-пастом. Если не получается авторизоваться, хотя пароль правильный, измените раскладку клавиатуры на английскую.\rИнфо\rSSH — сетевой протокол, позволяющий удалённо управлять ОС\rЕсли вы видите приглашение типа root@host_name — вы внутри, поздравляю! Да, тут нет привычного графического интерфейса как в обычном пк, но он и не нужен, ведь всё можно сделать через консоль. ","date":"30-12-2024","objectID":"/articles/vpn_server/:2:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Защита сервера\rroot — стандартная учётная запись администратора, которая чаще других становится целью брутфорс-атак (перебора паролей). Обезопасим себя, создав нового пользователя и запретив вход для root (также называемого суперпользователем). Пишем adduser новое_имя, придумываем сложный пароль и вбиваем/вставляем его. Для генерации сильных паролей я использую KeePass. Дальше нажимаем Enter несколько раз, пока не появится вопрос. Жмём y. Даём новому пользователю возможность выполнять команды от имени суперпользователя: usermod -aG sudo имя_пользователя, выходим из системы командой exit либо закрывая терминал. Зайдём под именем созданного пользователя: ssh имя_пользователя@ip_сервера, и проверим работоспособность командой sudo ls -la /root. Вывод есть? Значит всё хорошо, идём дальше. Теперь перед каждой командой, требующей доступ администратора, нам придётся писать sudo и вводить пароль (единоразово для сессии), ведь мы работаем не через суперпользователя, имеющего доступ ко всему и вся. Так, пора бы обновить систему. Пишем sudo apt update \u0026\u0026 sudo apt full-upgrade -y и ждём. Установим nano: sudo apt install nano, откроем конфиг SSH командой sudo nano /etc/ssh/sshd_config и изменим параметр “PermitRootLogin” с “yes” на “no”. Инфо\rnano — консольный текстовый редактор Linux (UNIX-подобных ОС). Он покажется довольно специфичным юзеру, пользовавшемся только графическими редакторами, поэтому вот пару советов, которые могут вам помочь: Передвигать курсор мышкой не получится, впрочем как и во всём терминале, так что используйте для этого стрелки на клавиатуре. Нажмите Ctrl + O -\u003e Enter, чтобы сохранить файл; Нажмите Ctrl + X, чтобы выйти из редактора. Так лучше, теперь root не сможет зайти в систему никоим образом. Ещё один важный шаг: нужно перевесить порт SSH с дефолтного на повыше. Открываем (если уже закрыли) тот же самый файл sshd_config, раскомментируем строку “Port”, убрав # и пишем произвольный номер порта. Нужно запомнить его. Инфо\rIP — адрес сетевого устройства, порт — адрес сетевой службы/программы на этом IP\rИнфо\rЕсли вам надоело, что соединение с сервером теряется после нескольких минут бездействия, измените значения параметров ClientAliveInterval и/или ClientAliveCountMax на более высокие. У меня стоят 300 и 12 соответственно\rНе забываем перезапустить службу SSH: sudo systemctl restart sshd. Выйдем и зайдём нормально :D Прописываем exit, затем подключаемся к серверу с нового порта: ssh имя_пользователя@ip_сервера -p номер_порта. Все предыдущие шаги были сделаны с целью обезопасить систему от непрошеных гостей. Сейчас же начнём установку 3X-UI панели, которая облегчит настройку XRay и даст графический интерфейс. - Так, стоп, а что за XRay? - XRay — ПО, выполняющее функции прокси. Оно не является таковым в физическом смысле, но содержит протоколы, транспорты и всё нужное для работы прокси-сервера. - Окей, кажется ещё упоминались какие-то VLESS и Reality? - VLESS — протокол передачи данных, поддерживающий технологии маскировки, к примеру XTLS-Reality, позволяющий скрыть трафик под обычные HTTPS запросы. - Я запутался… - Давайте ещё разок с самого начала. VPS — виртуальный сервер, размещённый на физическом. В нашем случае он находится где-то в Германии. На нём установлена операционная система, вроде Windows, но не он, а дистрибутив (реализация) Linux, называемый Ubuntu. На эту ОС мы накатим 3X-UI — программу, которая облегчит настройку XRay — ПО для маршрутизации и проксирования трафика, использующее для этой цели протоколы по типу VLESS, а последний, в свою очередь, улучшает свой функционал, работая с технологией XTLS-Reality, которая позволит маскироваться под определённый сайт. Фух, ну с объяснениями вроде закончили… ","date":"30-12-2024","objectID":"/articles/vpn_server/:3:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Установка 3x-ui\rВернёмся к практической части. Выполняем последовательность следующих команд: sudo apt install docker.io docker-compose -y git clone https://github.com/MHSanaei/3x-ui.git cd 3x-ui sudo nano docker-compose.yml Изменим строчки, начинающиеся с $PWD на: - /home/имя_пользователя/3x-ui/db/:/etc/x-ui/ - /home/имя_пользователя/3x-ui/cert/:/root/cert/ Выйдем из файла, предварительно сохранив изменения -\u003e вставляем sudo docker-compose up -d Готово. Теперь переходим в браузер, в поисковой строке вбиваем http://ip_сервера:2053/panel/. В качестве логина и пароля вводим дефолтные admin/admin. ","date":"30-12-2024","objectID":"/articles/vpn_server/:4:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Защита панели\rХорошо, панель есть. Теперь нужно защитить её от тех же брутфорс-атак. Для этого переходим в настройки и: Меняем корневой путь URL адреса. У меня будет /kekw/ (запишите его). Меняем порт панели. Желательно выбрать в пределах от 60000 до 65535 (также запомните или запишите). Инфо\rЧтобы изменить язык на русский, выберите страну в настройках в поле “Language”\rСохраните настройки и перезапустите панель. Теперь вы сможете войти в неё по следующему URL: http://ip_сервера:указанный_порт/корневой_путь/ На странице “Настройки безопасности” измените стандартные логин и пароль. ","date":"30-12-2024","objectID":"/articles/vpn_server/:5:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Настройка VLESS и Reality\rТеперь, наконец-таки, займёмся подключением протокола! Переходим во вкладку “Подключения” (Inbounds) и жмём плюсик. В “Примечании” (Remark) пишем любое название подключения, протокол — VLESS, “Порт IP” (Listening IP) — пустой, порт — 443. В настройках клиента меняем Email (по факту никнейм) на что-то уникальное и удобочитаемое. ID сгенерировано панелью, общий расход и дату окончания устанавливаем по усмотрению, я же оставлю эти поля пустыми. Ниже в строке “Безопасность” выбираем “Reality”, после чего в настройках клиента появляется строка “Flow”. В выпадающем окне жмём на “xtls-rprx-vision”. Возвращаемся к настройке транспорта. В “uTLS” выбирайте что хотите из знакомого и популярного, я оставил chrome. В “Dest” прописываем адрес сайта, по которому будет перенаправляться подключения для маскировке трафика. Вот тут сложнее. Желательно выбрать сайт из той же сети, в которой находится наш сервер, чтобы пинг и шанс блокировки сервера были ниже. Для Windows/Linux можно использовать эту утилиту. Переходим по ссылке, качаем на ХОСТ (т.е. ваш пк), открываем командную строку, переходим в папку скачивания и запускаем программу (для Windows: Win+R -\u003e cmd -\u003e cd Downloads -\u003e .\\RealiTLScanner-windows-64 -addr ip_сервера). Ждём несколько минут, нажимаем Ctrl+C и смотрим на вывод (также можно открыть созданный .csv файл). Получили что-то такое: Мда, не густо. Возможно дело в дешевизне хостинга VPS, ну да неважно. Главное выбрать популярный зарубежный сайт, который заблокируют с наименьшей долей вероятности для жителей РФ. Также важно учесть пинг: в идеале он должен быть \u003c10мс. Проверить можно командой ping выбранный_сайт (Ctrl + C, чтобы остановить процесс). Я выберу google.com:443, основываясь на вышеуказанных критериях. В “SNI” указываем “google.com,www.google.com”. Отныне провайдер будет думать, что вы подключаетесь к google.com, даже если вы находитесь на nelzagram.com. “Sniffing” рекомендуется оставлять по дефолту, но я включил 🤷‍♂️. ","date":"30-12-2024","objectID":"/articles/vpn_server/:6:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Подключение к VPN\rГотово! Осталось только подключиться. Для этого воспользуемся каким-либо из клиентов. Для любых устройств я рекомендую Hiddify. Чтобы скачать его, перейдите по ссылке или найдите репозиторий в поисковике, промотайте вниз до “Direct Download” и выберите свою платформу. Вернёмся к панельке. Сейчас имеем такую ситуацию: Жмём на плюсик рядом с “ID”, выпадут текущие пользователи. Тыкаем на значок qr-кода, затем на сам высветившийся qr — ссылка будет скопирована в буфер обмена. Теперь откроем Hiddify. Жмём на плюсик в правом верхнем углу, далее на “Добавить из буфера обмена”. Осталось нажать на центральную кнопку.. та-дам! Всё работает, можно пользоваться :) В параметрах конфигурации вы можете поставить регион ru, чтобы подключаться к сайтам с доменами .ru напрямую — так шанс идентификации использования прокси приближается к нулю. Если же всякие нельзяграммы так и не работают, измените в настройках режим работы на “VPN”. Учтите, что в этом случае нужно будет открыть приложение с правами администратора. У меня, к примеру, по дефолту режим стоял “Прокси”. Схема подключения на мобильных устройствах практически идентична. Ссылку можете получить, отсканировав qr или переслав через тот же телеграм. Также нужно выбрать режим работы VPN и установить регион по желанию. К слову, я использую VPN для всех сайтов (регион — Другой), и за полтора месяца проблем не было. ","date":"30-12-2024","objectID":"/articles/vpn_server/:7:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Пользователи\rДля каждого подключения есть возможность создать несколько пользователей. Для чего? Ну можно следить за расходом трафика, ограничивать его, задавать начальную и окончательную даты использования и может что-то ещё… Создать новых пользователей очень просто. Ищем наше подключение, нажимаем на значок под “Меню” -\u003e “ Добавить пользователя”. В качестве Email пишем уникальное имя, а в качестве Flow устанавливаем тот же “xtls-rprx-vision”. Супер, теперь у нас есть 2 пользователя. Ко второму может подключиться, например, наш друг. Просто берём ссылку, нажав на соответствующий qr в строке пользователя. Предупреждение\rРассчитайте, сколько устройств смогут комфортно пользоваться вашим прокси. Если вы дадите доступ слишком большому количеству людей, серверу может банально не хватить пропускной способности. Для скорости в 500мбит/c я бы ограничился 25 устройствами.\r","date":"30-12-2024","objectID":"/articles/vpn_server/:7:1","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Установка сертификата\rВверху панели вы наверняка заметили предупреждение о том, что соединение не защищено. Так и есть, ведь мы подключаемся к этой панели по протоколу http, а вот чтобы подключаться по https, нам нужен SSL/TLS сертификат. Разберём два способа подключения этой сущности. ","date":"30-12-2024","objectID":"/articles/vpn_server/:8:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Способ 1\rВообще сертификаты TLS подписываются специализированными центрами, но такой вариант может подойти не всем, так как он требует наличия домена, а это либо затраты + раскрытие своих паспортных данных, либо ненадёжные бесплатные поддомены, так что обучу вас тайной технике самоподписи… Будем пользоваться утилитой OpenSSL. Снова подключаемся к нашему серверу: ssh имя_пользователя@ip_сервера -p номер_порта -\u003e вводим пароль. Скачиваем пакеты: sudo apt install openssl (хотя скорее всего уже установлены) -\u003e снова вводим пароль. Перейдём в папку, куда устанавливали панель и создадим там директорию, где будут храниться ключи (если после второй команды вылезает ошибка, проигнорируйте её): cd 3x-ui mkdir cert cd cert Теперь создадим приватный ключ командой openssl genrsa -out private.key 2048, где вместо “private” вы можете вставить любое имя для ключа. Далее, создаём запрос на подпись сертификата: openssl req -key private.key -new -out public.csr, где вместо “public” вы также можете вставить любое имя. Сейчас у нас будут спрашивать информацию о нашем сайте / компании, которую он представляет. Оставляем всё по умолчанию, нажимая Enter, КРОМЕ пункта “Common Name”, где вписываем ip VPS сервера. И, наконец, самостоятельно подписываем сертификат: openssl x509 -signkey private.key -in public.csr -req -days 3650 -out public.crt, где вместо “3650” вы можете вставить любое число дней, на которое хотите подписать сертификат. По истечении срока вам снова придётся его подписать или создать новый. Посмотрим, что имеется в папке cert: Отлично, все файлы на месте. Открываем панельку и бежим в настройки. В поле “Путь к файлу публичного ключа сертификата панели” вводим /root/cert/public.crt, а в поле “Путь к файлу приватного ключа сертификата панели” вводим /root/cert/private.key. Нажимаем “Сохранить” в верхней левой части. Сохранилось? Ну и славно. Перезапускаем панель и видим предупреждение браузера: Это нормально, просто хром в курсе, что сертификат самоподписанный, но нехотя установит https соединение, если мы всё таки перейдём по ссылке. Ну что там, проверяем… Ура! Красное предупреждение исчезло 🥳 ","date":"30-12-2024","objectID":"/articles/vpn_server/:8:1","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Способ 2\rА для тех, кто не хочет испытывать на себе буллинг со стороны браузеров, я покажу как получить сертификат, подписанный сертифицированным центром. Так, что там нужно.. ах да, для начала — домен. Тут либо покупать, либо использовать бесплатные поддомены, я воспользуюсь вторым вариантом. Переходим на сайт и регистрируемся. К слову, кроме корректного email’а, вы можете ввести выдуманные данные. Активируем аккаунт через письмо на почте, тыкаем сюда и выбираем желаемый ПУБЛИЧНЫЙ домен -\u003e попадаем в окно настройки. В поле “Subdomain” пишем имя, которое хотим видеть перед основным доменом, в “Destination” вставляем ip сервера -\u003e сохраняем. Готово. Возвращаемся в консоль. Как и в первом способе, переходим в папку cert и используем OpenSSL: openssl genrsa -out private.key 2048; openssl req -key private.key -new -out public.csr — здесь также прожимаем Enter везде, КРОМЕ пункта “Common Name”, где вписываем ДОМЕН, который только что создали. Установим новую утилиту, которая отправит наш сертификат на подпись в центр и запросим эту подпись: docker-compose down sudo apt install certbot certbot certonly --csr public.csr --email email_адресс --agree-tos --no-eff-email 1 cat 0000_cert.pem 0000_chain.pem \u003e public.pem docker-compose up -d Предупреждение\rЕсли на этом этапе вы получили отказ из-за слишком большого количества выданных сертификатов за последнее время “There were too many requests of a given type :: too many certificates (50) already issued for…”, то нужно либо подождать указанное время и попробовать снова, либо получить и попробовать новый поддомен, расположенный в другой доменной зоне (в моём случае не .strangled.net).\rПо той же схеме переходим в настройки панели и пишем пути для сертификата в соответствующих полях: /root/cert/public.pem — путь к публичному ключу, а /root/cert/private.key — путь к приватному ключу. Вот и всё, теперь браузеры не будут ругаться! А чтобы так было, впредь нужно заходить в 3x-ui панель по следующему адресу: https://домен:указанный_порт/корневой_путь/. ","date":"30-12-2024","objectID":"/articles/vpn_server/:8:2","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Telegram бот\rИнтересная фича, которая позволит вам управлять панелью через Telegram бота. Делается всё очень и очень просто. Для начала переходим к @BotFather, стартуем -\u003e /newbot -\u003e Пишем любое имя -\u003e Пишем юзернейм с “bot” на конце -\u003e Копируем токен и вставляем его в панели в соответствующую строку в настройках Telegram бота. Сохраняем изменения и перезапускаем панель. Перейдём по ссылке к боту. Получаем свой id командой, как ни странно, /id, и также вставляем в панель, снова перезапуская её. Теперь бот знает, что вы — хозяин админ. Панель сейчас выглядит как-то так: По желанию вы можете настроить и другие параметры, например, частоту отправки уведомлений или язык бота. Так, хорошо, посмотрим, что умеет бот. Снова пишем /start — выпадает менюшка. Видим: Использование сервера, бэкапы баз данных, настройки подключений и их пользователей, просмотр онлайн клиентов и т.п. Также без подключения к самой панели через бота можно перезапускать ядро командой /restart force. Можно сделать так, чтобы пользователи тоже смогли просматривать свой объём используемого трафика. Для этого следуйте “All Clients” -\u003e “имя_подключения” -\u003e “имя_пользователя” -\u003e “Set Telegram User” -\u003e “Select Telegram User”. Теперь пользователь вашего VPN может просматривать свою информацию (но не более того). Поздравляю, бот готов! ","date":"30-12-2024","objectID":"/articles/vpn_server/:9:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"Подписки\rТоже довольно интересная функция, позволяющая придать процессу создания своего VPN коммерческий вектор. С помощью подписки можно создать ссылку сразу на несколько подключений, то есть у пользователя появится сразу несколько конфигураций VPN в клиенте, к тому же, изменения будут подтягиваться автоматически (без подписки придётся удалять и создавать подключения в клиенте заново). Вдруг какой-то перестанет работать, а тут второй как раз под рукой. Чтобы активировать эту функцию, переходим в настройки панели -\u003e “Подписка” и включаем службу. Пути к файлам сертификатов выбираем те же (оставьте пустыми, если сертификат самоподписанный), что делали для самой панели, корневой путь подписки меняем на произвольный. Порт выставляем какой-нибудь другой, но он не должен использоваться другими службами на вашем VPS. Чтобы проверить прослушиваемые порты, вбейте ss -ntlp. Выбираем любой четырёх/пятизначный НЕ из этого списка. Можно также изменить URI путь в подписке json, чтобы избавиться от предупреждения. Сохраняем конфиг и перезапускаем панельку. Получили что-то подобное: Теперь можем подключать клиентов к подписке. Для этого идём в подключения -\u003e “ Редактировать пользователя”. В выпашем окне в поле “Subscription” пишем название подписки. Это же название вы будете писать каждый раз, когда хотите присоединить клиента в другом подключении к этой подписке. Сохраняем изменения. P.S. Для примера я сделал второе подключение и вписал идентичное название подписки для его клиента. Выбираем подключение и клиента, которому присвоили подписку, жмём на значок qr, затем на qr-код ПОДПИСКИ. Возвращаемся в Hiddify -\u003e Ctrl + V. Видим новый профиль и значок перезагрузки рядом с ним. С помощью него мы и будем обновлять подписку, если понадобится вытянуть изменения настроек подключений 3x-ui панели. Также в левой менюшке “Прокси” можно выбрать конкретное подключение, которое вам нужно в данный момент. Вот гайд и подошёл к концу! Если у вас возникнут трудности/вопросы/предложения, жду их в лс! Спасибо, что читаете! Ну и конечно, с наступающим Новым Годом! 🎅🎁 ","date":"30-12-2024","objectID":"/articles/vpn_server/:10:0","tags":["vpn"],"title":"Свой VPN для самых маленьких | 3X-UI + VLESS","uri":"/articles/vpn_server/"},{"categories":null,"content":"\rДисклеймер: Материал носит исключительно информационный характер. Автор не призывает к каким-либо действиям. В этой статье разберём способы анонимизации пользователя. Также поговорим о доступе к \u003cздесь слово с корнем “блок”\u003e в РФ ресурсам. Уверен, большинство посетителей и так знают о Proxy/VPN/Tor, но если хотите поподробнее ознакомиться с каждым из них, то добро пожаловать. В ином случае ждите второй части статьи, где мы поговорим о способах анонимного общения, неотслеживаемых платежах, а также узнаем, как установить лучшую (субъективно) ОС для анонимизации. Предупреждение\rМда.. скоро вместо “VPN” придётся говорить “альтернативный способ передачи пакетов в сети” 🙃\rПримечание. Рабочие proxy и VPN постоянно меняются, к тому же их работоспособность зависит от большого количества факторов, поэтому ссылки на подобные сервисы оставлять не буду. Пожалуй, стоит начать с факта, который каждый наверняка не раз слышал: абсолютной анонимности в современном интернете не существует. Тем не менее, достаточно легко можно обеспечить себе достойный уровень скрытности, при котором вы сможете договориться со своей паранойей :) Стартуем с прокси и VPN. Скорее, как способы обхода \u003cслово с корнем “блок”\u003e, чем анонимизации, но понять базовый принцип работы будет полезно. ","date":"02-12-2024","objectID":"/articles/anonymity/:0:0","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Proxy\rProxy — промежуточный сервер между пользователем и целевым ресурсом. Работает в качестве удалённого ПК (ну это прям грубо сказано конечно…), отправляющего запросы на посещаемый веб-источник от своего имени. То есть вместо того, чтобы напрямую соединить хост (вас) с целевым сервисом, прокси-сервер пропускает трафик через себя и устанавливает соединения, заменяя исходный IP на собственный. Важно понимать, что в зависимости от протокола, прокси работает при условии, что используемая программа поддерживает проксирование. Конечно, можно подключить некоторые утилиты, позволяющие прогонять все пакеты через сервер, но лучше не заморачиваться и использовать VPN. Также некоторые прокси не поддерживают шифрования, что в контексте анонимности является существенным минусом. Перечислим основные типы прокси по протоколам: HTTP — используется для передачи запросов по протоколу HTTP, который не шифрует трафик. Работает только с веб-страницами. Неимоверно устарели из-за повсеместного использования HTTPS. HTTPS — передаёт данные по шифрованному каналу, защищая трафик между клиентом и веб-сервером. Также работает только с веб-страницами. SOCKS — более универсальный прокси-протокол, который работает с любым типом трафика (в том числе с приложениями, не поддерживающих HTTP/HTTPS), но сам по себе не шифрует данные. Легко детектируется цензорами. Shadowsocks — частично рабочий, особенно хорош при использовании через клиент Outline, но его трафик уникален, поэтому также довольно просто детектируется. Недавно был отличным протоколом для обхода \u003cслово с корнем “блок”\u003e, но сегодня уже не рекомендуется его использовать. VLESS — вкупе с XTLS-Reality является наиболее актуальным решением на сегодняшний день, поскольку умеет маскировать трафик под другой выбранный сайт. Пока РКН блокировать его не научился. В статье по настройке своего VPN мы разберём, как запустить собственный сервер с протоколом VLESS. Предупреждение\rОбратите внимание на минусы VPN в следующем разделе. Большинство из них применимо и к прокси.\rКак уже говорилось, приемлемый уровень анонимности такой способ не даст, но лично я использую его для посещения \u003cслово с корнем “блок”\u003e ресурсов. ","date":"02-12-2024","objectID":"/articles/anonymity/:1:0","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"VPN\rVPN (Virtual Private Network) — более интересная технология по сравнению с предыдущей. В ней также используются удалённые сервера, но, в отличие от большинства прокси, пакеты данных (блоки/сегменты данных / раздробленные данные) проходят этап шифрования. И также в отличие от прокси, VPN-клиент на хосте позволяет перенаправить весь интернет-трафик через VPN-сервер. Происходит это так: VPN-клиент на устройстве пользователя шифрует запросы, которые затем отправляются по заранее созданному туннелю на удалённый сервер. Там данные расшифровываются, и запрос идёт уже с IP сервера прямиком к нужному сайту. Затем ответ от этого сайта возвращается к VPN-серверу, где шифруется и передаётся пользователю по тому же туннелю, а VPN-клиент дешифрует данные. В итоге при проходе через туннель данные нельзя “прослушать”. Также, само собой, конечный сервис НЕ будет в курсе, что на самом деле запрос отправлялся хостом. Инфо\rVPN-туннель — виртуальная частная сеть, создаваемая между вашим устройством и VPN-сервером. Он не даёт злоумышленнику перехватить данные при передаче.\rНа следующем рисунке представлена поверхностная схема отправки запроса через VPN Есть несколько протоколов, реализующих работу VPN. Рассмотрим наиболее популярные из них: PPTP (Point-to-Point Tunneling Protocol) — один из старейших протоколов. Является быстро-работающим и легко-настраиваемым, но не рекомендуется к использованию из-за наличия серьёзных уязвимостей. L2TP/IPSec (Layer 2 Tunneling Protocol / Internet Protocol Security) — связка протоколов. Первый обеспечивает туннелирование, то есть группирование данных в пакеты для их конфиденциальной передачи, а второй — шифрование этих пакетов. Является безопасным, но считается устаревшим, хоть и встроен во все современные ОС. OpenVPN — современный и гибкий протокол (хоть и медленный). Шифрование происходит с помощью криптографических алгоритмов. Является одним из наиболее популярных решений для обхода цензуры. IKEv2/IPSec (Internet Key Exchange version 2 / IPSec) — быстрый (по сравнению с OpenVPN, L2TP) и стабильный протокол. WireGuard — относительно новый протокол с открытым исходным кодом. На данный момент чуть ли не самый популярный для обхода \u003cслово с корнем “блок”\u003e. Имеет “апгрейд” в виде AmneziaWG. Все они обеспечивают одну функцию, но различаются протоколами шифрования, скоростью передачи данных, сложностью настройки и поддерживаемыми платформами. Предупреждение\rГлавная общая черта перечисленных VPN и Proxy-протоколов — РКН научился их всех детектировать и блокировать 😀. Разве что ПОКА не было замечено блока амнезии и VLESS.\rМинусы VPN: Важно отметить, что хоть данные идут по зашифрованному туннелю, интернет-трафик всё равно проходит через вашего провайдера, а значит этот самый провайдер спокойно фиксирует факт использования как VPN, так и Proxy, и даже Tor’a, что, кстати, будет не сильно подозрительным с текущей политикой РКН :) DNS — система преобразования доменных имён в IP-адреса. Это преобразование, осуществляющееся DNS-серверами провайдеров, происходит, когда вы нажимаете “Enter” в поисковой строке браузера. То есть вместо noisycake.ru будет переход по следующему IP-адресу: 185.199.109.153. А нужно всё это для удобства человека, ведь кому понравится забивать набор октет вместо понятных буквенных символов? Так вот существует следующее понятие: DNS leak или утечка DNS, при которой DNS-запросы идут в обход Proxy/VPN/Tor, из-за чего провайдер видит адреса посещаемых вами сайтов. Она может произойти по нескольким причинам: неправильная настройка или “плохой” VPN, использование сторонних расширений браузера и т.д. Рекомендую ознакомиться с политикой вашего VPN-провайдера, покопаться в настройках, погуглить и запретить ОС обращаться к другим DNS-серверам, кроме как VPN’овским. Опасность\rМогут ли всё-таки “утечь” ваши данные? Однозначно, особенно при использовании бесплатных VPN-сервисов. Ведь на сервере данные становятся открытыми, а если подключаться по HTTP, то видно вообще всё, и большинство поставщиков VPN услуг пре","date":"02-12-2024","objectID":"/articles/anonymity/:2:0","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Собственный VPN-сервер\rКратко обсудим тему собственного VPN’а. Данный способ посложнее предыдущих и требует базовых навыков администрирования. Существуют такие штуки как VPS (Virtual Private Server) и VDS (Virtual Dedicated Server) — по сути синонимичные вещи, а именно виртуальные машины — эмулируемые сервера, работающие на физической машине. Собственно, когда вы покупаете VPS/VDS, вы получаете сервер, которым можете управлять удалённо. На форумах есть множество гайдов по поднятию своего VPN-сервера, но я сделал и свой, в котором рассказано об установке VPN с помощью панели 3X-UI и протокола VLESS. Всё описано пошагово, доступно, прописаны все команды, в общем справиться должен каждый. - Какой профит-то от своего VPN? Лучше уж не париться и купить подписку на готовое решение. - Когда вы подключаетесь к VPN-серверу через провайдера, параллельно с вами с этого же IP работают и другие люди (сотни, тысячи…), поэтому из-за огромного количества запросов сайты начинают относиться к адресу с недоверием. Следовательно главный плюс: отсутствие бесконечных капч, проверок и блокировок со стороны веб-сервисов. Более того, РКН постоянно блокирует существующие бесплатные (и даже платные) сервера или занижает их пропускную способность, поскольку их адреса находятся в общем доступе, в то время как ваш личный VPN-сервер будет детектироваться куда сложнее. Также со своим VPN вы получаете больший контроль и конфиденциальность, плюсом лучшую скорость по сравнению с большинством VPN-сервисов. - А минусы будут? - При использовании только лишь VPN-сервера анонимности как таковой вы всё равно не получите. Риски примерно такие же, как и с обычным VPN: утечки, мягкотелость VPS-хостинга, неправильная настройка, сопоставление и прочие неприятности. ","date":"02-12-2024","objectID":"/articles/anonymity/:3:0","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Tor\rЗдесь начинаются настоящие средства анонимности. На данный момент Tor является самым мощным средством обеспечения приватности, его работу поддерживают тысячи людей по всей планете. Если раньше он был невыносимо медленным, то сейчас им можно пользоваться достаточно комфортно. Преимущество Tor по сравнению с обычными VPN и прокси состоит в том, что он скрывает пользователя через сеть узлов, использует многослойное шифрование трафика, минимизирует отпечаток браузера, автоматически очищает куки, блокирует трекеры, является устойчивым к тотальной блокировке, да и вообще крутой кент :) Давайте разберёмся в том, как работает это чудо и на что стоит обратить внимание. ","date":"02-12-2024","objectID":"/articles/anonymity/:4:0","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Как это работает\rTor (The Onion Router) / Луковая маршрутизация — сеть из SOCKS-прокси (в контексте Tor называют узлами, реле или нодами), в роли которых обычно выступают ПК добровольцев. Каждый пакет данных по умолчанию проходит следующий путь: user -\u003e клиент Tor -\u003e входная (guard) нода -\u003e промежуточная (middle) нода -\u003e выходная (exit) нода -\u003e целевой ресурс. Инфо\rВсе активные узлы находятся в открытом доступе и каждый час публикуются в консенсусе (consensus) особыми девятью узлами, называемыми управляющими серверами (Directory Authorities).\rПри подключении к сети Tor цепочка нод выбирается случайно и меняется каждые 10 минут. Вдобавок перед отправкой пакеты шифруются столько раз, сколько узлов в цепочке, и у каждого узла есть свой ключ, дешифрующий только определённый уровень. Таким образом каждая нода будет снимать один слой шифрования и передавать следующей уже от своего имени (поэтому называется луковой маршрутизацией), вплоть до выходной, где данные становятся абсолютно “голыми”, если подключаться не через HTTPS (подробнее об этом позже). В итоге каждый узел знает адреса только двух соседних сегментов, благодаря чему выходной не обладает информацией об исходном пользователе. Ответ на запрос повторят ту же самую цепочку, но в обратном порядке: по ходу прохождения через узлы накладываются уровни шифрования, а дешифровка происходит в Tor-клиенте на ПК пользователя. Почему же используется только три узла в цепочке? Неужели больше — не лучше? Пожалуй, нет. Больше узлов = больше нагрузки на сеть Tor + медленная скорость передачи данных. Кроме того, с увеличением числа нод увеличивается и риск попасть на скомпрометированную ноду (подробнее об этом дальше). ","date":"02-12-2024","objectID":"/articles/anonymity/:4:1","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Мосты\rСуществует закрытый список нод, которые называются мостами. Они используются в качестве входных узлов, их также поддерживают добровольцы, вот только список мостов не публичный. Так зачем они нужны? Неужели обычных реле уже не хватает? А дело в том, что раз список обычных нод публичный, то его могут увидеть все, в том числе, к примеру, Роскомнадзор, который и заставляет российских провайдеров блокировать доступ к ним. Подобная ситуация происходит во многих странах, поэтому разработчики луковой сети придумали способ обхода данной проблемы: непубликуемые в общем доступе узлы. При использовании моста, цепочка-путь данных от юзера до целевого ресурса немного меняется. Теперь она выглядит так: user -\u003e клиент Tor -\u003e мост (bridge) -\u003e промежуточная нода -\u003e выходная нода -\u003e целевой ресурс. Интересный факт: На сегодняшний день доля мостов составляет около 20% от общего числа узлов. Ознакомиться с сегодняшним количеством узлов и другими метриками можно на официальном сайте: https://metrics.torproject.org/ ","date":"02-12-2024","objectID":"/articles/anonymity/:4:2","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Подключаемый транспорт\rМосты работают вместе с транспортом (pluggable transport) — инструментом, использующимся для маскировки трафика на этапе передачи между клиентов и мостом, делая его менее заметным для блокировки. После прохождения моста трафик передаётся дальше в стандартной зашифрованной форме, уже без дополнительной маскировки. Сегодня в браузере Tor можно увидеть 4 вида транспорта, а именно: Мост Описание, функционал obfs4 Делает Tor-трафик похожим на случайные данные, чтобы его нельзя было распознать с помощью DPI (глубокой анализ пакетов), часто используемой для обнаружения и блокировки Tor, VPN и Proxy. Именно этот мост вы скорее всего получите meek Перенаправляет Tor-трафик через крупные облачные платформы, такие как Google, Microsoft или Amazon, что делает его похожим на обычный HTTPS-трафик Snowflake Постоянно меняющиеся прокси, управляемые волонтёрами и настроенными так, чтобы сделать вид, что пользователь совершает видеозвонок, а не использует Tor WebTunnel Маскирует подключение к Tor так, чтобы оно выглядело, будто пользователь заходит на веб-сайт по протоколу HTTPS Например, если используется мост с транспортом obfs4, то трафик сначала маскируется obfs4, а затем передаётся через мост. ","date":"02-12-2024","objectID":"/articles/anonymity/:4:3","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":".onion-сервисы\rИ-так, onion-сайты… а хотя нет. Начнём с другого. HTTP — протокол (установленные правила), по которому ПК пользователя обменивается данными с интернет ресурсами. Удобная и фундаментальная вещь, правда при передаче трафик никак не шифруется, а значит при перехвате можно будет узнать логины, пароли, да вообще всё, что можно. В связи с этим придумали апгрейд. HTTPS — расширенный HTTP протокол, устанавливающий зашифрованное соединение с помощью криптографических протоколов SSL и TLS, то есть при его использовании запросы и ответы шифруются, чтобы не было интереса их перехватывать. Узнать, безопасно ли ваше соединение, можно, посмотрев на адресную строку браузера: если вначале стоит https:// — всё в порядке. В настоящее время HTTPS протокол поддерживают большинство сайтов, и при использовании Tor’a нужно открывать ресурсы именно с ним, о чём он предупреждает всякий раз, когда пользователь пытается открыть страницы с “плохим” протоколом HTTP. Onion-сайты — веб-ресурсы, доступные только через луковую сеть и использующие доменную зону .onion. Они лучше обычных сайтов тем, что: Переняли все преимущества HTTPS протокола, а значит трафик защищается сквозным шифрованием. Домены не хранятся на централизованных DNS-серверах, что затрудняет их обнаружение и даёт устойчивость к DNS-атакам. Но где же тогда они расположены? На специальных узлах, работающих примерно как DNS-сервера, только для каждого ресурса он будет своим. Владельцам onion-сайтов не требуется покупать доменные имена, так как они формируются автоматически в рамках протокола шифрования. Работают на основе криптографических ключей. Публичный как раз используется для создания домена, а приватный — для шифрования и аутентификации. Инфо\rOnion-адрес нового поколения состоит из 56 букв и цифр с окончанием .onion\r","date":"02-12-2024","objectID":"/articles/anonymity/:4:4","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Как подключиться к сети Tor\rВот мы и подошли к практической части! Инфо\rВсе ссылки предоставлены из надёжных источников. Для доступа ко многим из них вам, вероятно, потребуется Proxy/VPN.\rДля подключения к сети Tor используется Tor-браузер. Скачиваем его отсюда. К сожалению, iOS не позволяет создать Tor Browser под себя, но разработчики рекомендуют скачать Onion Browser, который тесно сотрудничает с проектом Tor. Далее, если вы не не хотите использовать VPN, вам потребуются мосты (вспоминаем факт блокировки открытых нод). Рассмотрим все известные способы их подключения: На ПК можно прямо из настроек браузера в разделе “подключение” нажать кнопку “Запросить мосты” и.. получить их :) Вряд-ли такой подход сработает, но можете попробовать выбрать один из предложенных вариантов во вкладке “Выбрать встроенный мост”. Или же можно запросить мосты прямиком из официального бота. Полученные адреса копируем, нажимаем на “Добавить новые мосты” и вставляем. Если вышеуказанные способы не работают, попробуйте написать на почту bridges@torproject.org. Важно: используйте только Riseup или Gmail, также оставьте тему сообщения пустым, а в теле напишите get transport obfs4. Инфо\rЕсли всё-таки ничего из перечисленного вам не помогло, попробуйте включить VPN перед подключением к Tor, хотя сами разработчики луковой сети не рекомендуют это делать.\rУра, мы в сети! Но что дальше? Как найти то, за чем мы сюда пришли? Гуглить! Или онионить… Сейчас скорее всего в качестве поисковика у вас стоит DuckDuckGo или Startpage. Они действительно хороши в плане анонимности, правда первый понижает в результатах выдачи российские новости, связанные с СВО (как же наверное приятно, когда тебе не нужно включать голову и думать, где правда, а где — нет), поэтому я чаще использую второй, хотя он тоже может блокировать некоторые запросы, нарушающие юридические или моральные нормы (мда, звучит абсурдно). В связи с чем советую нагуглить рабочие ссылки на такие поисковики как Torch, Ahmia, Tordex, Bobby и т.п. А ещё есть отдельные сайты, которые выкладывают список onion-ссылок по разным тематикам: соцсети, торговля, форумы и т.п. Инфо\rЕсли определённый сайт не пускает вас из-за подозрительного трафика, попробуйте создать новую личность в браузере. Для этого нажмите на такой значок в правом верхнем углу, затем на кнопку “Новая личность”. Построится новая цепочка сети Tor, закроются все вкладки, очистятся куки, данные о скачанных вами файлах и прочая информация.\r","date":"02-12-2024","objectID":"/articles/anonymity/:4:5","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Проблемы Tor\rTor, как и любое другое средство, не гарантирует 100%-ой анонимности. Существуют уязвимости, которые могут деанонимизировать пользователя. Узлы могут прослушиваться. В целом логично, ведь их предоставляют добровольцы, а значит этими добровольцами могут оказаться недоброжелатели :) Если скомпрометирована только одна нода в цепочке, то это не приведёт к значительным последствиям, так как guard node знает только отправителя, но не знает данных и конечного получателя, middle node не знает вообще ничего критически важного, а exit node знает конечного получателя и данные (если они передаются не через HTTPS), но не отправителя. Беда наступает, когда одним злоумышленником контролируются входная и выходная ноды. Сопоставив время и объём передаваемых данных будет достаточно просто установить реальный IP, а если скомпрометированы все 3 ноды, то пиши-пропало… До появления guard nodes (вместо них раньше были entry nodes) и мостов эта проблема была особенно актуальной, так как при длительном использовании тора шанс деанона был практически стопроцентный, ведь по теории вероятности вы рано или поздно наткнётесь на цепочку, в которой обе ноды будут скомпрометированы. Сейчас же, вместо того, чтобы менять всю цепочку раз в 10 минут, меняются только средняя и выходная ноды. Guard ноды же устроены по-другому: для каждого Tor-клиента случайным образом подбираются несколько входных узлов, и при подключении используются только они, при этом меняются раз в 2-3 месяца. Если эти узлы не контролируются, злоумышленник никогда не сможет деанонимизировать пользователя. В ином случае утекает значительная часть данных, но не больше, чем если бы такого трюка не было вовсе. С одной стороны это не очень гуманно, поскольку все проблемы достаются только отдельным пользователям, а с другой — большая часть людей сильнее защищена. Что ж, зачастую приходится идти на компромиссы. Ну а мосты вообще можно не менять, пока не перестанут работать. Функционал у них практически такой же, как и у Guard нод, плюсом они усложняют анализ трафика и скрывают факт использования тора. Также помните, что стоит заходить только на веб-сервисы, которые используют HTTPS. Так выходной узел не сможет видеть в ответе от сайта ваши логины и пароли. Вообще подобная вещь как контроль большого количества нод невероятно ресурсозатратно, так что чересчур сильно беспокоиться об этом не стоит, тем более что лучших простых и бесплатных альтернатив (по сравнению с тором) пока нет. Предупреждение\rНе отключайте NoScript. Это расширение защищает вас от JavaScript-атак. JavaScript довольно мощный инструмент, который может извлекать реальный IP в обход прокси-серверов, собирать данные о системе (разрешение экрана, шрифты, часовой пояс и прочее) и выполнять запросы на внешние ресурсы от имени пользователя.\rТеоретически злоумышленниками могут оказаться и некоторые из Directory Authorities, о которых мы не так давно говорили. В таком случае они могут включать в консенсус скомпрометированные ноды, но риск остаётся минимальным благодаря репутации данных узлов (да, вам в любом случае приходится кому-то доверять). К тому же для добавления плохих узлов нужно захватить как минимум 5 из 9 DA, что невероятно маловероятно 😀 НЕЛЬЗЯ (ну прям не надо, серьёзно) загружать torrent-файлы через Tor. Если вкратце, то большинство клиентов Bittorrent (сетевой протокол для обмена torrent-файлами), такие как uTorrent, игнорируют настройки прокси-серверов и обращаются напрямую к пользователю, детектируя его реальный IP, и отправляют эту информацию другим пользователям uTorrent’a. Ах да, использование Bittorrent’a создаёт большую нагрузку на сеть Tor, из-за чего у всех пользователей возникают падение скорости передачи данных. Так не будем же создавать сообществу проблем ;) На разных форумах встречал людей, беспокоящихся о том, что Tor финансируется различными структурами США. Да, объёмы действительно внушительные: 50% - 90%. Раньше конкретные суммы были публичными, но, видимо из-за наплыва трясущихся анонимусов, разраб","date":"02-12-2024","objectID":"/articles/anonymity/:4:6","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Связки нескольких способов\rVPN+VPN, VPN+Tor, VPN+Tor+VPN… Вариантов куча, но они могут как улучшить вашу анонимность, так и ослабить. Как мы уже выяснили, вычислить пользователя одного лишь VPN/Proxy не составит большого труда, поэтому в случае контроля злоумышленником входной и выходной нод Tor’а восстановление оставшейся цепочки типа VPN/Proxy+Tor+VPN/Proxy лишь затянет процесс деанона. Тем не менее подобные связки могут оказаться очень полезными в некоторых целях. Предлагаю рассмотреть возможные варианты поподробнее. ","date":"02-12-2024","objectID":"/articles/anonymity/:5:0","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"VPN -\u003e Tor\rЕсли нужно скрыть от провайдера факт использования Tor’а, а мосты не работают, поставьте перед ним VPN. Бонусом получаем скрытие нашего IP от Tor’а, но, опять же, это лишь замедлит нашу идентификацию, если всё-таки кто-то взломает Tor. Предупреждение\rПри конфигурациях VPN -\u003e Tor важно настроить систему так, чтобы Tor прерывал соединение при отключении VPN. Сделать это можно обычно включив “killswitch” в настройках VPN-клиента.\r","date":"02-12-2024","objectID":"/articles/anonymity/:5:1","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Proxy -\u003e Tor\rТакие протоколы как VLESS и Shadowsocks могут обеспечить тот же результат, что и VPN. Однако HTTP, HTTPS, SOCKS и прочие не способны скрыть от провайдера то, что вы используете Tor. ","date":"02-12-2024","objectID":"/articles/anonymity/:5:2","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Tor -\u003e VPN\rНекоторые сервисы не любят пропускать пользователей Tor, поэтому VPN на выходе может помочь вам избежать данной проблемы. Тут достаточно много нюансов.. большинство VPN-сервисов не поддерживают Tor-подключения, настройка довольно муторная, да и анонимность практически не прибавляется. К тому же, VPN-сервер теоретически может собирать данные, которые будут идти в открытом виде из выходной ноды Tor. Да, разумеется сами ноды могут быть скомпрометированы, но ведь они меняются, соответственно будут хранить только малую часть трафика, а вот VPN-сервера вы вряд-ли будете обновлять каждые 10 минут. Инфо\rСам проект Tor настоятельно не рекомендует неопытным юзерам пользоваться подобной связкой по указанным причинам\r","date":"02-12-2024","objectID":"/articles/anonymity/:5:3","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Tor -\u003e Proxy\rНу тут всё понятно, ничего нового не скажу. ","date":"02-12-2024","objectID":"/articles/anonymity/:5:4","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"X -\u003e Tor -\u003e X\rТут вроде тоже ничего не нужно объяснять, просто объедините вышесказанное к вашему варианту, например, Proxy -\u003e Tor -\u003e Vpn. ","date":"02-12-2024","objectID":"/articles/anonymity/:5:5","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Советы\rПерейдём к незамысловатым советам, которые помогут вам оставаться анонимными, и подведём промежуточные итоги. Заходите только на сайты, которые поддерживают HTTPS, иначе произойдёт утечка всего возможного. Не устанавливайте плагины и расширения в браузер Tor. Подобные дополнения дают уникальный “отпечаток” браузеру, такие как изменения заголовков запросов, действий на веб-сайтах, что может быть использовано для вашего отслеживания. Не открывайте скаченные файлы, пока находитесь в сети Tor. Они могут содержать скрипты, самооткрывающиеся ссылки и прочие фокусы, которых вы можете даже не заметить. Для подобных действий лучше использовать отдельную виртуальную машину, не имеющей доступа в интернет и не содержащей никакой критически важной для вас информации. Не заходите через Tor в свои аккаунты из обычной жизни, не используйте и не распространяйте свои личные данные и не общайтесь со своими знакомыми через новые анонимные аккаунты. Шифруйте диски. Банальный, но важный совет, которым многие пренебрегают: всегда придумывайте разные пароли, а лучше генерируйте и храните их в проверенной оффлайн программе по типу KeePass. Также можете сохранить пару важных паролей (доступ к системе/дешифровка диска/доступ к базе данных паролей) прямо на бумажке, но нужно постараться и хорошенько спрятать её. Дальше для полных параноиков 👽: Не покупайте физические сим-карты для одноразовых аккаунтов. Даже в переходах метро. Гораздо лучше брать одноразовые номера в соответствующих сервисах. На каждом форуме/аккаунте придумывайте себе новую личность. Меняйте свои интересы (либо не выдавайте их совсем) и стиль общения. Выключайте микрофоны и камеры. Сегодня даже ИИ может определить конкретную клавишу лишь по звуку её нажатия, что уж говорить об обученных специалистах. Убирайте мобильный телефон подальше. Конечно, просто так, без установки ПО или физических устройств на мобильник, вас прослушать вряд-ли смогут, но раз зашла речь про паранойю, чего мелочиться. Не заходите на Фейсбук :) Не платите Bitcoin’ом. В следующей части статьи мы обсудим этот момент подробнее. Не используйте Windows. Подробнее также в следующей части ;) Как раз-таки Tor я использую как основное средство анонимизации. Лучших альтернатив, не требующих вложения средств, просто не существует. Информации много, поэтому решил разделить статью на две, и во второй начнётся самое интересное. Жду ваши отзывы/вопросы/советы в лс, и спасибо, что читаете! ","date":"02-12-2024","objectID":"/articles/anonymity/:6:0","tags":["anonymity","tor","vpn"],"title":"Анонимность в сети. Часть I","uri":"/articles/anonymity/"},{"categories":null,"content":"Об авторе\rПривет, меня зовут Иван. Я увлекаюсь ЯП Python, сетями, машинным обучением. Учусь в двух вузах: РУДН (2-ой курс) и Финансовый университет при Правительстве РФ (1-ый курс). Хожу на разные мероприятия по типу кейс-чемпионатов, чтобы познакомиться с интересными людьми. 👨‍💻 Студент 📚 Специальности: Компьютерные и информационные науки; Финансы и инвестиции ","date":"08-11-2024","objectID":"/about/:1:0","tags":null,"title":"О нас","uri":"/about/"},{"categories":null,"content":"О блоге\rHFK (Hungry for Knowledge) – онлайн-ресурс, содержащий конспекты, статьи и проекты автора, охватывающие спектр тем, связанных с программированием и не только. Цели проекта: предоставить удобный доступ к материалам и создать портфолио. Планы на будущее: разместить проект, связанный с языком программирования Python; сделать 3 полноценных статьи. Мини-проект (сайт) HFK был выполнен с помощью генератора статических сайтов Hugo и темы FixIt. История блога\rСоздан сайт на основе темы Blowfish\r2024-06-15Добавлено достаточно контента\r2024-07-13После долгого простоя в связи с несовместимостью Blowfish с мобильными устройствами (или ошибками реализации) было решено сменить тему Blowfish -\u003e FixIt\r2024-11-07Куплен домен noisycake.ru\r2024-11-09Начало переноса контента с небольшим форматированием\r2024-11-09Выложена первая статья 🥳\r2024-12-02\r","date":"08-11-2024","objectID":"/about/:2:0","tags":null,"title":"О нас","uri":"/about/"},{"categories":["python"],"content":" Конспект посвящён модулю collections и его составляющим, а именно именованному кортежу, специфическим типам словарей и т.п. Вторая часть конспектов про типы данных в Python ","date":"24-07-2024","objectID":"/notes/collections2/:0:0","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Модуль collections\rPython содержит встроенный модуль collections, который содержит специализированные типы коллекций, альтернативных традиционным list, tuple, dict: namedtuple defaultdict OrderedDict Counter ChainMap и прочие Начнём с разбора именованных кортежей. ","date":"24-07-2024","objectID":"/notes/collections2/:1:0","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Namedtuple\rДля использования: from collections import namedtuple Именованные кортежи (тип namedtuple) — это подтип обычных кортежей в Python. У них те же функции, что и у обычных, но их значения можно получать как с помощью индекса (например, [0]), так и с помощью имени через точку (например, .name). Их основным назначением является улучшение читаемости кода. Опишем точку на плоскости, имеющую две координаты x и y с помощью именованного кортежа: from collections import namedtuple Point = namedtuple('Point', ['x', 'y']) # создаём подкласс кортежа Point (именованный кортеж) point = Point(3, 7) # создаём экземпляр Point print(point) print(point.x, point.y) print(point[0], point[1]) print(type(point)) # Вывод: Point(x=3, y=7) 3 7 3 7 \u003cclass '__main__.Point'\u003e Как и обычный, именованный кортеж может содержать изменяемые значения, но стоит помнить, что такие кортежи не будут хэшируемы: from collections import namedtuple Person = namedtuple('Person', ['name', 'children']) sveta = Person('Sveta Ivanova', ['Larisa', 'Keksik']) print(sveta) sveta.children.append('Romka') print(sveta) # Вывод: Person(name='Sveta Ivanova', children=['Larisa', 'Keksik']) Person(name='Sveta Ivanova', children=['Larisa', 'Keksik', 'Romka']) Опасность\rОчевидно, что подобный код sveta.children = ['Larisa', 'Keksik', 'Romka'] привёл бы к ошибке\rСоздавать кортежи можно также с помощью именованных аргументов: from collections import namedtuple Point = namedtuple('Point', ['x', 'y']) point1 = Point(2, 4) # позиционные аргументы point2 = Point(y=10, x=3) # именованные аргументы print(point1) print(point2) # Вывод: Point(x=2, y=4) Point(x=3, y=10) При работе с именованными кортежами можно пользоваться срезами (результатом будет обычный кортеж) ","date":"24-07-2024","objectID":"/notes/collections2/:2:0","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Функция namedtuple()\rЭта фабричная функция (понятие из ООП) позволяет создавать подклассы кортежа с именованными полями (классы именованных кортежей). Сигнатура: namedtuple(typename, field_names, *, rename=False, defaults=None, module=None). Разберёмся с каждым параметров по-отдельности. typename и field_names\rПараметр typename отвечает за имя создаваемого класса namedtuple (который и возвращает функция namedtuple()), а параметр fieldnames за название полей, которые мы будем использовать, чтобы получить доступ к значениям определённого экземпляра именованного кортежа. В качестве параметра field_names можно использовать: Список. from collections import namedtuple Point = namedtuple('Point', ['x', 'y']) # передаем список point = Point(2, 4) print(point) # выводит Point(x=2, y=4) Кортеж. from collections import namedtuple Point = namedtuple('Point', ('x', 'y')) # передаем кортеж point = Point(2, 4) print(point) # выводит Point(x=2, y=4) Словарь. В этом случае для полей именованного кортежа используются ключи словаря, поэтому в качестве значений можно указать, все что угодно. from collections import namedtuple Point = namedtuple('Point', {'x': 0, 'y': 69}) # передаем словарь point = Point(2, 4) print(point) # выводит Point(x=2, y=4) Строка. При создании именованного кортежа с помощью строки мы указываем поля либо через символ пробела, либо разделяя их символом ,. from collections import namedtuple Point = namedtuple('Point', 'x y') # передаем строку (можно 'x,y') point = Point(2, 4) print(point) # выводит Point(x=2, y=4) Множество. Можно создать именованный кортеж с помощью множества, но делать это не рекомендуется, так как множество — неупорядоченный набор данных, поэтому поля могут перемешаться. from collections import namedtuple Point = namedtuple('Point', {'x', 'y'}) # в качестве второго параметра передаем множество point = Point(2, 4) print(point) # выводит Point(x=2, y=4) или Point(y=2, x=4) Совет\rВ качестве параметра field_names можно передавать любой итерируемый объект, например, результат вызова функций map() и filter()\rВ качестве названия полей для именованных кортежей мы можем использовать любое корректное название имени переменной, за исключением: имён, начинающихся с символа _; ключевых слов языка Python (if, with, else, class, …). rename\rПри rename=True названия полей, переданных в field_names, которые содержат ключевые слова Python, переименовываются в соответствии с их порядковыми номерами (начиная с нуля), перед которыми ставится символ _. Посмотрим на пример: from collections import namedtuple headers = ('name', 'surname', 'age', 'class', 'with', 'color', 'name', 'class', 'if') Student = namedtuple('Student', headers, rename=True) stud = Student('Иван', 'Бережной', 19, 2, 'me', 'green', 'Cake', '2A', 'else') print(stud) # Вывод: Student(name='Иван', surname='Бережной', age=19, _3=2, _4='me', color='green', _6='Cake', _7='2A', _8='else') defaults\rПараметр defaults (работает в Python 3.7+) используется для того, чтобы установить значения по умолчанию для полей именованного кортежа. Можно указать значение по умолчанию только для некоторых полей, при этом defaults присваивает значения по умолчанию с хвоста. from collections import namedtuple Point = namedtuple('Point', ['x', 'y'], defaults=(0, 0)) point = Point() # используем значения по умолчанию print(point) # Вывод: Point(x=0, y=0) module\rПосмотрим на вывод следующего кода: from collections import namedtuple Point = namedtuple('Point', ['x', 'y']) point = Point(1, 2) print(type(point)) # Вывод: \u003cclass '__main__.Point'\u003e Если мы укажем допустимое имя модуля для этого аргумента, тогда атрибуту .__ module__ результирующего именованного кортежа будет присвоено это значение: from collections import namedtuple Point = namedtuple('Point', ['x', 'y'], module='custom') point = Point(1, 2) print(point.__module__) # Вывод: custom Инфо\rПараметр module был добавлен в Python 3.6 для того, чтобы появилась возможность сериализовать/десериализовать именованные кортежи с помощью мод","date":"24-07-2024","objectID":"/notes/collections2/:2:1","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Распаковка именованного кортежа\rИменованный кортеж распаковывается также, как и обычный: from collections import namedtuple Person = namedtuple('Person', ['name', 'age', 'height']) ivan = Person('Иван', 19, 179) print(*ivan) # Вывод: Иван 19 179 ","date":"24-07-2024","objectID":"/notes/collections2/:2:2","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Атрибуты _fields и _field_defaults\rИменованные кортежи имеют два дополнительных атрибута: _fields и _field_defaults. Первый содержит кортеж строк, в котором перечислены имена полей. Второй атрибут содержит словарь, который сопоставляет имена полей с соответствующими значениями по умолчанию, если таковые имеются. from collections import namedtuple Person = namedtuple('Person', ['name', 'age', 'height']) ivan = Person('Иван', 19, 179) print(ivan) print(ivan._fields) print(Person._fields) # Вывод: Person(name='Иван', age=19, height=179) ('name', 'age', 'height') ('name', 'age', 'height') Как видно из примера выше, можно обращаться к атрибуту _fields как через переменную (ivan), так и через сам тип именованного кортежа (Person). С помощью атрибута _fields можно создавать новые именованные кортежи на основании уже существующих. В следующем примере создаётся новый именованный кортеж с именем ExtendedPerson, который расширяет старый Person новым полем weight: from collections import namedtuple Person = namedtuple('Person', ['name', 'age', 'height']) ExtendedPerson = namedtuple('ExtendedPerson', [*Person._fields, 'weight']) # распаковка полей старого кортежа ivan = ExtendedPerson('Иван', 19, 179, 63) print(ivan) print(ExtendedPerson._fields) # Вывод: ExtendedPerson(name='Иван', age=19, height=179, weight=63) ('name', 'age', 'height', 'weight') Мы также можем использовать атрибут _fields для перебора полей и их значений с помощью встроенной функции zip(): from collections import namedtuple Person = namedtuple('Person', ['name', 'age', 'height']) ivan = Person('Иван', 19, 179) for field, value in zip(Person._fields, ivan): print(field, '-\u003e', value) # Вывод: name -\u003e Иван age -\u003e 19 height -\u003e 179 С помощью атрибута _field_defaults мы можем выяснить, какие поля именованного кортежа имеют значения по умолчанию: from collections import namedtuple Person = namedtuple('Person', ['name', 'age', 'height', 'country'], defaults=['Russia']) ivan = Person('Иван', 19, 179) print(ivan) print(ivan._field_defaults) print(Person._field_defaults) # Вывод: Person(name='Иван', age=19, height=179, country='Russia') {'country': 'Russia'} {'country': 'Russia'} Инфо\rЕсли именованный кортеж не предоставляет значений по умолчанию, тогда атрибут _field_defaults содержит пустой словарь.\r","date":"24-07-2024","objectID":"/notes/collections2/:2:3","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Методы _make(), _replace(), _asdict()\r_make() — метод класса (не экземпляра), работающий как альтернативный конструктор класса и возвращающий новый экземпляр именованного кортежа typename. from collections import namedtuple Person = namedtuple('Person', ['name', 'age', 'height']) ivan = Person._make(['Ivan', 19, 179]) print(ivan) # Вывод: Person(name='Ivan', age=19, height=179) _asdict() преобразует именованные кортежи в словари, в которых имена полей используются в качестве ключей. Ключи результирующего словаря находятся в том же порядке, что и поля в исходном именованном кортеже. from collections import namedtuple Person = namedtuple('Person', ['name', 'age', 'height']) ivan = Person._make(['Иван', 19, 179]) print(ivan._asdict()) # Вывод: {'name': 'Иван', 'age': 19, 'height': 179} _replace() создаёт новый именованный кортеж на основе уже существующего с заменой некоторых значений. Потребность в данном методе вызвана тем, что именованные кортежи являются неизменяемыми. from collections import namedtuple Person = namedtuple('Person', ['name', 'age', 'height', 'country']) ivan1 = Person('Иван', 19, 179, 'Russia') ivan2 = ivan1._replace(age=20, country='Germany') print(ivan1) print(ivan2) # Вывод: Person(name='Иван', age=19, height=179, country='Russia') Person(name='Иван', age=20, height=179, country='Germany') ","date":"24-07-2024","objectID":"/notes/collections2/:2:4","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Схожесть со словарями\rФункционал именованных кортежей можно полностью заменить функционалом словарей, тогда зачем вообще нужен этот namedtuple? Если коротко, то он более быстрый и занимает меньше места в памяти. Сравним эти показатели с помощью нехитрых программ. Начнём с потребления памяти: from collections import namedtuple from pympler import asizeof Person = namedtuple('Person', ['name', 'age', 'height']) ivan = Person('Иван', 19, 179) ivan_dct = {'name': 'Иван', 'age': 19, 'height': 179} print(f'Именованный кортеж: {asizeof.asizeof(ivan)} байт') print(f'Словарь: {asizeof.asizeof(ivan_dct)} байт') # Вывод: Именованный кортеж: 112 байт Словарь: 304 байт Теперь посмотрим на производительность: from collections import namedtuple from time import perf_counter def average_time(structure, test_func): time_measurements = [] for _ in range(1_000_000): start = perf_counter() test_func(structure) end = perf_counter() time_measurements.append(end - start) return sum(time_measurements) / len(time_measurements) * int(10**9) def time_dict(dictionary): 'name' in dictionary 'missing_key' in dictionary 28 in dictionary.values() 'missing_value' in dictionary.values() dictionary['age'] def time_namedtuple(named_tuple): 'name' in named_tuple._fields 'missing_field' in named_tuple._fields 28 in named_tuple 'missing_value' in named_tuple named_tuple.age Person = namedtuple('Person', ['name', 'age', 'height']) ivan = Person('Иван', 19, 179) ivan_dct = {'name': 'Иван', 'age': 19, 'height': 179} print(f'Именованный кортеж: {average_time(ivan, time_namedtuple)} наносекунд') print(f'Словарь: {average_time(ivan_dct , time_dict)} наносекунд') # Вывод: Именованный кортеж: 382 наносекунд Словарь: 508 наносекунд ","date":"24-07-2024","objectID":"/notes/collections2/:2:5","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Defaultdict\rДля использования: from collections import defaultdict Основная проблема при работе с обычными словарями — попытка получить доступ к несуществующему ключу, которая вызывает ошибку KeyError. С этим можно справиться через setdefault(), get() или проверкой наличия ключа в словаря (try/except или оператор in), а можно воспользоваться типом данных defaultdict. Тип defaultdict ведет себя почти так же, как обычный словарь dict, но если мы попытаемся получить доступ (или изменить значение) по несуществующему ключу, то defaultdict автоматически создаст ключ и сгенерирует для него значение по умолчанию. Такое поведение делает этот тип данных удобным вариантом обработки недостающих ключей в словарях. defaultdict является является наследником класса dict, а значит обладает всеми его методами. Функция defaultdict() принимает в качестве аргумента тип элемента по умолчанию. Таким образом, для ключей, к которым происходит обращение, словарь defaultdict поставит в соответствие дефолтный элемент данного типа: int – число 0; float – число 0.0; bool – значение False; str – пустая строка ''; list – пустой список []; tuple – пустой кортеж (); set – пустое множество set(); dict – пустой словарь {}. from collections import defaultdict info = defaultdict(int) # создаем словарь со значением по умолчанию 0 info['name'] = 'Ivan' info['age'] = 19 info['job'] = 'Darkstore' print(info['salary']) print(info) # Вывод: 0 defaultdict(\u003cclass 'int'\u003e, {'name': 'Ivan', 'age': 19, 'job': 'Darkstore', 'salary': 0}) Помимо первого аргумента — типа элемента по умолчанию — мы можем передать второй аргумент: словарь, на основании которого будет создан defaultdict. from collections import defaultdict info = defaultdict(int, {'name': 'Ivan', 'age': 19, 'job': 'Darkstore'}) print(info['name']) print(info['salary']) print(info) # Вывод: Ivan 0 defaultdict(\u003cclass 'int'\u003e, {'name': 'Ivan', 'age': 19, 'job': 'Darkstore', 'salary': 0}) Также допустимы все способы, которые мы используем при создании обычных словарей, а именно передача именованных аргументов или итерируемого объекта, содержащего пары ключ-значение (например, список кортежей). Правда, следующий код приведёт к ошибке, так как в качестве первого аргумента должен быть указан тип элемента по умолчанию, а не итерируемый объект с парами ключ-значение: from collections import defaultdict info = defaultdict([('name', 'Ivan'), ('age', 19), ('job', 'Darkstore')]) print(info) Если же создать экземпляр defaultdict словаря без указания default_factory (значения по умолчанию для отсутствующих ключей), то поведение defaultdict будет таким же, как и у обычного словаря (тип dict). То же самое произойдёт, если передать значение None (является значением по умолчанию для default_factory) Следующий код вызовет ошибку KeyError: from collections import defaultdict data = defaultdict() # или data = defaultdict(None) print(data['salary']) Если в ходе написания кода потребуется изменить значение по умолчанию, это можно осуществить через атрибут default_factory: from collections import defaultdict data = defaultdict(int) print(data['salary1']) data.default_factory = list print(data['salary2']) data.default_factory = float print(data['salary3']) # Вывод: 0 [] 0.0 При создании defaultdict словаря можно указывать не только тип данных для значений по умолчанию, но и любую функцию, не принимающую аргументов и возвращающую некоторое дефолтное значение. Передадим функцию, объявленную с помощью def: from collections import defaultdict def get_default(): return 69 info = defaultdict(get_default, {'name': 'Ivan', 'age': 19, 'job': 'Darkstore'}) print(info['name']) print(info['salary']) # Вывод: Ivan 69 Теперь передадим lambda-функцию: from collections import defaultdict info = defaultdict(lambda: '1000000$', {'name': 'Ivan', 'age': 19, 'job': 'Darkstore'}) print(info['name']) print(info['salary']) # Вывод: Ivan 1000000$ Рассмотрим задачу и решим её с помощью defaultdict: пусть задан список чисел numbers, в котором некоторые числа встречаютс","date":"24-07-2024","objectID":"/notes/collections2/:3:0","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Когда использовать defaultdict?\rЕсть несколько рекомендаций: Если ваш код в значительной степени основан на словарях и вы все время имеете дело с отсутствующими ключами, вам следует подумать об использовании defaultdict, а не обычного dict; Если элементы вашего словаря необходимо инициализировать некоторым значением по умолчанию, вам следует подумать об использовании defaultdict, вместо dict; Если ваш код использует словари для агрегирования, накопления, подсчета или группировки значений, вам следует подумать об использовании defaultdict, вместо dict. К слову, тип defaultdict работает быстрее чем использование методов setdefault() и get() обычного словаря. ","date":"24-07-2024","objectID":"/notes/collections2/:3:1","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"OrderedDict\rДля использования: from collections import OrderedDict Для использования: from collections import OrderedDict В Python 3.6 словари были переработаны так, чтобы повысилась их производительность (и понизилось потребление памяти на 20-25%). Следствием такой переработки явился один очень интересный побочный эффект — словари стали упорядоченными, то есть стали сохранять порядок вставки элементов, хотя на тот момент официально этот порядок не гарантировался. «Официально не гарантируется» означает, что это была просто деталь реализации, которая могла быть изменена в будущих версиях Python. Но начиная с Python 3.7, в спецификации языка гарантируется сохранение порядка вставки элементов в словарь. Задолго до переработки устройства словарей в рамках релиза Python 3.1 в стандартную библиотеку был добавлен тип OrderedDict, который на тот момент решал проблему неупорядоченности обычных словарей. Стоит учесть, что в OrderedDict стоит использовать только для обратной совместимости со старыми программами на версиях Python, когда dict ещё не был упорядочен, ведь обычный словарь быстрее на 40% и занимает на 50% меньше памяти. Таблица различий и особенностей классов dict и OrderedDict: Функционал `OrderedDict dict Сохранность порядка вставки ключей Да (начиная с Python 3.1) Да (начиная с Python 3.6) Удобочитаемость и сигнализация о намерениях Высокая Низкая Возможность менять порядок элементов Да (метод move_to_end()) Нет Производительность операций Низкая Высокая Потребление памяти Высокое Низкое Учет порядка элементов при сравнении на равенство Да Нет Перебор ключей в обратном порядке Да (начиная с Python 3.5) Да (начиная с Python 3.8) Возможность добавления пользовательских атрибутов Да (атрибут .__dict__) Нет Возможность использовать операторы | и |= Да (начиная с Python 3.9) Да (начиная с Python 3.9) OrderedDict является подклассом dict, а значит обладает всеми его методами, также имея собственные методы. Как и defaultdict, эти словари можно создавать любым из доступных способов, как и обычные словари: from collections import OrderedDict numbers1 = OrderedDict({'one': 1, 'two': 2, 'three': 3}) numbers2 = OrderedDict({('one', 1), ('two', 2), ('three', 3)}) numbers3 = OrderedDict(one=1, two=2, three=3) В большинстве случаев OrderedDict ведёт себя как и обычный словарь: программист может добавлять, обновлять, удалять, перебирать (по keys(), values() и items()) элементы, объединять словари с помощью операторов | и |= (конкатенация словарей). Словарь (обычный или OrderedDict) можно “развернуть” функцией reversed(). Обновляя значение ключа, позиция сохраняется, удаляя ключ и снова добавляя его, он помещается в конец словаря. Инфо\rЗначение по ключу можно обновить как через квадратные скобки, так и через словарный метод update()\r","date":"24-07-2024","objectID":"/notes/collections2/:4:0","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Метод move_to_end()\rМетод move_to_end() позволяет переместить существующий элемент либо в конец, либо в начало словаря. Ему можно передать два аргумента: key (обязательный) – ключ, который идентифицирует перемещаемый элемент last=True (необязательный) – логическое значение (тип bool), которое определяет, в какой конец словаря мы перемещаем элемент, значение True (по умолчанию) перемещает элемент в конец, значение False – в начало from collections import OrderedDict numbers = OrderedDict(one=1, two=2, three=3) print(numbers) numbers.move_to_end('one') # last=True print(numbers) numbers.move_to_end('three', last=False) # last=False print(numbers) # Вывод: OrderedDict({('one', 1), ('two', 2), ('three', 3)}) OrderedDict({('two', 2), ('three', 3), ('one', 1)}) OrderedDict({('three', 3), ('two', 2), ('one', 1)}) С помощью метода move_to_end() можно сортировать OrderedDict по ключам: from collections import OrderedDict letters = OrderedDict(b=2, d=4, a=1, c=3) for key in sorted(letters): letters.move_to_end(key) print(letters) # Вывод: OrderedDict({('a', 1), ('b', 2), ('c', 3), ('d', 4)}) ","date":"24-07-2024","objectID":"/notes/collections2/:4:1","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Метод popitem()\rМетод popitem(last=True) по умолчанию удаляет и возвращает элемент в порядке LIFO (Last-In/First-Out, последний пришел/первый ушел), то есть удаляет элементы с конца словаря. from collections import OrderedDict numbers = OrderedDict(one=1, two=2, three=3) print(numbers.popitem()) print(numbers) print(numbers.popitem()) print(numbers) # Вывод: ('three', 3) OrderedDict({('one', 1), ('two', 2)}) ('two', 2) OrderedDict({('one', 1)}) ","date":"24-07-2024","objectID":"/notes/collections2/:4:2","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Атрибут .__dict__\rOrderedDict словари содержат дополнительный атрибут __dict__, которого нет у обычного словаря. Данный атрибут используется для динамического наделения объектов дополнительным функционалом. Этот атрибут позволяет динамически добавлять пользовательские атрибуты в OrderedDict. Использовать его можно двумя способами: В стиле словаря: ordered_dict.__dict__['attr'] = value; Через точечную нотацию: ordered_dict.attr = value. 1: from collections import OrderedDict letters = OrderedDict(b=2, d=4, a=1, c=3) print(letters) print(letters.__dict__) letters.__dict__['advanced'] = '144' print(letters) print(letters.__dict__) # Вывод: OrderedDict({('b', 2), ('d', 4), ('a', 1), ('c', 3)}) {} OrderedDict({('b', 2), ('d', 4), ('a', 1), ('c', 3)}) {'advanced': '144'} 2: from collections import OrderedDict letters = OrderedDict(b=2, d=4, a=1, c=3) letters.sorted_keys = lambda: sorted(letters.keys()) print(letters) print(letters.sorted_keys()) letters['e'] = 5 print(letters) print(letters.sorted_keys()) for key in letters.sorted_keys(): print(key, '-\u003e', letters[key]) # Вывод: OrderedDict({('b', 2), ('d', 4), ('a', 1), ('c', 3)}) ['a', 'b', 'c', 'd'] OrderedDict({('b', 2), ('d', 4), ('a', 1), ('c', 3), ('e', 5)}) ['a', 'b', 'c', 'd', 'e'] a -\u003e 1 b -\u003e 2 c -\u003e 3 d -\u003e 4 e -\u003e 5 Если же методу передать необязательный аргумент last=False, то он начнет удалять и возвращать элементы в порядке FIFO (First-In/First-Out, первый пришел/первый ушел). ","date":"24-07-2024","objectID":"/notes/collections2/:4:3","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Сравнение словарей\rСтоит просто запомнить три истины: При сравнении на равенство обычных словарей порядок расположения их элементов неважен. При сравнении на равенство dict и OrderedDict словарей порядок расположения их элементов неважен. При сравнение на равенство OrderedDict словарей порядок расположения их элементов важен. ","date":"24-07-2024","objectID":"/notes/collections2/:4:4","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Counter\rДля использования: from collections import Counter Counter является подклассом dict, специально разработанным для подсчёта хэшируемых объектов в Python. Он хранит объекты в качестве ключей, а их количество — в качестве значений. Для подсчёта класс Counter использует высокооптимизированную функцию, написанную на языке C. Инфо\rС помощью типа Counter можно реализовать концепцию мультимножества\rЕсть несколько способов создать объект Counter. Например, можно передать коллекцию или итератор в конструктор: from collections import Counter counter = Counter('mississippi') print(counter) # Вывод: Counter({'i': 4, 's': 4, 'p': 2, 'm': 1}) Инфо\rCounter выдает результат в порядке убывания количества вхождений объектов\rТакже при создании объекта Counter можно задавать начальные значения количества объектов: from collections import Counter counter1 = Counter({'i': 4, 's': 4, 'p': 2, 'm': 1}) counter2 = Counter(i=4, s=4, p=2, m=1) print(counter1) print(counter2) # Вывод: Counter({'i': 4, 's': 4, 'p': 2, 'm': 1}) Counter({'i': 4, 's': 4, 'p': 2, 'm': 1}) Класс Counter, будучи подклассом типа dict, наследует все методы, предоставляемые обычным словарем. Но вызов метода fromkeys() всегда будет приводить к возникновению ошибки. Такое поведение не случайно, оно позволяет избежать ошибок неоднозначности при создании объектов типа Counter, например следующий код: counter = Counter.fromkeys('mississippi', 2) мог бы создать объект типа Counter на основе строки mississippi со значением по умолчанию равным 2 для всех символов строки, несмотря на реальное количество вхождений символов в строке mississippi. Как и в обычных словарях, ключи в объектах Counter должны быть хэшируемы. Ограничений на тип значений нет, но для нормальной работы подсчёта объектов в качестве значений должны быть целые неотрицательные числа. Доступ к элементам и итерирование по Counter словарям работает так же, как и у обычных словарей. Мы можем перебирать ключи напрямую или можем использовать словарные методы items(), keys() и values(). При этом, если обратиться по ключу, которого нет в Counter словаре, то ошибка KeyError возникать не будет. Будет возвращено нулевое значение (ключ создан не будет). Объекты типа Counter можно сравнивать между собой. Очевидно, что одинаковыми будут те, что имеют одинаковые элементы (ключ: значение). Также до версии Python 3.10 словари Counter(i=4) и Counter(i=4, s=0) считались разными, но, начиная с Python 3.10 сравнение рассматривает отсутствующие элементы как имеющие нулевое значение, поэтому следующий код вернёт True: from collections import Counter counter1 = Counter(i=4) counter2 = Counter(i=4, s=0) print(counter1 == counter2) Объекты класса Counter, аналогично объектам OrderedDict, содержат дополнительный атрибут __dict__, который используется для динамического наделения объектов дополнительным функционалом: from collections import Counter counter = Counter(green=10, red=25, blue=5) print(counter.__dict__) counter.__dict__['min_value'] = lambda: min(counter.values()) counter.max_value = lambda: max(counter.values()) print(counter.min_value()) print(counter.max_value()) # Вывод: {} 5 25 ","date":"24-07-2024","objectID":"/notes/collections2/:5:0","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Метод update()\rДля изменения объектов типа Counter рекомендуется использовать метод update(). Он не заменяет значения как у обычных словарей, а суммирует существующие. При этом для новых объектов update() создаёт новые пары ключ: количество. from collections import Counter letters = Counter({'i': 4, 's': 4, 'p': 2, 'm': 1}) letters.update('missouri') print(letters) # Вывод: Counter({'i': 6, 's': 6, 'p': 2, 'm': 2, 'o': 1, 'u': 1, 'r': 1}) Метод update() принимает любой итерируемый объект: список, строку, кортеж и т.д., другой объект типа Counter, либо обычный словарь. Также его можно использовать с именованными аргументами, например следующие две строки кода равнозначны: sales.update(apple=3, orange=12, banana=7) и sales.update(monday_sales). from collections import Counter sales = Counter(apple=20, orange=5, banana=10) monday_sales = Counter(apple=3, orange=12, banana=7) tuesday_sales = {'apple': 4, 'orange': 5, 'tomato': 6} print(sales) sales.update(monday_sales) print(sales) sales.update(tuesday_sales) print(sales) # Вывод: Counter({'apple': 20, 'banana': 10, 'orange': 5}) Counter({'apple': 23, 'orange': 17, 'banana': 17}) Counter({'apple': 27, 'orange': 22, 'banana': 17, 'tomato': 6}) Если значения по ключам будут иметь тип, отличный от int, но работающий с оператором +, то то ошибки при вызове метода update() не возникнет: from collections import Counter counter1 = Counter(i=4, s='4') counter2 = Counter(i=5, s='5') counter1.update(counter2) print(counter1) # Вывод: Counter({'i': 9, 's': '54'}) Из предыдущего кода также можем заметить, что под ключом 's' содержится не '45', а '54'. Так устроен метод update() — он складывает значение переданного объекта с изменяемым, но не наоборот, то есть '5' + '4'. ","date":"24-07-2024","objectID":"/notes/collections2/:5:1","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Метод most_common()\rmost_common() возвращает список наиболее повторяемых элементов и количество каждого из них в виде кортежей (ключ, число повторений). from collections import Counter letters = Counter('mississippi') numbers = Counter([5, 6, 7, 1, 3, 9, 9, 1, 2, 5, 5, 7, 7, 9]) print(letters.most_common()) print(numbers.most_common()) # Вывод: [('i', 4), ('s', 4), ('p', 2), ('m', 1)] [(5, 3), (7, 3), (9, 3), (1, 2), (6, 1), (3, 1), (2, 1)] Если методу most_common() передать целочисленный аргумент n, то он вернет n самых часто повторяющихся элементов. from collections import Counter letters = Counter('mississippi') print(letters.most_common(2)) # Вывод: [('i', 4), ('s', 4)] Для поиска самых редких элементов, можно использовать срезы с отрицательным шагом. ","date":"24-07-2024","objectID":"/notes/collections2/:5:2","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Метод elements()\relements() возвращает итератор по элементам, в котором каждый элемент повторяется столько раз, во сколько установлено его значение. Элементы возвращаются в порядке их появления. При этом, если количество элементов по некоторому ключу меньше единицы, то метод elements() просто проигнорирует его. from collections import Counter letters = Counter('mississippi') numbers = Counter([5, 6, 7, 1, 3, 9, 9, 1, 2, 5, 5, 7, 7, 9]) print(list(letters.elements())) print(list(numbers.elements())) # Вывод: ['m', 'i', 'i', 'i', 'i', 's', 's', 's', 's', 'p', 'p'] [5, 5, 5, 6, 7, 7, 7, 1, 1, 3, 9, 9, 9, 2] ","date":"24-07-2024","objectID":"/notes/collections2/:5:3","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Метод total()\rВ Python 3.10 появился метод total(), который вычисляет сумму всех значений Counter словаря, включая отрицательные. from collections import Counter letters = Counter(i=4, s=4, a=0, p=2, b=-98, m=1) print(letters.total()) # Вывод: -87 ","date":"24-07-2024","objectID":"/notes/collections2/:5:4","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Метод subtract()\rsubtract() вычитает из значений элементов одного словаря Counter значения элементов другого словаря. Этот метод подобен update(), но вычитает количества, а не складывает их. При этом у результирующего словаря значения ключей могут быть нулевыми или отрицательными. from collections import Counter counter1 = Counter(i=4, s=40, a=1, p=20, b=98, z=69) counter2 = Counter(i=2, s=20, a=6, p=12, m=1, z=69) counter1.subtract(counter2) print(counter1) # Вывод: Counter({'b': 98, 's': 20, 'p': 8, 'i': 2, 'z': 0, 'm': -1, 'a': -5}) Помимо словарей, метод subtract() может принимать любой итерируемый объект: список, строку, кортеж и т.д., а также его можно использовать с именованными аргументами. from collections import Counter counter = Counter(i=4, s=40, a=1, p=20, b=98, z=69) letters = 'iisssssapppz' counter.subtract(letters) # обновляем значения в counter print(counter) # Вывод: Counter({'b': 98, 'z': 68, 's': 35, 'p': 17, 'i': 2, 'a': 0}) ","date":"24-07-2024","objectID":"/notes/collections2/:5:5","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Операторы +, -, \u0026, |\rКак мы уже знаем, методы update() и subtract() объединяют Counter словари путем сложения и вычитания количества соответствующих элементов. Python предоставляет удобные операторы сложения (+) и вычитания (-), которые могут заменить вызовы данных методов. При использовании этих операторов из результирующего словаря исключаются элементы с нулевыми и отрицательными значениями. from collections import Counter counter1 = Counter(i=10, s=40, p=10, m=1) counter2 = Counter(i=2, s=8, p=10, m=3) print(counter1 + counter2) print(counter1 - counter2) print(counter2 - counter1) # Вывод: Counter({'s': 48, 'p': 20, 'i': 12, 'm': 4}) Counter({'s': 32, 'i': 8}) Counter({'m': 2}) Инфо\rОператоры + и - работают только с Counter словарями, в то время как методы update() и subtract() — с любым итерируемым объектом\rCounter позволяет также использовать унарные операторы сложения и вычитания. В первом случае мы получаем новый Counter словарь, который содержит только элементы с положительными значениями, во втором — элементы с отрицательными значениями. Другими словами, операторы унарного сложения и вычитания прибавляют пустой Counter словарь или вычитают исходный из пустого. Следующие два блока кодов равнозначны: from collections import Counter counter = Counter(a=5, b=-9, c=0) print(+counter) print(-counter) from collections import Counter counter = Counter(a=5, b=-9, c=0) print(+counter) print(-counter) и выводят: # Вывод: Counter({'a': 5}) Counter({'b': 9}) Помимо указанных выше операторов, Python также предоставляет операторы пересечения (\u0026) и объединения (|), которые возвращают минимум и максимум из соответствующих значений. from collections import Counter counter1 = Counter(i=10, s=40, p=10, m=1) counter2 = Counter(i=2, s=8, p=10, m=3) print(counter1 \u0026 counter2) print(counter1 | counter2) # Вывод: Counter({'p': 10, 's': 8, 'i': 2, 'm': 1}) Counter({'s': 40, 'i': 10, 'p': 10, 'm': 3}) ","date":"24-07-2024","objectID":"/notes/collections2/:5:6","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"ChainMap\rДля использования: from collections import ChainMap ChainMap представляет из себя объединение нескольких словарей. Этот объект группирует словари вместе, что позволяет рассматривать их как единое целое. ChainMap был добавлен в модуль collections в версии Python 3.3. Этот класс не создаёт новый словарь, вместо этого он хранит ссылки на исходные словари в списке, что, грубо говоря, позволяет программисту иметь несколько одноимённых ключей в одном словаре. Раз ChainMap содержит ссылки на объекты, то изменение содержания любого словаря, на основании которого создан ChainMap, изменяет и сам ChainMap объект. Аналогично, изменение ChainMap объекта приводит к изменению словаря, на основании которого он создан. Чтобы создать объект ChainMap, можно, например, передать в конструктор словари: from collections import ChainMap empty_chain_map = ChainMap() print(empty_chain_map) numbers = {'one': 1, 'two': 2} letters = {'a': 'A', 'b': 'B'} chain_map = ChainMap(numbers, letters) print(chain_map) # Вывод: ChainMap({}) ChainMap({'one': 1, 'two': 2}, {'a': 'A', 'b': 'B'}) В ChainMap можно также передать любой из уже изученных словарей: defaultdict, OrderedDict, Counter. При этом нужно понимать, что поиск по ChainMap объекту будет учитывать особенность поиска по соответствующим словарям. Для defaultdict, в случае если ключ отсутствует, вернётся значение по умолчанию, для Counter — нулевое значение. from collections import defaultdict, OrderedDict, Counter, ChainMap numbers = OrderedDict(one=1, two=2) letters = defaultdict(str, {'a': 'A', 'b': 'B'}) counter = Counter('aabbbcccc') chain_map = ChainMap(numbers, letters, counter) print(chain_map) # Вывод: ChainMap(OrderedDict([('one', 1), ('two', 2)]), defaultdict(\u003cclass 'str'\u003e, {'a': 'A', 'b': 'B'}), Counter({'c': 4, 'b': 3, 'a': 2})) Либо же, можно воспользоваться методом fromkeys(): from collections import ChainMap chain_map1 = ChainMap.fromkeys(['one', 'two', 'three']) chain_map2 = ChainMap.fromkeys(['one', 'two', 'three'], -1) print(chain_map1) print(chain_map2) # Вывод: ChainMap({'one': None, 'two': None, 'three': None}) ChainMap({'one': -1, 'two': -1, 'three': -1}) Для получения значений по ключу в ChainMap объектах используется такой же механизм, как и в обычных словарях. Либо мы используем квадратные скобки, либо метод get(). Рассмотрим объект, в котором ключи повторяются: from collections import ChainMap for_adoption = {'dogs': 15, 'cats': 8, 'pythons': 9} vet_treatment = {'dogs': 7, 'cats': 2, 'tigers': 3} pets = ChainMap(for_adoption, vet_treatment) print(pets['dogs']) print(pets['cats']) print(pets['pythons']) print(pets['tigers']) # Вывод: 15 8 9 3 Как видно, в ситуации, когда у объединяемых словарей есть повторяющиеся ключи, возвращается только первое вхождение этого ключа. Таким образом, поиск по ChainMap объекту всегда осуществляется в том же порядке, в котором словари были указаны при создании этого объекта, при этом поиск останавливается, как только значение по нужному ключу найдено. Встроенная функция len() вернёт количество уникальных ключей ChainMap объекта. from collections import ChainMap for_adoption = {'dogs': 15, 'cats': 8, 'pythons': 9} vet_treatment = {'dogs': 7, 'cats': 2, 'tigers': 3} pets = ChainMap(for_adoption, vet_treatment) print(len(pets)) # Вывод: 4 ","date":"24-07-2024","objectID":"/notes/collections2/:6:0","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Итерирование по ChainMap\rИтерирование по ChainMap объекту происходит в обратном порядке от последнего указанного словаря к первому. from collections import ChainMap numbers = {'one': 1, 'two': 2} letters = {'a': 'A', 'b': 'B'} alpha_num = ChainMap(numbers, letters) for key in alpha_num: print(key, '-\u003e', alpha_num[key]) # Вывод: a -\u003e A b -\u003e B one -\u003e 1 two -\u003e 2 При этом, если присутствуют дубликаты ключей, возвращаться будет последнее значение (имеется ввиду последнее при итерировании по объекту ChainMap, то есть первое значение, если идти сверху вниз). from collections import ChainMap for_adoption = {'dogs': 15, 'cats': 8, 'pythons': 9} vet_treatment = {'dogs': 7, 'cats': 2, 'tigers': 3} pets = ChainMap(for_adoption, vet_treatment) for key in pets: print(key, '-\u003e', pets[key]) # Вывод: dogs -\u003e 15 cats -\u003e 8 tigers -\u003e 3 pythons -\u003e 9 При итерировании, как и с обычными словарями, позволяется использовать методы keys(), values(), items(): from collections import ChainMap for_adoption = {'dogs': 15, 'cats': 8, 'pythons': 9} vet_treatment = {'dogs': 7, 'cats': 2, 'tigers': 3} pets = ChainMap(for_adoption, vet_treatment) for key in pets.keys(): print(key, '-\u003e', pets[key]) print() for value in pets.values(): print(value) print() for key, value in pets.items(): print(key, '-\u003e', value) ","date":"24-07-2024","objectID":"/notes/collections2/:6:1","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Мутация ChainMap\rДля изменения объектов типа ChainMap можно использовать те же способы, что и для изменения обычного словаря. Позволяется обновлять, добавлять, удалять и извлекать элементы. При этом нужно знать, что все эти операции действуют только на первый из объединяемых словарей. from collections import ChainMap numbers = {'one': 1, 'two': 2} letters = {'a': 'A', 'b': 'B'} alpha_num = ChainMap(numbers, letters) print(alpha_num) alpha_num['c'] = 'C' print(alpha_num) alpha_num['b'] = 'b' print(alpha_num) alpha_num.pop('two') print(alpha_num) del alpha_num['c'] print(alpha_num) alpha_num.clear() print(alpha_num) # Вывод: ChainMap({'one': 1, 'two': 2}, {'a': 'A', 'b': 'B'}) ChainMap({'one': 1, 'two': 2, 'c': 'C'}, {'a': 'A', 'b': 'B'}) ChainMap({'one': 1, 'two': 2, 'c': 'C', 'b': 'b'}, {'a': 'A', 'b': 'B'}) ChainMap({'one': 1, 'c': 'C', 'b': 'b'}, {'a': 'A', 'b': 'B'}) ChainMap({'one': 1, 'b': 'b'}, {'a': 'A', 'b': 'B'}) ChainMap({}, {'a': 'A', 'b': 'B'}) Опасность\rПри попытке удаления значения по ключу, которого нет в первом словаре, возникает ошибка KeyError\rУказывая в качестве первого аргумента для ChainMap пустой словарь, получается поведение, при котором все изменения ChainMap объекта не затрагивают объединяемые (исходные) словари. ","date":"24-07-2024","objectID":"/notes/collections2/:6:2","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Сравнение ChainMap\rДва объекта типа ChainMap (к примеру, chainmap1 и chainmap2) считаются равными, если значение следующего выражения равно True: dict(chainmap1.items()) == dict(chainmap2.items()). Учитывая специфику работы метода items(), равенство двух объектов типа ChainMap не гарантирует того, что эти объекты в точности совпадают: from collections import ChainMap chainmap1 = ChainMap({'a': 10, 'b': 20}) chainmap2 = ChainMap({'a': 10, 'b': 20}) print(chainmap1 == chainmap2) chainmap1 = ChainMap({'a': 10, 'b': 20}, {'a': 1, 'b': 2}) chainmap2 = ChainMap({'a': 10, 'b': 20}) print(chainmap1 == chainmap2) # Вывод: True True ","date":"24-07-2024","objectID":"/notes/collections2/:6:3","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Атрибут maps\rКак уже было сказано, Объект ChainMap хранит ссылки на все объединяемые словари во внутреннем списке, который доступен через атрибут maps и может быть изменён. Порядок словарей в списке maps соответствует порядку, в котором словари были указаны при создании объекта ChainMap. from collections import ChainMap for_adoption = {'dogs': 15, 'cats': 8, 'pythons': 9} vet_treatment = {'dogs': 7, 'cats': 2, 'tigers': 3} pets = ChainMap(for_adoption, vet_treatment) print(pets) print(pets.maps) print(type(pets.maps)) # Вывод: ChainMap({'dogs': 15, 'cats': 8, 'pythons': 9}, {'dogs': 7, 'cats': 2, 'tigers': 3}) [{'dogs': 15, 'cats': 8, 'pythons': 9}, {'dogs': 7, 'cats': 2, 'tigers': 3}] \u003cclass 'list'\u003e Инфо\rПри создании пустого ChainMap объекта его maps будет содержать пустой словарь.\rАтрибут maps является обычным списком, поэтому он поддерживает все основные операции со списками. Мы можем добавлять в него новые словари, удалять уже добавленные, а также изменять их порядок. from collections import ChainMap for_adoption = {'dogs': 15, 'cats': 8, 'pythons': 9} vet_treatment = {'dogs': 7, 'cats': 2, 'tigers': 3} pets = ChainMap(for_adoption, vet_treatment) pets.maps.reverse() pets.maps[0]['lions'] = 10 del pets.maps[1]['cats'] print(pets) print(pets.maps) # Вывод: ChainMap({'dogs': 7, 'cats': 2, 'tigers': 3, 'lions': 10}, {'dogs': 15, 'pythons': 9}) [{'dogs': 7, 'cats': 2, 'tigers': 3, 'lions': 10}, {'dogs': 15, 'pythons': 9}] Инфо\rИзменяя порядок словарей в списке атрибута maps, мы также меняем сами объединяемые словари, а также порядок поиска в объекте ChainMap\rАтрибут maps можно использовать для обработки абсолютно всех значений во всех словарях. С помощью этого атрибута мы можем обойти поведение по умолчанию, заключающееся в получении (изменении) первого значения из первого словаря. from collections import ChainMap for_adoption = {'dogs': 15, 'cats': 8, 'pythons': 9} vet_treatment = {'dogs': 7, 'cats': 2, 'tigers': 3} pets = ChainMap(for_adoption, vet_treatment) for animals in pets.maps: for key, value in animals.items(): print(key, '-\u003e', value) # Вывод: dogs -\u003e 15 cats -\u003e 8 pythons -\u003e 9 dogs -\u003e 7 cats -\u003e 2 tigers -\u003e 3 ","date":"24-07-2024","objectID":"/notes/collections2/:6:4","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Метод new_child()\rnew_child() возвращает новый объект ChainMap(), содержащий новый переданный словарь в качестве первого элемента, за которым следуют все исходные словари объекта, к которому этот метод применялся. Вызов этого метода (например, d.new_child()) эквивалентен вызову ChainMap({}, *d.maps). from collections import ChainMap dad = {'name': 'Timur', 'age': 29} mom = {'name': 'Rosaly', 'age': 28} old_family = ChainMap(dad, mom) son = {'name': 'Soslan', 'age': 0} new_family = old_family.new_child(son) print(old_family) print(new_family) # Вывод: ChainMap({'name': 'Timur', 'age': 29}, {'name': 'Rosaly', 'age': 28}) ChainMap({'name': 'Soslan', 'age': 0}, {'name': 'Timur', 'age': 29}, {'name': 'Rosaly', 'age': 28}) ","date":"24-07-2024","objectID":"/notes/collections2/:6:5","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Атрибут parents\rparents возвращает новый объект ChainMap, содержащий все словари, кроме первого. Может пригодиться в случае, когда нужно пропустить первый словарь при поиске ключей. Обращение к этому атрибуту (например, d.parents) эквивалентно вызову ChainMap(*d.maps[1:]). from collections import ChainMap dad = {'name': 'Timur', 'age': 29} mom = {'name': 'Rosaly', 'age': 28} son = {'name': 'Soslan', 'age': 0} family = ChainMap(son, dad, mom) print(family) print(family.parents) print(type(family.parents)) # Вывод: ChainMap({'name': 'Soslan', 'age': 0}, {'name': 'Timur', 'age': 29}, {'name': 'Rosaly', 'age': 28}) ChainMap({'name': 'Timur', 'age': 29}, {'name': 'Rosaly', 'age': 28}) \u003cclass 'collections.ChainMap'\u003e ","date":"24-07-2024","objectID":"/notes/collections2/:6:6","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Где используется\rОсновным вариантом использования ChainMap является эффективное управление несколькими областями видимости и определение приоритетов доступа дубликатов ключей. Например, в документации по ChainMap можно найти, как Python обращается к именами переменных в разных пространствах имён. Когда интерпретатор ищет имя (переменную), он последовательно обращается к локальной, глобальной и встроенной (print, list, input и т.д.) областям видимости, которые представляют из себя словари, отображающие имена на объекты. from collections import ChainMap import builtins input = 42 pylookup = ChainMap(locals(), globals(), vars(builtins)) print(pylookup[\"input\"]) del globals()[\"input\"] print(pylookup[\"input\"]) # Вывод: 42 \u003cbuilt-in function input\u003e Вообще, варианты применения этого типа данных довольно специфичны: Эффективная группировка нескольких словарей в одном представлении Поиск по нескольким словарям с определенным приоритетом Представление цепочки значений по умолчанию и управление их приоритетами Повышение производительности кода, который часто вычисляет подмножества словаря Основной источник: https://stepik.org/course/82541 Дополнительные источники: Real Python Python Docs ","date":"24-07-2024","objectID":"/notes/collections2/:6:7","tags":["python","datatypes","modules","collections","namedtuple","defaultdict","ordereddict","counter","chainmap"],"title":"Коллекции в Python. Часть II","uri":"/notes/collections2/"},{"categories":["python"],"content":"Конспект посвящён переменным в Python: как они устроены, чем отличаются от переменных в других ЯП и т.д., а также интернированию, неизменяемым и изменяемым типам данных, поверхностному и глубокому копированию. Начнём с того, что в Python нет переменных. По-крайней мере в том виде, в котором они представлены в более низкоуровневых ЯП, таких как C или C++. Вместо этого в Python — имена. Разберёмся, в чём здесь разница. ","date":"18-07-2024","objectID":"/notes/variables_python/:0:0","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":"Переменные в C и C++\rint num = 101; Исполнение вышележащей строки проходит через три этапа: Выделение достаточного количества памяти для числа; Присвоение этому месту в памяти значения 101; Отображение, что num указывает на это значение. Упрощённо это можно представить следующим образом: Здесь переменная num имеет виртуальный адрес 0x7f1 и значение 101. Если позднее нам захочется изменить значение, это можно сделать так: int num = 102;. Этот код присваивает переменной num новое значение 102, тем самым перезаписывая предыдущее значение. Это означает, что переменная изменяема. Обновлённая схема памяти для нового значения: Расположение переменной в памяти не поменялось, но поменялось значение, а значит num — место в памяти, а не просто имя. Если мы выполним следующий код: int num1 = num;, мы получим уже две абсолютно разные области памяти, с различными адресами (хоть и одинаковым значением). С переменными в Python ситуация другая. ","date":"18-07-2024","objectID":"/notes/variables_python/:1:0","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":"Переменные в Python\rВ Python нет переменных, как таковых, вместо них имена. Вполне допустимо использовать термин переменные, однако важно понимать разницу. Напишем тот же код на Python: num = 101. Исполнение также происходит в несколько этапов: Создаётся специальный объект PyObject; Заполняется его поле Type, которое указывает на тип; Заполняется его поле Value, которое указывает на значение; Создаётся имя num; Имя num начинает указывать на созданный PyObject; Счётчик ссылок (поле Reference Count) объекта PyObject увеличивается на 1. Можно представить себе это следующим образом: Как видно, схемы памяти для Python и C/C++ отличаются. Вместо того, чтобы num владел блоком памяти, в котором хранится значение 101, num ссылается на участок памяти, которой владеет PyObject объект. Присвоим переменной новое значение: num = 102. Исполнение этой строки кода также проходит через несколько этапов: Создаётся новый PyObject; Заполняется его поле Type, которое указывает на тип; Заполняется его поле Value, которое указывает на значение; Имя num указывает на новый PyObject; Счётчик ссылок (поле Reference Count) нового PyObject увеличивается на 1; Счётчик ссылок (поле Reference Count) старого PyObject уменьшается на 1. Взглянем на новую схему памяти: Изображение демонстрирует, что переменная привязалась к новому объекту и отвязалась от предыдущего. К тому же PyObject, содержащий значение 101, теперь имеет счётчик ссылок, равным 0, а значит будет уничтожен сборщиком мусора (GC). Введём новую переменную (имя): num1 = num. В памяти не появится нового объекта, новое имя будет ссылаться на уже существующий (счётчик ссылок которого будет увеличен на 1): Важно также отметить, что структуры данных, ровно как имена, содержат указатели на объекты. Допустим, у нас есть список nums = [1, 2, 3]. В нём не хранятся сами значение, а хранятся указатели на них, а сами объекты 1, 2 и 3 содержатся в других областях памяти. ","date":"18-07-2024","objectID":"/notes/variables_python/:2:0","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":"Адрес объекта\rУ каждого объекта в Python есть собственный идентификатор, который устанавливается только один раз при его создании. Идентификатор объекта – это целое и постоянное число, которое никогда не изменяется после его создания. В стандартной реализации Python (CPython) идентификатор объекта ассоциируется с адресом объекта в памяти. Для того чтобы получить идентификатор объекта, используется встроенная функция id(). name = 'Ivan' age = 29 is_teacher = True print(id(name)) print(id(age)) print(id(is_teacher)) # Возможный вывод: 2226167895200 140710064049464 140710063254608 При каждом новом запуске id будут разные, так как заранее не устанавливается, какое значение будет в определённым участком памяти. Таким образом, объекты, периоды существования которых не пересекаются, могут иметь одинаковый id. Если объекты изменяемые, то в большинстве случаев они будут иметь разные идентификаторы. Например: nums1 = [1, 2, 3] nums2 = [1, 2, 3] print(nums1 == nums2) print(id(nums1)) print(id(nums2)) # Вывод: True 2303843075456 2303886617792 Инфо\rОператор сравнения == сравнивает объекты поэлементно, а не по id\rПолучаем, что переменные nums1 и nums2 указывают на разные адреса памяти, хоть и имеют одинаковое содержимое. Нужно также помнить, что оператор присваивания =, никогда не создает копию данных, а, скорее, привязывает имя к объекту. Следующий код будет выводить одинаковые id: nums1 = [1, 2, 3] nums2 = nums1 print(id(nums1)) print(id(nums2)) # Вывод: 2002273207680 2002273207680 Инфо\rНекоторые объекты существуют в единичном экземпляре, например None, True, False и другие\rОператор is\rС помощью оператора is можно сравнить id объектов: nums1 = [1, 2, 3] nums2 = [1, 2, 3] nums3 = nums1 print(nums1 is nums2, nums1 == nums2) print(nums1 is nums3, nums1 == nums3) print(nums2 is nums3, nums2 == nums3) # Вывод: False True True True False True Для проверки значения на равенство с None обычно используют is: value = None if value is None: print('Пусто') ","date":"18-07-2024","objectID":"/notes/variables_python/:2:1","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":"Интернирование объектов\rКак мы знаем, в Python целые числа (тип int) и строки (тип str) являются неизменяемыми. Это значит, что после того как строковые и целочисленные объекты были созданы, мы не можем изменить или обновить их. Даже если кажется, что строка изменяется, например, после использования метода, на самом деле создается новая строка, а исходная остается прежней. Учитывая неизменяемость строковых и целочисленных объектов, Python использует специальную оптимизацию, которая называется интернированием. Интернирование — это процесс хранения в памяти только одной копии объекта. Это означает, что, когда мы создаем две строки (два целых числа) с одинаковыми значениями, то вместо выделения памяти для них обоих, только одна строка (целое число) фактически фиксируется в памяти. Другая же просто указывает на то же самое место в памяти. Для реализации данной оптимизации Python использует специальную таблицу, которая называется пул интернирования. Эта таблица содержит одну уникальную ссылку на каждый объект строкового типа, либо целого числа. Основные преимущества интернирования: Экономия памяти: мы не храним копии одинаковых объектов; Быстрые сравнения: сравнение интернированных строк происходит намного быстрее, чем неинтернированных строк. Это происходит потому, что для сравнения интернированных строк нужно только сравнить, совпадают ли их адреса в памяти, а не сравнивать их содержимое. Интернирование целых чисел\rPython интернирует целые числа в диапазоне [-5; 256]. Если мы наберём следующий код в IDLE: num1 = 100 num2 = 100 num3 = 1000 num4 = 1000 print(num1 is num2, num1 == num2) print(num3 is num4, num3 == num4) получим такой результат: True True False True Но среда, в которой пишется код, может самостоятельно указывать диапазон интернирования. Так, в VS Code, тот же самый код вернёт: True True True True Интернирование строк\rВ Python 3.7 интернируются строки, содержащие не более 20 символов и состоящие только из ASCII-букв, цифр и знаков подчёркивания. Данный набор символов был выбран потому, что он часто используется в нашем коде. s1 = 'beegeek' s2 = 'beegeek' s3 = 'bee' + 'geek' print(id(s1)) print(id(s2)) print(id(s3)) # Вывод: 2846528331184 2846528331184 2846528331184 Добавим символ ! в строку: s1 = 'beegeek!' s2 = 'beegeek!' print(id(s1)) print(id(s2)) # Вывод: 2846528331312 2846528331440 Начиная с Python 3.8 длина интернируемых строк была увеличена до 4096 символов. s1 = 'b' * 4096 s2 = 'b' * 4096 s3 = 'b' * 5000 s4 = 'b' * 5000 print(s1 is s2) print(s3 is s4) # Вывод: True False Как я понял, VS Code применяет свои правила интернирования и для строк, а конкретно интернирует любую последовательность символов длинной до 4096 включительно. Функция sys.intern()\rКак мы уже знаем, Python интернирует лишь строки, содержащие не более 4096 символов и состоящие только из ASCII-букв, цифр и знаков подчёркивания. Однако функция intern() из модуля sys позволяет интернировать любую строку, например, содержащую 5000 символов или состоящую из букв русского алфавита. Данная функция принимает в качестве аргумента строку, добавляет ее в пул интернирования (если ее там нет) и возвращает интернированную строку. import sys s1 = sys.intern('степик!') s2 = sys.intern('степик!') print(s1 is s2) # Вывод: True ","date":"18-07-2024","objectID":"/notes/variables_python/:2:2","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":"Изменяемые и неизменяемые типы данных\rТипы данных в Python делятся на две категории: изменяемые (mutable) — list, set, dict, ...; неизменяемые (immutable) — int, float, bool, tuple, str, .... Если мы попытаемся изменить, например, строку, то получим ошибку: data = 'beegeek' data[0] = 'B' print(data) # Вывод: TypeError: 'str' object does not support item assignment В то же время мы запросто можем изменить список: data = ['b', 'e', 'e', 'g', 'e', 'e', 'k'] data[0] = 'B' print(data) # Вывод: ['B', 'e', 'e', 'g', 'e', 'e', 'k'] ","date":"18-07-2024","objectID":"/notes/variables_python/:3:0","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":"Присваивание vs “мутация”\rВ Python есть два вида изменения объектов: Присваивание переменной нового объекта Мутация (непосредственное изменение) самого объекта Слово “изменение” зачастую носит двусмысленный характер. Фраза “мы изменили x” может означать “мы переназначили x”, а может означать “мы мутировали объект, на который указывает x”. Например, следующий код повторно связывает имя с совершенно новым объектом: x = x + 1 (адрес num изменился). Но такая операция как num.append(7) добавляет элемент в уже существующий объект, то есть num указывает всё на тот же объект (адрес num не изменился). Инфо\rРабота += в Python реализована через значение x. Эти две строки эквивалентны: x += y и x = x.__iadd__(y)\rТаким образом, если несколько имён ссылаются на один изменяемый объект, и программист модифицирует этот объект, изменения отразятся в каждом из имён: nums1 = [1, 2, 3] nums2 = nums1 nums1.append(4) print(nums1) print(nums2) [1, 2, 3, 4] [1, 2, 3, 4] Важно понимать, что со списками операции x = x + y и x += y работают по-разному. В первом случае, как мы уже знаем, создаётся новый объект, но при += модифицируется существующий список: nums1 = [1, 2, 3] nums2 = nums1 nums3 = [1, 2, 3] nums4 = nums3 nums1 = nums1 + [4, 5] print(nums1) print(nums2) print() print(nums3) print(nums4) # Вывод: [1, 2, 3, 4, 5] [1, 2, 3] [1, 2, 3, 4, 5] [1, 2, 3, 4, 5] Причина такого поведения в том, что список реализует __iadd__ следующим образом: class List: def __iadd__(self, other): self.extend(other) return self То есть такой код: nums1 += nums2, эквивалентен: nums1.extend(nums2). ","date":"18-07-2024","objectID":"/notes/variables_python/:3:1","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":"Модуль copy\rДля использования: import copy. Как мы уже знаем, оператор присваивания в Python не создает копию объекта, он лишь связывает имя переменной с объектом. Для создания реальных копий объектов в Python используют модуль copy. Модуль copy содержит две функции: copy(): копирует объект и возвращает его поверхностную копию; deepcopy(): копирует объект и возвращает его глубокую копию. Разницу между этими видами копирования можно проследить только для коллекций. ","date":"18-07-2024","objectID":"/notes/variables_python/:4:0","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":"Поверхностное копирование\rПоверхностное копирование создает отдельный новый объект, но вместо копирования дочерних элементов в новый объект, оно просто копирует ссылки на их адреса памяти. import copy data1 = [1, 2, 3] data2 = copy.copy(data1) data1.append(4) print(id(data1), data1) print(id(data2), data2) # Вывод: 2072210867584 [1, 2, 3, 4] 2072250543808 [1, 2, 3] Как видно, id объектов, как и их содержимое, различаются, так как элементами списка являются целые числа, поэтому изменение одного списка не отражается на другом. Если бы элементами списка были бы изменяемые типы, то поверхностное копирование скопировало бы лишь ссылки на их адреса памяти. Следовательно, любое изменение элементов одного объекта отразилось бы также и на элементах другого объекта. В следующем коде видно, что изменения затронули оба списка, потому что оба они содержат ссылки на один и тот же вложенный объект. Так работает поверхностное копирование: import copy data1 = [[1, 2, 3], [4, 5, 6]] data2 = copy.copy(data1) data1[0].append(7) data2[1].append(8) print(id(data1), data1) print(id(data2), data2) # Вывод: 2088862020160 [[1, 2, 3, 7], [4, 5, 6, 8]] 2088872808384 [[1, 2, 3, 7], [4, 5, 6, 8]] У списков, словарей и множеств есть собственный метод copy(), создающий их поверхностную копию: data1 = [1, 2, 3, 4] data2 = [[1, 2], [3, 4]] new_data1 = data1.copy() new_data2 = data2.copy() Поверхностную копию также можно создать, используя соответствующие функции для каждой коллекции (list, dict, set, ...): data1 = [1, 2, 3, 4] data2 = {'a': 1, 'b': 2} data3 = {1, 2, 3, 4} new_data1 = list(data1) new_data2 = dict(data2) new_data3 = set(data3) Ещё поверхностную копию списка можно сделать через срез: new_data = data[:] ","date":"18-07-2024","objectID":"/notes/variables_python/:4:1","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":"Глубокое копирование\rГлубокое копирование создаёт копию составного объекта рекурсивно. Это означает, что любые изменения, внесенные вами в новую копию объекта, не будут отражаться в исходной, и наоборот. import copy data1 = [[1, 2, 3], [4, 5, 6]] data2 = copy.deepcopy(data1) data1[0].append(7) data2[1].append(8) print(id(data1), data1) print(id(data2), data2) # Вывод: 2001097388608 [[1, 2, 3, 7], [4, 5, 6]] 2001108045760 [[1, 2, 3], [4, 5, 6, 8]] Инфо\rПри глубоком копировании временные затраты на создание копии, очевидно выше чем при создании поверхностной копии. Если копируемый объект имеет сложную вложенную структуру, то глубокое копирование может занять кучу времени.\rОсновной источник: https://stepik.org/lesson/624529/step/1?unit=620219 Дополнительные источники: Habr Ned Batchelder ","date":"18-07-2024","objectID":"/notes/variables_python/:4:2","tags":["python","memory","modules","copy"],"title":"Переменные и объекты в Python","uri":"/notes/variables_python/"},{"categories":["python"],"content":" Конспект посвящён объяснению понятия компьютерной памяти и тому, как эта память устроена в языке программирования Python ","date":"18-07-2024","objectID":"/notes/memory_python/:0:0","tags":["python","memory"],"title":"Устройство памяти в Python","uri":"/notes/memory_python/"},{"categories":["python"],"content":"Компьютерная память\rКак можем видеть из схемы ниже, память в компьютере разделяется на внутреннюю и внешнюю: Посмотрим подробнее на каждый тип памяти. ","date":"18-07-2024","objectID":"/notes/memory_python/:1:0","tags":["python","memory"],"title":"Устройство памяти в Python","uri":"/notes/memory_python/"},{"categories":["python"],"content":"Внутренняя память\rХарактерными особенностями внутренней памяти по сравнению с внешней являются высокое быстродействие и ограниченный объем. Физически внутренняя память компьютера представляет собой интегральные микросхемы, которые размещаются в специальных гнездах на материнской плате. Чем больше размер внутренней памяти, тем более сложную задачу и с большей скоростью может решить компьютер. Внутренняя память подразделяется на: постоянную память оперативную память кэш-память Постоянная память (ROM — read-only memory) — энергозависимая память, использующаяся для долговременного хранения неизменяемого массива данных. Содержание ПЗУ специальным образом закладывается при его изготовлении для постоянного хранения. Из название как раз можно понять, что данная память предназначена только для чтения. Оперативная память (RAM — Random Access Memory) — в большинстве случаев энергозависимая память, хранящая выполняемый машинный код программ, входные, выходные и промежуточные данные, обрабатываемые процессором в текущем сеансе работы ПК. После выключения питания компьютера, полностью очищается. Микросхемы оперативной памяти монтируются на печатной плате. Каждая такая плата снабжена контактами, расположенными вдоль нижнего края. Для подключения к другим устройствам компьютера такая плата вставляется своими контактами в специальный разъем (слот) на материнской плате. Материнская плата имеет несколько разъемов для модулей оперативной памяти, суммарный объем которых может принимать ряд фиксированных значений, например 2, 4, 8, 16, 32 Гб и более. Оперативная память бывает нескольких типов: SDRAM, DDR, DDR2, DDR3, DDR4, DDR5. Каждый последующий тип памяти представляет собой улучшение предыдущего и позволяет новой памяти работать с большей скоростью. В данный момент в современных компьютерах используется оперативная память типа DDR4 и DDR5. Кэш-память (cache) — промежуточный буфер с быстрым доступом к нему, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. Эта память используется при обмене данными между процессором и оперативной памятью. Алгоритм ее работы позволяет сократить частоту обращений процессора к оперативной памяти и, следовательно, повысить производительность компьютера. Современные процессоры оснащены кэшем, который состоит зачастую из трех уровней: L1 (первый уровень), L2 (второй уровень), L3 (третий уровень). L1 — наиболее быстрый уровень кэш-памяти, который работает напрямую с ядром процессора, в следствии чего обладает наименьшим временем доступа и работает на частотах, близких процессору. Размер данного кэша обычно не велик, а количество микросхем зачастую привязано к количеству ядер процессора, при этом у каждого ядра кэш свой собственный. Размер блока может варьироваться от 64-256 КБ у десктопов и ноутбуков до 1-2 МБ для серверных решений. Сам L1 тоже имеет свое разделение. Он делится на кэш команд и кэш данных: Первый содержит информацию об операции, которой занимается ЦП, проще говоря, отвечает на вопрос: «Что надо сделать»; Второй хранит в себе данные, над которыми должны производиться вычисления. L2 — второй уровень более масштабный, нежели первый, но в результате, обладает меньшими скоростными характеристиками. Также привязан к ядру и не взаимодействует с остальными. L3 — третий уровень. Он более медленный, нежели два предыдущих, но всё же гораздо быстрее, чем оперативная память. Этот блок уже доступен для всех ядер процессора. На третьем уровне временно хранятся данные, которые хоть и важны для продуктивной работы, но регистры обращаются за этой информацией относительно нечасто. ","date":"18-07-2024","objectID":"/notes/memory_python/:1:1","tags":["python","memory"],"title":"Устройство памяти в Python","uri":"/notes/memory_python/"},{"categories":["python"],"content":"Внешняя память\rНазначение внешней памяти компьютера заключается в долговременном хранении информации любого вида. Выключение питания компьютера не приводит к очистке внешней памяти и её объём в тысячи раз больше объёма внутренней памяти. Минус такой памяти в том, что обращение к ней требует гораздо большего времени. К устройствам внешней памяти относятся: Жёсткие магнитные диски (HDD — Hard Disk Drive) Твердотельные накопители (SSD — Solid State Drive) Оптические диски (CD-ROM, DVD-ROM, Blue-Ray и т.д.) Флеш-накопители Гибкие магнитные диски Наиболее распространенный вариант постоянной памяти — жесткие диски HDD. Они представляют собой один или несколько магнитных дисков, вращающихся с огромной скоростью (от 5 до 12 тысяч оборотов в минуту), и головок, предназначенных для считывания и записи информации. HDD являются надежными носителями информации, позволяют записывать и считывать информацию огромное количество раз. Неудобство в том, что они очень медленные и восприимчивы к ударам, падениям и прочим механическим воздействиям, особенно в момент работы. Почти у каждого уверенного пользователя ПК в наши дни скорее найдётся SSD, чем HDD. Их популярность неудивительна, ведь они имеют гораздо более высокую скорость записи и чтения и невосприимчивы к механическим воздействиям. Их можно было бы назвать идеальными накопителями, если бы не ощутимо конечное количество циклов чтения-записи. ","date":"18-07-2024","objectID":"/notes/memory_python/:1:2","tags":["python","memory"],"title":"Устройство памяти в Python","uri":"/notes/memory_python/"},{"categories":["python"],"content":"Управление памятью в Python\rУправление памятью — это процесс выделения, распределения и координации памяти таким образом, чтобы все программы работали правильно и могли оптимально получать доступ к различным системным ресурсам. Управление памятью также включает в себя и очистку памяти от объектов, которые больше не нужны. Существует два типа управления памятью: ручное и автоматическое. Ручное управление включает в себя, как правило, три этапа: Запрос памяти у операционной системы Работа с ней Возвращение памяти обратно в операционную систему Ручной подход управления (как в C, C++, Pascal и т.д.) позволяет работать с памятью максимально эффективно. Программист точно знает, сколько памяти ему выделено, зачем он её использует, и т.д. Однако помимо преимуществ такой подход имеет и ряд недостатков. Ключевой из них — сложность. Управлять памятью вручную — сложно и тяжело, поскольку легко забыть вернуть память обратно операционной системе, в результате чего возникает утечка: программа держит неиспользуемую память просто так, не давая применять ее для решения других задач. Автоматическое управление памятью (как в Python, Java, JS, C#, Ruby и т.д.) берет на себя самый сложный этап — возвращение памяти обратно операционной системе, когда она уже не требуется. Восстановленная память может использоваться другими объектами. В определённых случаях это менее эффективно, но позволяет сильно сократить трудозатраты и повысить надежность процесса. Python — это язык с автоматическим управлением памятью. Причем для управления ею он использует несколько механизмов. При запуске Python программы создается новый процесс, в рамках которого операционная система выделяет пул ресурсов, включая виртуальное адресное пространство. В эту память загружается интерпретатор Python вместе со всеми необходимыми ему для работы данными, включая код написанной программы. Оставшаяся свободная виртуальная память может использоваться для хранения информации об объектах Python. Для управления этой памятью в CPython используется специальный механизм, который называется аллокатор. Он используется каждый раз, когда вам нужно создать новый объект. Обычно мы в своих программах не оперируем большими объектами. Большая часть наших данных — это числа, строки и т.д., они занимают не такой уж большой объем в расчёте на одно значение. Но зато мы создаем их достаточно часто. И это приводило бы к проблемам, если бы Python абсолютно все такие вызовы транслировал в операционную систему. Системный вызов на выделение памяти — штука трудозатратная, зачастую связанная с переходом в контекст ядра операционной системы. Поэтому одна из главных задач аллокатора Python — оптимизация количества системных вызовов. Инфо\rДля больших объектов (больше 512 байт) Python выделяет память напрямую у ОС. Обычно таких объектов не очень много в рамках программы, и создаются они нечасто. Поэтому накладные расходы на создание таких объектов напрямую в RAM не так высоки.\rАллокатор для малых объектов (не больше 512 байт) использует три уровня абстракции: Блок — кусок памяти, используемый для хранения одного объекта. Пул — страница памяти, содержащий блоки (обычно 4 килобайта). Арена — большой непрерывный кусок памяти, содержащий пулы (обычно 256 килобайт). Блок\rБлок — это кусок памяти, который может содержать только один Python объект фиксированного размера. Размер блока может варьироваться от 8 до 512 байт и должен быть кратен восьми. Все блоки в конкретном пуле имеют одинаковый размер и находятся в одном классе размера, который и определяет размер блока. Запрос памяти в байтах Размер блока в байтах Индекс класса размера 1-8 8 0 9-16 16 1 17-24 24 2 25-32 32 3 33-40 40 4 41-48 48 5 … … … 505-512 512 63 Таким образом, если необходимы: 6 байт, то данные будут помещены в блок размером 8 байт; 42 байта, то данные будут помещены в блок размером 48 байт; и т.д. Пул\rПулы состоят из блоков одного размера. Каждый пул работает по принципу двусвязного списка с другими пулами того же размера, поэтому алгоритм может с легкос","date":"18-07-2024","objectID":"/notes/memory_python/:2:0","tags":["python","memory"],"title":"Устройство памяти в Python","uri":"/notes/memory_python/"},{"categories":["python"],"content":"Очистка памяти\rКак мы уже знаем, язык Python является языком с автоматически управляемой памятью, то есть программисту, пишущему код на Python, не нужно беспокоиться о работе с памятью, в частности заниматься ее освобождением. Как только данные программы (объекты в Python) больше не нужны, Python автоматически освобождает память, которую они занимали. Несмотря на это, понимание того, как работает механизм очистки памяти, может помочь писать более качественный и производительный код. Стандартный интерпретатор Python использует сразу два механизма очистки памяти: Подсчёт ссылок; Сборщик мусора (Garbage Collector, GC). ","date":"18-07-2024","objectID":"/notes/memory_python/:3:0","tags":["python","memory"],"title":"Устройство памяти в Python","uri":"/notes/memory_python/"},{"categories":["python"],"content":"Подсчёт ссылок\rАлгоритм подсчета ссылок — это один из самых простых механизмов очистки памяти. Объекты удаляются как только на них больше нет ссылок. Каждый объект в Python унаследован от базового класса PyObject, который содержит специальное поле Reference Count (ob_refcnt), в котором хранится количество ссылок на данный объект. Как только кто-то начинает ссылаться на объект, значение этого поля увеличивается на единицу. Если по какой-то причине ссылка пропадает, то это поле уменьшается на один. При этом если счетчик ссылок для определенного объекта достигает нуля, то интерпретатор запускает процесс уничтожения объекта. Если удаленный объект содержал ссылки на другие объекты, то эти ссылки также удаляются. Таким образом, удаление одного объекта может повлечь за собой удаление других. Инфо\rМеханизм подсчета ссылок работает в режиме реального времени.\rЧетыре основных сценария, увеличивающих количество ссылок на объект: Создание нового объекта и присвоение его переменной; Присвоение уже существующего объекта переменной; Передача объекта в функцию в качестве аргумента; Добавление объекта в список, множество, словарь и т.д. Четыре основных сценария, уменьшающих количество ссылок на объект: Удаление объекта из области видимости функции после ее завершения; Удаление переменной с помощью оператора del; Переприсваивание переменной нового значения; Удаление объекта из списка, множества, словаря и т.д. Для получения количества ссылок на заданный объект используется функция getrefcount() из модуля sys. import sys nums = [1, 2, 3] print(sys.getrefcount(nums)) # Вывод: 2 Когда мы вызываем функцию getrefcount() для получение количества ссылок на объект, мы увеличиваем количество ссылок на объект на один, так как передаем nums в качестве аргумента в функцию. Поэтому счетчик ссылок равен 2. Это означает, что и переменная nums, и функция getrefcount() ссылаются на один и тот же список [1, 2, 3]. Алгоритм подсчета ссылок очень простой и эффективный, но у него есть один большой недостаток. Он не умеет определять циклические ссылки. Приведённый ниже код создаёт циклические ссылки, так как nums1 содержит ссылку на nums2, в то время как nums2 содержит ссылку на nums1. Таким образом, счетчики ссылок у nums1 и nums2 никогда не будут равны нулю. nums1 = [1, 2, 3] nums2 = [4, 5] nums1.append(nums2) nums2.append(nums1) Именно из-за этого в Python существует дополнительный механизм очистки памяти — сборщик мусора (Garbage Collector, GC), который следит за объектами с потенциальными циклическими ссылками. Инфо\rВ Python алгоритм подсчета ссылок является фундаментальным и не может быть отключен, тогда как сборщик мусора (GC) опционален и может быть отключен.\rКоличество ссылок на определенный объект иногда может оказаться заметно больше, чем кажется на первый взгляд. Дело в том, что многие неизменяемые объекты уже используются, например, в реализациях встроенных функций и типов данных. Объекты, относящиеся к изменяемым типам данных данной особенности не подвержены, так как изменение такого объекта в одной части программы привело бы к его изменению в другой части программы. import sys print(sys.getrefcount(0)) # число 0 print(sys.getrefcount(1)) # число 1 print(sys.getrefcount('')) # пустая строка print(sys.getrefcount(())) # пустой кортеж # Возможный вывод: 164 84 58 1257 Счетчик ссылок подвержен проблемам в многопоточной среде, которые могут приводить к некорректности обновления этого счетчика из разных потоков и, следовательно, к удалению объектов, на которые еще существуют ссылки. Чтобы этого избежать, CPython использует GIL — Global Interpreter Lock. Каждый раз, когда происходит работа с памятью, GIL — как глобальная блокировка — препятствует выполнению этих действий одновременно из двух потоков. Он гарантирует, что сначала отработает один, потом другой. ","date":"18-07-2024","objectID":"/notes/memory_python/:3:1","tags":["python","memory"],"title":"Устройство памяти в Python","uri":"/notes/memory_python/"},{"categories":["python"],"content":"Сборщик мусора\rВ отличие от алгоритма подсчета ссылок, сборщик мусора не работает в режиме реального времени и запускается периодически. Каждый запуск сборщика создаёт микропаузы в работе программы, поэтому Python использует различные эвристики для определения частоты запуска сборщика мусора. Сборщик мусора разделяет все объекты на 3 поколения (нулевое, первое и второе). Новые объекты попадают в нулевое поколение. Если новый объект выживает в процессе сборки мусора, то он перемещается в следующее поколение. Чем старше поколение, тем реже оно сканируется на сборку мусора. Так как новые объекты зачастую имеют очень маленький срок жизни (являются временными), то имеет смысл проверять их чаще, чем те, которые уже прошли через несколько этапов сборки мусора. В каждом поколении есть специальный порог срабатывания, при достижении которого срабатывает процесс сборки мусора. Если сразу несколько поколений преодолели порог, то выбирается наиболее старшее поколение, так как сборка мусора в старших поколениях включает в себя также сборку мусора и в младших поколениях. Основной источник: https://stepik.org/course/82541/syllabus Дополнительные источники: Habr Market.Marvel.ru GitHub ","date":"18-07-2024","objectID":"/notes/memory_python/:3:2","tags":["python","memory"],"title":"Устройство памяти в Python","uri":"/notes/memory_python/"},{"categories":["python"],"content":" Конспект посвящён скрытым особенностям и неочевидным деталям логических операторов в Python ","date":"14-07-2024","objectID":"/notes/deep_bool_oper_python/:0:0","tags":["python"],"title":"Углубление в логические операторы Python","uri":"/notes/deep_bool_oper_python/"},{"categories":["python"],"content":"Truthy и falsy объекты\rFalsy — объекты, которые могут быть оценены как значение False. К ним относятся следующие объекты: Значение False Значение None Числовые нули: 0, 0.0, 0j, Decimal(0), Fraction(0, 1) Пустые последовательности и коллекции: b'', bytearray(b''), '', [], (), {}, set(), range(0) Truthy — объекты, которые могут быть оценены как значение True. К ним относятся все объекты, не относящиеся к falsy. Чтобы представить такие объекты в булевом виде, можно использовать функцию bool(). ","date":"14-07-2024","objectID":"/notes/deep_bool_oper_python/:1:0","tags":["python"],"title":"Углубление в логические операторы Python","uri":"/notes/deep_bool_oper_python/"},{"categories":["python"],"content":"Операторы and и or\rОператоры and и or не приводят свои результаты принудительно к значениям True или False, а возвращают один из своих операндов. Такой подход позволяет использовать эти операторы в более общих операциях, а не только в булевых. Для начала посмотрим на оператор or: print(None or 0) print(0 or 5) print('beegeek' or None) print([1, 2, 3] or [6, 9]) print(1 or 'beegeek' or None) print(0.0 or 'habr' or {'one': 1}) print(0 or '' or [6, 9]) print(0 or '' or []) print(0 or '' or [] or {}) # Вывод: 0 5 beegeek [1, 2, 3] 1 habr [6, 9] [] {} Как можно видеть, оператор or оценивает каждый свой операнд как truthy или falsy объект, однако возвращает не значение True или False, а сам объект по определенному правилу — первый truthy объект либо последний объект, если truthy объекты в логическом выражении не найдены. Подобным образом с помощью or можно определять значение по умолчанию, к примеру: greet = input(\"Ваше имя \u003e\u003e \") or \"noname\" print(f\"Привет, {greet}!\") Если пользователь ничего не передаст в функцию input(), в переменную greet попадёт строка \"noname\". Перейдём к оператору and: print(None and 10) print(5 and 0.0) print('beegeek' and {}) print([1, 2, 3] and [6, 9]) print(1 and 'beegeek' and None) print('habr' and 0 and {'one': 1}) print(10 and [6, 9] and []) # Вывод: None 0.0 {} [6, 9] None 0 [] Оператор and возвращает первый falsy объект либо последний объект, если falsy объекты в логическом выражении не найдены. ","date":"14-07-2024","objectID":"/notes/deep_bool_oper_python/:2:0","tags":["python"],"title":"Углубление в логические операторы Python","uri":"/notes/deep_bool_oper_python/"},{"categories":["python"],"content":"Short-circuit evaluation\rОператоры and и or укорачивают вычисление своих операндов (т.е. используют замыкания): правый операнд вычисляется лишь в том случае, если его значение необходимо для получения истинного значения в операциях and или or. Другими словами, замыкания в логических операциях используются для запуска второй части или последующих частей логического выражения только в том случае, если это актуально! Если левый операнд оператора or является truthy объектом, то общим результатом логического выражения является True, независимо от значения правого операнда. Если левый операнд оператора and является falsy объектом, то общим результатом логического выражения является False, независимо от значения правого операнда. Данный механизм называется вычислением по короткой схеме (short-circuit evaluation) и используется интерпретатором для оптимизации вычислений. Рассмотрим пример: def f(): print('bee') return 3 if True or f(): print('geek') # Вывод: geek Левым операндом оператора or является truthy объект, значит, для вычисления общего результата логического выражения нет необходимости вычислять правый операнд, то есть вызывать функцию f(). Поскольку вызова функции не происходит, в выводе отсутствует строка bee. И наоборот, если заменить or на and, в выводе будут обе строки. ","date":"14-07-2024","objectID":"/notes/deep_bool_oper_python/:3:0","tags":["python"],"title":"Углубление в логические операторы Python","uri":"/notes/deep_bool_oper_python/"},{"categories":["python"],"content":"Приоритет логических операторов\rПриоритет указан от наивысшего к наименьшему: not and or По отношению к другим операторам Python (за исключением оператора присваивания =) логические операторы имеют самый низкий приоритет. a = 5 b = 7 print(not a == b) # True В этом коде сначала сравниваются значения переменных, затем применяется оператор not. Стоит упомянуть, что подобная запись будет вызывать исключение SyntaxError: a = 5 b = 7 print(a == not b) Рассмотрим ещё один пример: print(not 1 == 2 or 3 == 3 and 5 == 6) # Вывод: True Согласно приоритету операторов в первую очередь вычисляются выражения 1 == 2, 3 == 3 и 5 == 6, в результате чего исходное выражение принимает вид not False or True and False. Далее выполняется оператор not, возвращая значение True, после него — оператор and, возвращая значение False. Выражение принимает вид True or False. Последним выполняется оператор or, возвращая общий результат выражения — значение True. P.S. На самом деле после вычисления not 1 == 2 оператор or сразу вернёт True, не вычисляя правую часть. ","date":"14-07-2024","objectID":"/notes/deep_bool_oper_python/:4:0","tags":["python"],"title":"Углубление в логические операторы Python","uri":"/notes/deep_bool_oper_python/"},{"categories":["python"],"content":"Цепочки сравнений\rКак известно, сравнивать объекты в Python можно в укороченной форме, например вместо a \u003c b and b \u003c c писать a \u003c b \u003c c Поскольку оператор and реализует вычисление по короткой схеме, все сравнения, которые располагаются правее сравнения, вернувшего ложный результат, не выполняются, и их операнды не вычисляются: def f(): print('bee') return 3 if 5 \u003c 1 \u003c f(): print('geek') else: print('beegeek') # Вывод: beegeek Пояснение: выражение 5 \u003c 1 \u003c f() эквивалентно выражению 5 \u003c 1 and 1 \u003c f(). Сравнение 5 \u003c 1 возвращает False. В результате сравнение 1 \u003c f() не выполняется, и функция f() не вызывается. Тем не менее между сокращенным и расширенным вариантами записи цепочек сравнений существует важное отличие. В сокращенном выражении значение, стоящее по середине (между операторами сравнения), будет вычислено один раз (если его вообще нужно вычислять), а в развёрнутом выражении — два раза: def f(): print('bee') return 3 if 1 \u003c f() \u003c 5: print('geek') print() if 1 \u003c f() and f() \u003c 5: print('geek') # Вывод: bee geek bee bee geek Помимо операторов сравнения, в цепочку операторов могут объединяться и другие операторы Python. lst = [1, 2, 3] num = 2 print(num in lst == True) # Вывод: False Данное выражение на самом деле эквивалентно выражению num in lst and lst == True, которое, в свою очередь, эквивалентно выражению True and False. Следовательно, результатом данной цепочки операторов является значение False. Рассмотрим ещё один пример: a = 5 b = 5 c = 10 print(a \u003c c is True) print(a == b in [True]) # Вывод: False False Основной источник: https://habr.com/ru/articles/824170/ Доп. источники: Russian Python Docs Stackoverflow ","date":"14-07-2024","objectID":"/notes/deep_bool_oper_python/:5:0","tags":["python"],"title":"Углубление в логические операторы Python","uri":"/notes/deep_bool_oper_python/"},{"categories":["python"],"content":" Конспект посвящён модулям os и shutil, которые могут быть полезны для работы с операционной системой, управлением каталогами и файлами, а также модулю shelve, позволяющему сериализовывать объекты Python ","date":"12-07-2024","objectID":"/notes/os_shutil_shelve/:0:0","tags":["python","modules","os","shutil","shelve"],"title":"Модули os, shutil и shelve","uri":"/notes/os_shutil_shelve/"},{"categories":["python"],"content":"Модуль os\rДля использования: import os Модуль os позволяет взаимодействовать с операционной системой. Например, мы можем перемещаться по папкам, получить информацию о файле, посмотреть и изменить переменные среды (окружения), переместить файлы и так далее. Посмотрим на некоторые функции и объекты, которые мы можем использовать. os.getcwd() возвращает рабочий каталог (тот, в котором пользователь сейчас находится). os.chdir(path) перемещает пользователя в директорию, которая была передана в функцию. os.listdir(path) возвращает случайно упорядоченный список файлов и каталогов, которые находятся в текущем каталоге (если ничего не было передано), либо список объектов в директории по переданному пути. os.scandir(path) возвращает итератор объектов os.DirEntry, представленные в виде записей каталога path. os.DirEntry — класс, объекты которого являются файлами или каталогами. Рассмотрим некоторые атрибуты и методы. obj.name — имя файла/каталога; obj.path — путь к файлу/каталогу, который будет начинаться с папки, переданной в пути os.scandir() первой; obj.is_dir() возвращает True, если obj является папкой, иначе — False; obj.is_file() возвращает True, если obj является файлом, иначе — False; obj.stat() возвращает объект os.stat_result (см. ниже) для obj, как если бы была вызвана os.stat(path) (см. ниже), где obj является конечным в path. os.mkdir(path) создаёт одну(!) папку, путь которой был передан в функцию. Опасность\rПри попытке создать папку, которая уже присутствует в текущем каталоге, возвращает ошибку (исключение) FileExistsError, а если путь не найден, ошибку (исключение) FileNotFoundError. В дальнейшем упоминания об этих ошибках будут зачастую опускаться, где это совсем очевидно\ros.makedirs(path, exist_ok=False) рекурсивно создаёт папки, путь которых был передан в качестве аргумента, то есть в отличии от mkdir(), функция makedirs() создаёт все папки промежуточного уровня, которые должны содержать конечный каталог. Параметр exist_ok имеет значение False по умолчанию, при котором в случае наличия одноимённой папки в рабочей директории функция вернёт ошибку FileExistsError, но если задать exist_ok=True, функция проигнорирует создание папки и не вернёт ошибку. os.rm_dir(path) удаляет папку по переданному пути, если она пуста. В ином случае вернёт ошибку, зависящую от ОС , внутри которой ведётся работа (OSError). os.removedirs(path) рекурсивно удаляет каталоги, начиная с последнего указанного в пути. Если какая-то из папок в пути окажется непустой, вызывает ошибку OSError, которая игнорируется. os.remove(path) удаляет файл в пути path. Если передана папка, или файл не существует, возвращает соответствующие ошибки. os.rename(src, dst) переименовывает файл или пустую папку с src на dst (могут быть представлены как пути), причём если указать файлу другой путь, он будет перемещён в него. os.replace(src, dst) по функционалу аналогичен os.rename(), но для поддержки кроссплатформенности рекомендуется использовать именно os.replace(). os.chown(path, uid, gid) меняет идентификатор владельца объекта по пути path на числовые uid, gid. Чтобы изменить владельца по имени пользователя/группы, обратитесь к функции shutil.chown() модуля shutil os.stat(path) возвращает объект stat_result, который содержит разного рода информацию о файле или папке. Рассмотрим атрибуты этого объекта: st_mode: Режим файла: тип файла и биты режима файла (разрешения). st_ino: Зависит от платформы, но если значение не равно нулю, однозначно идентифицирует файл по заданному значению st_dev. inode номер для Unix; индекс файла для Windows. st_dev: Идентификатор устройства, в котором находится файл. st_nlink: Количество жёстких ссылок. st_uid: Идентификатор пользователя владельца файла. st_gid: Идентификатор группы пользователей владельцев файла. st_size: Размер файла в байтах, если это обычный файл или символьная ссылка. Размер символьной ссылки - это длина пути, который она содержит, без завершающего нулевого байта. st_atime: Время последнего доступа в секундах. st_mtime: Вр","date":"12-07-2024","objectID":"/notes/os_shutil_shelve/:1:0","tags":["python","modules","os","shutil","shelve"],"title":"Модули os, shutil и shelve","uri":"/notes/os_shutil_shelve/"},{"categories":["python"],"content":"Подмодуль os.path\ros.path.split(path) разбивает переданный путь на парный кортеж (head, tail), где tail — последний компонент пути (всегда без косой черты), а head — всё остальное. При этом: если path завершился косой чертой, tail будет пуст; если в path нет ни одной косой черты, head будет пуст; если path пуст, оба элемента кортежа будут пустыми. os.path.splitext(path) разбивает переданный путь на парный кортеж (root, ext), где root + ext = path и ext — расширение файла с точкой, а root — всё остальное. os.path.dirname(path) возвращает первый элемент кортежа от функции os.path.split(), то есть путь до конечного файла/каталога не включая. os.path.basename(path) возвращает второй элемент кортежа от функции os.path.split(), то есть имя конечного файла/каталога. os.path.join(path, *paths) объединяет один или несколько сегментов пути. Возвращает строку, состоящую из объединения path и всех элементов *paths, которые разделяются os.sep, кроме последнего (если тот не пуст). import os.path os.path.join('home', 'User', 'Desktop', 'file.txt') # 'home/User/Desktop/file.txt' os.path.join('/home', 'User/Desktop', 'file.txt') # '/home/User/Desktop/file.txt' os.path.join('/home', '/User/Desktop', 'file.txt') # '/User/Desktop/file.txt' os.path.join('User/Desktop', '/home', 'file.txt') # '/home/file.txt' os.path.exists(path) возвращает True, если path ссылается на существующий путь, иначе — False. os.path.isabs(path) возвращает True, если путь является абсолютным, иначе — False. В случае отсутствия пути возвращает исключение OSError. os.path.isdir(path) возвращает True, если путь существует и является каталогом, иначе — False. os.path.isfile(path) возвращает True, если путь существует и является файлом, иначе — False. os.path.abspath(path) возвращает абсолютный путь. ","date":"12-07-2024","objectID":"/notes/os_shutil_shelve/:1:1","tags":["python","modules","os","shutil","shelve"],"title":"Модули os, shutil и shelve","uri":"/notes/os_shutil_shelve/"},{"categories":["python"],"content":"Модуль shutil\rМодуль shutil предлагает ряд высокоуровневых операций с файлами и коллекциями файлов. Например функции, которые поддерживают копирование и удаление файлов. Разберём основные возможности этого модуля. Предупреждение\rДаже функции копирования файлов более высокого уровня (shutil.copy(), shutil.copy2()) не могут скопировать все метаданные файла. Например в Windows, владельцы файлов, списки контроля доступа и альтернативные потоки данных не копируются.\rshutil.copy(src, dst) копирует файла src в файл или директорию dst, при этом оба аргумента передаются как пути. shutil.copy2(src, dst) идентична функции copy(), за исключением того, что функция copy2() также пытается сохранить метаданные файла. shutil.copyfileobj(fsrc, fdst) копирует содержимое файла src — fsrc (получается, например, при открытии файла с помощью open()) в объект файла fdst. shutil.ignore_patterns(*patterns) создаёт функцию, которая может быть использована в качестве аргумента для параметра ignore функции shutil.copytree() (см. ниже). В результате файлы и каталоги, подходящие под (хотя бы) один из переданных шаблонов будут игнорироваться при копировании. shutil.copytree(src, dst, dirs_exist_ok=False, ignore=None) рекурсивно копирует дерево каталогов из папки src в папку dst и возвращает dst. Если установить dirs_exist_ok=True, исключение вызвано НЕ БУДЕТ, если целевой каталог с именем dst уже существует. Если задано значение ignore, то это должен быть вызываемый объект, который получит в качестве своих аргументов текущий каталог, посещаемый функцией copytree(), и список его содержимого, возвращаемый функцией os.listdir(), например функция, возвращаемая shutil.ignore_patterns() или самописная функция. shutil.rmtree(path) удаляет дерево каталогов по переданному пути. shutil.copymode(src, dst) копирует права доступа с файла по пути src в файл dst. shutil.copystat(src, dst) копирует время последнего доступа, время последнего изменения и флаги(чтение, запись и т.д.) из src в dst. shutil.move(src, dst, copy_function=copy2) рекурсивно перемещает файл или директорию src в директорию dst и возвращает dst. Если место назначения dst находится в текущей файловой системе, тогда неявно используется функция os.rename(). В противном случае src копируется в dst с помощью функции, переданной в аргумент copy_function, а затем удаляется. shutil.which(path) возвращает абсолютный путь к исполняемому файлу, путь которых прописан в PATH (переменные среды) shutil.disk_usage(path) возвращает статистику использования диска по указанному пути в виде именованного кортежа с атрибутами total — общий объём диска, used — используемый объём и free — свободное пространство в байтах. shutil.chown(path, user=None, group=None) меняет владельца объекта по пути path на user и group. user может быть системным именем пользователя или uid; то же самое относится и к group. Требуется как минимум один аргумент. shutil.make_archive(name, format, root_dir) создаёт архивный файл папки/файла root_dir с именем name (может быть указан как путь) в формате format и возвращает name. shutil.unpack_archive(filename, extract_dir) распаковывает архив с именем filename в папку extract_dir. shutil.get_archive_formats() возвращает список всех поддерживаемых форматов архивов. ","date":"12-07-2024","objectID":"/notes/os_shutil_shelve/:2:0","tags":["python","modules","os","shutil","shelve"],"title":"Модули os, shutil и shelve","uri":"/notes/os_shutil_shelve/"},{"categories":["python"],"content":"Модуль shelve\rМодуль shelve сохраняет произвольные объекты Python в файл с определенным ключом (типа str), т.е. такие объекты, которые может обработать модуль pickle (большинство экземпляров классов, рекурсивных типов данных и объектов, содержащих множество общих подобъектов). Затем по этому ключу может извлечь ранее сохраненный объект из файла. В отличии от pickle, shelve более удобен, когда требуется сериализовать множество объектов. ","date":"12-07-2024","objectID":"/notes/os_shutil_shelve/:3:0","tags":["python","modules","os","shutil","shelve"],"title":"Модули os, shutil и shelve","uri":"/notes/os_shutil_shelve/"},{"categories":["python"],"content":"Функция shelve.open()\rshelve.open(filename, flag='c') возвращает объект key-value хранилища, похожий на словарь (объект называется shelf). В filename передаётся имя открываемого/создаваемого файла, flag принимает одно из следующих значений: 'c' — файл открывается для чтения и записи. Если файл отсутствует, он создаётся; 'r' — файл открывается для чтения; 'w' — файл открывается для записи; 'n' — файл открывается для для записи. Если файл отсутствует, он создаётся. Если существует, перезаписывается. Объекты shelf поддерживают большинство методов и операций, поддерживаемых словарями (за исключением копирования, конструкторов и операторов | и |=). Запись/чтение данных shelf также происходит подобно записи/чтению данных словаря. Посмотрим пример: import shelve with shelve.open('test') as db: db['func'] = func db['not_string'] = {\"this_is_not_string_LOL\": 80085} print(db['not_string']) # Вывод: {'this_is_not_string_LOL': 80085} Программа создаёт три файла разных расширений: dat, bak, dir, в которых содержится одна и та же сериализованная протоколом pickle информация. Предупреждение\rНе стоит открывать незнакомые pkl файлы и файлы, которые создаются shelve, поскольку они могут содержать самовыполняющийся код\r","date":"12-07-2024","objectID":"/notes/os_shutil_shelve/:3:1","tags":["python","modules","os","shutil","shelve"],"title":"Модули os, shutil и shelve","uri":"/notes/os_shutil_shelve/"},{"categories":["python"],"content":"Управление файлами формата zip, pkl в языке программирования Python ","date":"11-07-2024","objectID":"/notes/zip_pkl/:0:0","tags":["python","files","modules"],"title":"Работа с zip и pkl файлами в Python","uri":"/notes/zip_pkl/"},{"categories":["python"],"content":"Формат zip\rzip — это формат сжатия без потерь: после распаковки данные будут такими же, как перед сжатием. Алгоритм ищет избыточности в исходных данных и эффективнее представляет информацию. Формат zip обладает следующими преимуществами: является полностью открытым является одним из самых популярных (большинство архивов в Internet – это архивы zip) является очень быстрым Инфо\rФормат сжатия без потерь отличается от сжатия с потерями, который используется в таких форматах, как JPEG и MP3: при сжатии выбрасывается часть информации, которая менее заметна для человеческого глаза или уха.\rСначала разберёмся, как считать степень сжатия файла — коэффициент K, определяемый как отношение объема сжатого файла к объему исходного файла, выраженным в процентах: $$ K = \\frac{V_{c}} {V_{o}} * 100\\% $$ Степень сжатия зависит от используемой программы, метода сжатия и типа исходного файла. Наиболее хорошо сжимаются файлы графических образов, текстовые файлы и файлы данных, для которых степень сжатия может достигать 5–40%, меньше сжимаются файлы исполняемых программ и загрузочных модулей — 60–90%. Почти не сжимаются архивные файлы. ","date":"11-07-2024","objectID":"/notes/zip_pkl/:1:0","tags":["python","files","modules"],"title":"Работа с zip и pkl файлами в Python","uri":"/notes/zip_pkl/"},{"categories":["python"],"content":"Модуль zipfile\rВ этом конспекте будет рассмотрен объекты ZipFile и ZipInfo, однако модуль zipfile содержит и другие классы. Для использования: from zipfile import ZipFile ","date":"11-07-2024","objectID":"/notes/zip_pkl/:2:0","tags":["python","files","modules"],"title":"Работа с zip и pkl файлами в Python","uri":"/notes/zip_pkl/"},{"categories":["python"],"content":"Методы ZipFile\rprintdir() — выводит таблицу с информацией о содержимом архива: полные названия файлов с указанием даты изменения и размера в байтах. from zipfile import ZipFile with ZipFile('test.zip') as zip_file: zip_file.printdir() # Вывод: File Name Modified Size test/ 2021-11-27 12:47:10 0 test/Картинки/ 2021-11-27 12:49:02 0 test/Картинки/1.jpg 2021-09-02 12:30:20 90156 test/Картинки/avatar.png 2021-08-20 09:38:44 19053 test/Картинки/certificate.png 2021-10-23 09:46:36 43699 test/Картинки/py.png 2021-07-28 17:55:56 33522 test/Картинки/World_Time_Zones_Map.png 2021-11-08 07:30:06 2324421 test/Картинки/Снимок экрана.png 2021-10-01 20:47:02 10878 test/Неравенства.djvu 2021-08-19 08:39:06 5283010 test/Программы/ 2021-11-27 12:48:20 0 test/Программы/image_util.py 2021-11-18 12:42:22 4955 test/Программы/sort.py 2021-11-14 19:31:02 61 test/Разные файлы/ 2021-11-27 12:48:10 0 test/Разные файлы/astros.json 2021-11-08 09:29:58 505 Инфо\rПри создании объекта ZipFile мы также можем передать необязательный аргумент mode, который задает режим работы (по аналогии с обычными файлами): r — чтение, w — запись в новый файл, a — запись в конец существующего файла\rinfolist() — позволяет получить информацию о файлах из архива в виде списка объектов ZipInfo, которые содержат дополнительную информацию о каждом файле: file_size, compress_size, filename, date_time и другие. from zipfile import ZipFile with ZipFile('test.zip') as zip_file: info = zip_file.infolist() print(info[6].file_size) # размер начального файла в байтах print(info[6].compress_size) # размер сжатого файла в байтах print(info[6].filename) # имя файла print(info[6].date_time) # дата изменения файла # Вывод: 2324421 2322032 test/Картинки/World_Time_Zones_Map.png (2021, 11, 8, 7, 30, 6) Метод is_dir() объекта ZipInfo нужен, чтобы проверить, является ли этот объект файлом (возвращает False) или папкой (True). namelist() — возвращает список названий файлов и директорий, содержащихся в архиве. from zipfile import ZipFile with ZipFile('test.zip') as zip_file: info = zip_file.namelist() print(*info, sep='\\n') # Вывод: test/ test/Картинки/ test/Картинки/1.jpg test/Картинки/avatar.png test/Картинки/certificate.png test/Картинки/py.png test/Картинки/World_Time_Zones_Map.png test/Картинки/Снимок экрана.png test/Неравенства.djvu test/Программы/ test/Программы/image_util.py test/Программы/sort.py test/Разные файлы/ test/Разные файлы/astros.json getinfo() — в отличие от метода infolist(), который позволяет получить информацию о всех файлах из архива в виде списка специальных объектов (тип ZipInfo), метод getinfo() позволяет получить информацию о конкретном файле по его имени в архиве. from zipfile import ZipFile with ZipFile('test.zip') as zip_file: info = zip_file.namelist() # получаем названия всех файлов архива last_file = zip_file.getinfo(info[-4]) # получаем информацию об отдельном файле print(last_file.file_size) print(last_file.compress_size) print(last_file.filename) print(last_file.date_time) 4955 1641 test/Программы/image_util.py (2021, 11, 18, 12, 42, 22) При создании объекта ZipFile мы также можем передать еще два необязательных аргумента: compression, который определяет метод сжатия, который должен использоваться при записи в архив. Он принимает одно из значений: ZIP_STORED, ZIP_DEFLATED, ZIP_BZIP2, ZIP_LZMA. По умолчанию используется значение compression=ZIP_STORED allowZip64, который позволяет разрешить использование расширений zip64, которые дают возможность создавать архивы размером больше 4 гигабайт. По умолчанию равен allowZip64=True Для того чтобы проверить является ли некоторый файл zip архивом, используется функция zipfile.is_zipfile(), которая принимает на вход путь к файлу (или сам файловый объект) и возвращает значение True, если указанный файл является zip архивом, или False в противном случае. ","date":"11-07-2024","objectID":"/notes/zip_pkl/:2:1","tags":["python","files","modules"],"title":"Работа с zip и pkl файлами в Python","uri":"/notes/zip_pkl/"},{"categories":["python"],"content":"Работы с конкретными файлами архива\rОткроем отдельный файла из архива: from zipfile import ZipFile with ZipFile('test.zip') as zip_file: with zip_file.open('test/Разные файлы/astros.json') as file: print(file.read()) # Вывод: b'{\"number\": 10, \"people\": [{\"craft\": \"ISS\", \"name\": \"Mark Vande Hei\"}, {\"craft\": \"ISS\", \"name\": \"Pyotr Dubrov\"}, {\"craft\": \"ISS\", \"name\": \"Thomas Pesquet\"}, {\"craft\": \"ISS\", \"name\": \"Megan McArthur\"}, {\"craft\": \"ISS\", \"name\": \"Shane Kimbrough\"}, {\"craft\": \"ISS\", \"name\": \"Akihiko Hoshide\"}, {\"craft\": \"ISS\", \"name\": \"Anton Shkaplerov\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Zhai Zhigang\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Wang Yaping\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Ye Guangfu\"}], \"message\": \"success\"}' Метод ZipFile.open() открывает файл в бинарном виде, поэтому перед выводом стоит символ b, а значит перед нами бинарная строка. Чтобы преобразовать байты в строку, воспользуемся методом decode() с указанием кодировки ('utf-8'): from zipfile import ZipFile with ZipFile('test.zip') as zip_file: with zip_file.open('test/Разные файлы/astros.json') as file: print(file.read().decode('utf-8')) # Вывод: {\"number\": 10, \"people\": [{\"craft\": \"ISS\", \"name\": \"Mark Vande Hei\"}, {\"craft\": \"ISS\", \"name\": \"Pyotr Dubrov\"}, {\"craft\": \"ISS\", \"name\": \"Thomas Pesquet\"}, {\"craft\": \"ISS\", \"name\": \"Megan McArthur\"}, {\"craft\": \"ISS\", \"name\": \"Shane Kimbrough\"}, {\"craft\": \"ISS\", \"name\": \"Akihiko Hoshide\"}, {\"craft\": \"ISS\", \"name\": \"Anton Shkaplerov\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Zhai Zhigang\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Wang Yaping\"}, {\"craft\": \"Shenzhou 13\", \"name\": \"Ye Guangfu\"}], \"message\": \"success\"} ","date":"11-07-2024","objectID":"/notes/zip_pkl/:2:2","tags":["python","files","modules"],"title":"Работа с zip и pkl файлами в Python","uri":"/notes/zip_pkl/"},{"categories":["python"],"content":"Запись в архив\rЧтобы записать файл в архив, нужно как минимум открыть его для записи (mode='w' — для записи с удалением уже имеющегося содержимого; или mode='a' — для записи в конец, сохраняя содержимое). Далее, используем метод write(): from zipfile import ZipFile with ZipFile('archive.zip', mode='w') as zip_file: zip_file.write('program.py') zip_file.write('lse.jpeg') print(zip_file.namelist()) Опасность\rЕсли файлы для записи в архив не будут найдены, то возникнет ошибка (исключение) FileNotFoundError\rМетод write() может принимать еще один строковый аргумент, задающий новое имя файла в архиве. ","date":"11-07-2024","objectID":"/notes/zip_pkl/:2:3","tags":["python","files","modules"],"title":"Работа с zip и pkl файлами в Python","uri":"/notes/zip_pkl/"},{"categories":["python"],"content":"Извлечение содержимого\rЕсли требуется извлечь отдельные файлы, то используется метод extract(), он принимает два аргумента: название файла и путь, по которому требуется извлечь файл. Если путь не указывать, то файл будет извлечен в папку, где находится файл с программой. Следующий код извлекает файлы из архива test.zip from zipfile import ZipFile with ZipFile('test.zip') as zip_file: zip_file.extract('test/Картинки/avatar.png') zip_file.extract('test/Программы/image_util.py') zip_file.extract('lse.jpeg') Если требуется извлечь все содержимое архива, то используется метод extractall(), он принимает в качестве аргумента путь, по которому требуется извлечь все файлы. Если путь не указывать, то файл будет извлечен в папку, где находится файл с программой. ","date":"11-07-2024","objectID":"/notes/zip_pkl/:2:4","tags":["python","files","modules"],"title":"Работа с zip и pkl файлами в Python","uri":"/notes/zip_pkl/"},{"categories":["python"],"content":"Сериализация и десериализация\rПреобразование переменных программы (Python-объектов) в формат для хранения называется «сериализацией», а обратное преобразование — «десериализацией». Сериализация объектов часто используется для: сохранения состояния программы (то есть некоторых её объектов) между запусками передачи данных между различными программами (например, по сети) Главная идея состоит в том, что сериализованный формат — набор байт или строка, которую можно легко сохранить на диск или передать другой программе, в отличие от самого объекта. А значит, задача сохранения объекта/группы объектов при этом сводится к простой задаче сохранения набора байт или строки. ","date":"11-07-2024","objectID":"/notes/zip_pkl/:3:0","tags":["python","files","modules"],"title":"Работа с zip и pkl файлами в Python","uri":"/notes/zip_pkl/"},{"categories":["python"],"content":"Модуль pickle\rПомимо сериализации в формат json мы также можем использовать бинарную сериализацию, то есть сериализацию в байты. Для этого в Python используется модуль pickle. Интерфейс взаимодействия с модулем pickle абсолютно такой же, как и для модуля json. Мы будем использовать четыре основных функции: dump(), dumps(), load(), loads(). Инфо\rМодуль pickle сериализует и десериализует данные быстрее чем модуль json.\rМодуль pickle может сериализовывать: Все встроенные типы данных (bool, int, float, complex, str, None); Списки, кортежи, словари и множества, содержащие любую комбинацию встроенных типов данных (но не генераторы); Списки, кортежи, словари и множества, содержащие любую комбинацию списков, кортежей, словарей и множеств; Функции (но не lambda-функции), классы и экземпляры классов. Разберём функции модуля: Функция dump() модуля pickle принимает сериализуемый Python объект, сериализует его в бинарный, Python-зависимый формат, используя протокол pickle, и сохраняет его в открытый для записи бинарный файл. Следующий код создает файл file.pkl, содержащий бинарное представление объекта obj: import pickle obj = {'Python': 1991, 'Java': 1995, 'C#': 2002} with open('file.pkl', 'wb') as file: pickle.dump(obj, file) Функция dumps() выполняет такую же сериализацию, как и функция dump(). Но вместо того чтобы сохранять сериализованные данные в открытый для записи бинарный файл, она просто возвращает эти сериализованные данные. import pickle obj = {'Python': 1991, 'Java': 1995, 'C#': 2002} binary_obj = pickle.dumps(obj) print(binary_obj) print(type(binary_obj)) # Вывод: b'\\x80\\x03}q\\x00(X\\x06\\x00\\x00\\x00Pythonq\\x01M\\xc7\\x07X\\x04\\x00\\x00\\x00Javaq\\x02M\\xcb\\x07X\\x02\\x00\\x00\\x00C#q\\x03M\\xd2\\x07u.' \u003cclass 'bytes'\u003e Поскольку протокол pickle использует бинарный формат данных, функция dumps() возвращает объект типа bytes. Инфо\rТип данных bytes — это неизменяемые последовательности отдельных байтов. Синтаксис для байтовых литералов в основном такой же, как и для строковых литералов, за исключением того, что добавляется префикс b.\rФункция load() принимает файловый объект, читает из него сериализованные данные, десериализует их в Python-объект и возвращает полученный Python-объект. import pickle with open('file.pkl', 'rb') as file: # используется файл полученный на предыдущем шаге obj = pickle.load(file) print(obj) print(type(obj)) # Вывод: {'Python': 1991, 'Java': 1995, 'C#': 2002} \u003cclass 'dict'\u003e Функция loads() выполняет такую же десериализацию, как и функция load(). Но вместо того чтобы принимать файловый объект, она принимает объект типа bytes, содержащий сериализованные данные. import pickle obj = {'Python': 1991, 'Java': 1995, 'C#': 2002} binary_obj = pickle.dumps(obj) new_obj = pickle.loads(binary_obj) print(new_obj) print(obj == new_obj) print(obj is new_obj) # проверка на идентичность # Вывод: {'Python': 1991, 'Java': 1995, 'C#': 2002} True False Интересно то, что объекты obj и new_obj имеют одинаковое содержимое, но по сути не идентичны. Инфо\rПротокол pickle зависит от Python и не совместим с другими языками программирования. Если необходима совместимость с другими языками программирования, то следует использовать JSON сериализацию.\r","date":"11-07-2024","objectID":"/notes/zip_pkl/:4:0","tags":["python","files","modules"],"title":"Работа с zip и pkl файлами в Python","uri":"/notes/zip_pkl/"},{"categories":["python"],"content":"Управление текстовыми файлами формата csv, tsv, dtv, json в языке программирования Python ","date":"09-07-2024","objectID":"/notes/csv_json/:0:0","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Формат CSV\rCSV (от англ. Comma-Separated Values — значения, разделённые запятыми) — текстовый формат, предназначенный для представления табличных данных. Строка таблицы соответствует строке текста, которая содержит одно или несколько полей, разделенных запятыми. К примеру, следующая таблица: Rank Language Share 1 Python 31.17% 2 Java 17.75% 3 JavaScript 8% 4 C# 7.05% 5 PHP 6.09% в формате csv будет выглядеть следующим образом: Rank,Language,Share 1,Python,31.17% 2,Java,17.75% 3,JavaScript,8% 4,C#,7.05% 5,PHP,6.09% Подобные файлы можно обрабатывать вручную подобно txt — считывать, разделять на строки и отдельные элементы по разделителям с помощью split(), но в Python есть отдельный модуль для работы с файлами формата dsv. Инфо\rdsv (англ. delimiter separated values — «значения, разграниченные разделителем») общий формат для форм csv, tsv (англ. tab separated values — «значения, разделенные табуляцией») и других.\r","date":"09-07-2024","objectID":"/notes/csv_json/:1:0","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Модуль csv\rДля использования: import csv В данном модуле есть два основных объекта: reader и writer, созданные, чтобы читать и создавать csv файлы соответственно. ","date":"09-07-2024","objectID":"/notes/csv_json/:2:0","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Чтение через reader\rРассмотрим файл products.csv, содержащий информацию о товарах интернет магазина: keywords,price,product_name Садовый стул,1699,ВЭДДО Садовый стул,2999,ЭПЛАРО Садовый табурет,1699,ЭПЛАРО Садовый стол,1999,ТЭРНО Складной стол,7499,ЭПЛАРО Настил,1299,РУННЕН Стеллаж,1299,ХИЛЛИС Кружка,39,СТЕЛЬНА Молочник,299,ВАРДАГЕН Термос для еды,699,ЭФТЕРФРОГАД Ситечко,59,ИДЕАЛИСК Чайник заварочный,499,РИКЛИГ Кофе-пресс,699,УПХЕТТА Чашка с блюдцем,249,ИКЕА Кружка,249,ЭМНТ Ситечко,199,САККУННИГ Кружка,199,ФИНСТИЛТ Тарелка,269,ЭВЕРЕНС Код ниже читает содержимое файла и выводит его построчно: import csv with open('products.csv', encoding='utf-8') as file: rows = csv.reader(file) # создаём reader объект for row in rows: print(row) # Вывод: ['keywords', 'price', 'product_name'] ['Садовый стул', '1699', 'ВЭДДО'] ['Садовый стул', '2999', 'ЭПЛАРО'] ['Садовый табурет', '1699', 'ЭПЛАРО'] ['Садовый стол', '1999', 'ТЭРНО'] ['Складной стол', '7499', 'ЭПЛАРО'] ['Настил', '1299', 'РУННЕН'] ['Стеллаж', '1299', 'ХИЛЛИС'] ['Кружка', '39', 'СТЕЛЬНА'] ['Молочник', '299', 'ВАРДАГЕН'] ['Термос для еды', '699', 'ЭФТЕРФРОГАД'] ['Ситечко', '59', 'ИДЕАЛИСК'] ['Чайник заварочный', '499', 'РИКЛИГ'] ['Кофе-пресс', '699', 'УПХЕТТА'] ['Чашка с блюдцем', '249', 'ИКЕА'] ['Кружка', '249', 'ЭМНТ'] ['Ситечко', '199', 'САККУННИГ'] ['Кружка', '199', 'ФИНСТИЛТ'] ['Тарелка', '269', 'ЭВЕРЕНС'] Объект reader дает доступ к построчному итератору, полностью аналогичному работе с файлом или списком. После выполнения строки rows = csv.reader(file) в переменную rows будет записан итератор, с помощью которого можно «пробежаться» циклом по файлу. В каждой итерации цикла при этом будет доступна соответствующая строка файла, уже разбитая по запятым и представляющая собой список. При этом автоматически будут учтены все нюансы с запятыми внутри кавычек и самими кавычками. При создании reader объекта можно указать: аргумент delimiter — односимвольная строка, используемая для разделения полей, по умолчанию имеет значение ',' аргумент quotechar — односимвольная строка, используемая для кавычек в полях, содержащих специальные символы, по умолчанию имеет значение '\"'. ","date":"09-07-2024","objectID":"/notes/csv_json/:2:1","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Чтение через DictReader\rВ модуле csv есть специальный объект DictReader, который поддерживает создание объекта-словаря на основе названий столбцов. С помощью DictReader объекта можно обращаться к полям не по индексу, а по названию, что делает код более понятным. Немного поменяем содержимое файла products.csv. Теперь разделителем будет точка с запятой, также заключим текст с запятыми в кавычки во избежание ошибок при разделении строки на элементы: keywords;price;product_name \"Садовый стул, стул для дачи\";1699;ВЭДДО Садовый стул;2999;ЭПЛАРО Садовый табурет;1699;ЭПЛАРО Садовый стол;1999;ТЭРНО \"Складной стол, обеденный стол\";7499;ЭПЛАРО Настил;1299;РУННЕН Стеллаж;1299;ХИЛЛИС \"Кружка, сосуд, стакан с ручкой\";39;СТЕЛЬНА Молочник;299;ВАРДАГЕН Термос для еды;699;ЭФТЕРФРОГАД Ситечко;59;ИДЕАЛИСК Чайник заварочный;499;РИКЛИГ Кофе-пресс;699;УПХЕТТА Чашка с блюдцем;249;ИКЕА \"Кружка, стакан с ручкой\";249;ЭМНТ Ситечко;199;САККУННИГ Кружка;199;ФИНСТИЛТ \"Тарелка, блюдце\";269;ЭВЕРЕНС Теперь прочитаем этот файл, используя DictReader: import csv with open('products.csv', encoding='utf-8') as file: rows = csv.DictReader(file, delimiter=';', quotechar='\"') for row in rows: print(row) # Вывод: {'keywords': 'Садовый стул, стул для дачи', 'price': '1699', 'product_name': 'ВЭДДО'} {'keywords': 'Садовый стул', 'price': '2999', 'product_name': 'ЭПЛАРО'} {'keywords': 'Садовый табурет', 'price': '1699', 'product_name': 'ЭПЛАРО'} {'keywords': 'Садовый стол', 'price': '1999', 'product_name': 'ТЭРНО'} {'keywords': 'Складной стол, обеденный стол', 'price': '7499', 'product_name': 'ЭПЛАРО'} {'keywords': 'Настил', 'price': '1299', 'product_name': 'РУННЕН'} {'keywords': 'Стеллаж', 'price': '1299', 'product_name': 'ХИЛЛИС'} {'keywords': 'Кружка, сосуд, стакан с ручкой', 'price': '39', 'product_name': 'СТЕЛЬНА'} {'keywords': 'Молочник', 'price': '299', 'product_name': 'ВАРДАГЕН'} {'keywords': 'Термос для еды', 'price': '699', 'product_name': 'ЭФТЕРФРОГАД'} {'keywords': 'Ситечко', 'price': '59', 'product_name': 'ИДЕАЛИСК'} {'keywords': 'Чайник заварочный', 'price': '499', 'product_name': 'РИКЛИГ'} {'keywords': 'Кофе-пресс', 'price': '699', 'product_name': 'УПХЕТТА'} {'keywords': 'Чашка с блюдцем', 'price': '249', 'product_name': 'ИКЕА'} {'keywords': 'Кружка, стакан с ручкой', 'price': '249', 'product_name': 'ЭМНТ'} {'keywords': 'Ситечко', 'price': '199', 'product_name': 'САККУННИГ'} {'keywords': 'Кружка', 'price': '199', 'product_name': 'ФИНСТИЛТ'} {'keywords': 'Тарелка, блюдце', 'price': '269', 'product_name': 'ЭВЕРЕНС'} При создании DictReader объекта значениями по умолчанию для аргументов delimiter и quotechar являются ',' (символ запятой) и '\"' (символ двойной кавычки) соответственно. Инфо\rНазвания столбцов сохраняются в атрибуте fieldnames объекта DictReader\r","date":"09-07-2024","objectID":"/notes/csv_json/:2:2","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Запись через writer\rДля записи данных в csv файл можно использовать специальный writer объект: import csv columns = ['first_name', 'second_name', 'class_number', 'class_letter'] data = [['Тимур', 'Гуев', 11, 'А'], ['Руслан', 'Чаниев', 9, 'Б'], ['Артур', 'Харисов', 10, 'В']] with open('students.csv', 'w', encoding='utf-8', newline='') as file: writer = csv.writer(file) writer.writerow(columns) # запись заголовков for row in data: # запись строк writer.writerow(row) # Создаётся файл students.csv с содержимым: first_name,second_name,class_number,class_letter Тимур,Гуев,11,А Руслан,Чаниев,9,Б Артур,Харисов,10,В При открытии файла функцией open() был использован параметр newline со значением '' (пустая строка), который отвечает за переводы строк при чтении или записи в текстовый файл. По умолчанию имеет значение None, в этом случае все разделители строк преобразуются в '\\n'. Если в файле оказывается лишний перевод строки, то следует использовать этот параметр в режиме newline='', тогда '\\n' будет преобразован в пустую строку. При создании writer объекта так же можно его настраивать, задавая delimiter и многие другие параметры. import csv columns = ['first_name', 'second_name', 'class_number', 'class_letter'] data = [['Тимур', 'Гуев', 11, 'А'], ['Руслан', 'Чаниев', 9, 'Б'], ['Роман', 'Белых', 10, 'В']] with open('students.csv', 'w', encoding='utf-8', newline='') as file: writer = csv.writer(file, delimiter=';', quoting=csv.QUOTE_NONNUMERIC) writer.writerow(columns) for row in data: writer.writerow(row) # Создаётся файл students.csv с содержимым: \"first_name\";\"second_name\";\"class_number\";\"class_letter\" \"Тимур\";\"Гуев\";11;\"А\" \"Руслан\";\"Чаниев\";9;\"Б\" \"Роман\";\"Белых\";10;\"В\" Значение аргумента quoting=csv.QUOTE_NONNUMERIC означает, что в кавычки будут браться все нечисловые значения. По умолчанию символом кавычки является \", если нужно поменять символ, используется уже знакомый нам именованный аргумент quotechar. Для quoting существуют и другие константы из модуля csv: QUOTE_ALL: указывает объектам записи указывать все поля QUOTE_MINIMAL: указывает объектам записи заключать в кавычки только те поля, которые содержат специальные символы, такие как разделитель delimiter, кавычка quotechar или любой из символов в lineterminator QUOTE_NONNUMERIC: указывает объектам записи указывать все нечисловые поля QUOTE_NONE: указывает объектам записи никогда не заключать в кавычки поля Помимо метода writerow() можно использовать и метод writerows(), чтобы записать сразу несколько строк. Единственным аргументом этого метода может быть коллекция коллекций. То есть, каждый элемент списка rows в нашем случае должен быть коллекцией. Если rows будет, например, списком чисел, программа завершится с ошибкой. ","date":"09-07-2024","objectID":"/notes/csv_json/:2:3","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Запись через DictWriter\rДля записи данных в csv файл также можно использовать DictWriter объект, который позволяет записывать содержимое словаря в файл. import csv data = [{'first_name': 'Тимур', 'second_name': 'Гуев', 'class_number': 11, 'class_letter': 'А'}, {'first_name': 'Руслан', 'second_name': 'Чаниев', 'class_number': 9, 'class_letter': 'Б'}, {'first_name': 'Роман', 'second_name': 'Белых', 'class_number': 10, 'class_letter': 'В'}] columns = ['first_name', 'second_name', 'class_number', 'class_letter'] with open('students.csv', 'w', encoding='utf-8', newline='') as file: writer = csv.DictWriter(file, fieldnames=columns, delimiter=';', quoting=csv.QUOTE_NONNUMERIC) writer.writeheader() # запись заголовков for row in data: # запись строк writer.writerow(row) # Создаётся файл students.csv с содержимым: \"first_name\";\"second_name\";\"class_number\";\"class_letter\" \"Тимур\";\"Гуев\";11;\"А\" \"Руслан\";\"Чаниев\";9;\"Б\" \"Роман\";\"Белых\";10;\"В\" Опасность\rКлючи словарей, которые записываются в файл, должны совпадать с названиями полей, которые переданы в качестве аргумента fieldnames, иначе будет возникать ошибка ValueError.\r","date":"09-07-2024","objectID":"/notes/csv_json/:2:4","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Формат json\rJSON (англ. JavaScript Object Notation, читается как “джЕйсон”) — текстовый формат обмена данными, основанный на синтаксисе объекта в языке программирования JavaScript. Как и многие другие текстовые форматы, JSON легко читается людьми. Несмотря на происхождение от JavaScript, формат считается независимым от языка и может использоваться практически с любым языком программирования. В отличие от формата csv, данные в формате json не просто разделены запятыми, а чаще всего имеют структуру ключ-значение. Это напоминает словарь Python, но в отличие от словаря, ключи в json могут быть только строками, заключенными в двойные кавычки: { \"firstName\": \"Тимур\", \"lastName\": \"Гуев\", \"gender\": \"мужской\" } Преимущества, которые сделали этот формат популярным: не занимает много места, является компактным в написании и быстро компилируется создание текстового содержимого понятно человеку, просто в реализации, а чтение со стороны среды разработки не вызывает никаких проблем. Чтение может осуществляться и человеком, поскольку ничего сложного в представлении данных нет структура преобразуется для чтения на любых языках программирования практически все языки имеют соответствующие библиотеки или другие инструменты для чтения данных JSON В качестве значений в JSON могут быть использованы: число (целое или вещественное); литералы true (истина), false (ложь), null (отсутствие значения); строка (последовательность символов, заключенная в двойные кавычки); список (заключается в квадратные скобки [ ], значения разделяются запятыми). Список может быть пустым, значения в пределах одного списка могут иметь разный тип; вложенный объект (неупорядоченное множество пар ключ: значение, заключённое в фигурные скобки { }). Ключ описывается строкой, между ним и значением стоит символ :. Пары ключ-значение отделяются друг от друга запятыми. { \"firstName\": \"Тимур\", \"lastName\": \"Гуев\", \"age\": 29, \"gender\": \"мужской\", \"smoke\": false, \"address\": { \"streetAddress\": \"Часовая 25, кв. 127\", \"city\": \"Москва\", \"postalCode\": 125315 }, \"phoneNumbers\": [\"+7 (919) 424-84-34\", \"+7 (916) 928-92-34\"] } Инфо\rВложенность данных может быть бесконечной\rТакже, переносы строк и отступы в формате json необязательны. Они нужны только для удобства чтения. {\"firstName\": \"Тимур\", \"lastName\": \"Гуев\", \"gender\": \"мужской\"} Инфо\rJSON — это текстовый формат, который может быть представлен не только в виде пар ключ-значение (объектов). Он так же может содержать список, строку, число и т.д. Тем не менее, чаще всего используется структура ключ-значение. При этом, объекты являются неупорядоченными, списки же, наоборот, упорядочены\r","date":"09-07-2024","objectID":"/notes/csv_json/:3:0","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Модуль json\rДля использования: import json Преобразование переменных программы (Python-объектов) в формат для хранения называется «сериализацией», а обратное преобразование — «десериализацией». В Python для сериализации и десериализации в формат json есть одноимённый модуль. ","date":"09-07-2024","objectID":"/notes/csv_json/:4:0","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Функция dumps()\rДля сериализации данных в json строку используется функция dumps() из модуля json. Для того, чтобы сериализовать данные с ее помощью, достаточно передать в нее аргументом любой сериализуемый Python-объект. import json data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'} json_data = json.dumps(data) # сериализуем словарь data в json строку print(type(json_data)) print(json_data) # Вывод: \u003cclass 'str'\u003e {\"name\": \"Russia\", \"phone_code\": 7, \"capital\": \"Moscow\", \"currency\": \"RUB\"} Инфо\rНезависимо от того, какие кавычки использовались в Python-объекте, в результате данные будут в двойных кавычках (стандарт json)\r","date":"09-07-2024","objectID":"/notes/csv_json/:4:1","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Функция dump()\rВ отличие от функции dumps(), которая сериализует Python-объект в json строку, функция dump() записывает переданный Python-объект в файл. import json data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'} with open('countries.json', 'w') as file: json.dump(data, file) // Создаётся файл countries.json с содержимым: {\"name\": \"Russia\", \"phone_code\": 7, \"capital\": \"Moscow\", \"currency\": \"RUB\"} Инфо\rВозможно сериализовать любой объект, поддерживаемый форматом json, например число, список, строку и т.д\rindent, sort_keys и separators\rФункции записи dumps() и dump() имеют необязательные аргументы indent, sort_keys и separators, которые можно использовать для более удобного чтения человеком. Аргумент indent задает отступ от левого края. По умолчанию имеет значение None для более компактного представления без отступов. Если значением indent является строка, то она используется в качестве отступа. Аргумент sort_keys задает сортировку ключей в результирующем json. По умолчанию имеет значение False для более быстрого выполнения. Если установить значение аргумента в True, то ключи будут отсортированы в алфавитном порядке, что особенно удобно, когда ключей много. Аргумент separators задает кортеж, состоящий из двух элементов (item_separator, key_separator), которые представляют разделители для элементов и ключей. По умолчанию аргумент имеет значение (', ', ': '). import json data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'} json_data1 = json.dumps(data) json_data2 = json.dumps(data, indent=3, separators=(';', ' = '), sort_keys=True) print(json_data1) print(json_data2) # Вывод: {\"name\": \"Russia\", \"phone_code\": 7, \"capital\": \"Moscow\", \"currency\": \"RUB\"} { \"capital\" = \"Moscow\"; \"currency\" = \"RUB\"; \"name\" = \"Russia\"; \"phone_code\" = 7 } ","date":"09-07-2024","objectID":"/notes/csv_json/:4:2","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Функция loads()\rДля десериализации данных нужно использовать функцию loads(). Ее аргумент — это строка с данными в формате json. import json json_data = '{\"name\": \"Russia\", \"phone_code\": 7, \"capital\": \"Moscow\", \"currency\": \"RUB\"}' data = json.loads(json_data) print(type(data)) print(data) # Вывод: \u003cclass 'dict'\u003e {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'} Опасность\rВ случае если строка для десериализации содержит данные с ошибкой, то модуль json не сможет правильно прочитать такую строку, и программа завершится с ошибкой json.decoder.JSONDecodeError\r","date":"09-07-2024","objectID":"/notes/csv_json/:4:3","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Функция load()\rВ отличие от функции loads(), которая в качестве аргумента принимает строку с данными в формате json, функция load() принимает файловый объект и возвращает его десериализованное содержимое. Пусть файл data.json имеет следующее содержимое: { \"name\": \"Russia\", \"phone_code\": 7, \"capital\": \"Moscow\", \"cities\": [\"Abakan\", \"Almetyevsk\", \"Anadyr\", \"Anapa\", \"Arkhangelsk\", \"Astrakhan\"], \"currency\": \"RUB\" } Тогда следующий код преобразует data.json в словарь data и выведет его элементы: import json with open('data.json') as file: data = json.load(file) # передаем файловый объект for key, value in data.items(): if type(value) == list: print(f'{key}: {\", \".join(value)}') else: print(f'{key}: {value}') # Вывод: name: Russia phone_code: 7 capital: Moscow cities: Abakan, Almetyevsk, Anadyr, Anapa, Arkhangelsk, Astrakhan currency: RUB ","date":"09-07-2024","objectID":"/notes/csv_json/:4:4","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Типы данных в json\rМодуль json автоматически определяет тип значения при десериализации. Такая автоматическая работа с типами данных выгодно отличает json от csv, при работе с которым таких автоматических преобразований нет. Важно также понимать, что при преобразовании данных в формат JSON, данные не всегда будут того же типа, что исходные данные в Python. Например, кортежи при записи в JSON превращаются в списки. Так происходит из-за того, что в JSON используются другие типы данных, и не для всех типов данных Python есть соответствия. Таблица конвертации типов данных Python в JSON: Python JSON dict object list, tuple array str string int, float number True true False false None null Таблица конвертации JSON в типы данных Python: JSON Python object dict array list string str number (int) int number (real) float true True false False null None ","date":"09-07-2024","objectID":"/notes/csv_json/:4:5","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Ограничение по типам данных\rВ формат JSON нельзя записать словарь, у которого ключи – кортежи. Поэтому есть необязательный аргумент skipkeys, который игнорирует элементы с подобными ключами: import json data = { 'beegeek': 2018, ('Timur', 'Guev'): 29, ('Arthur', 'Kharisov'): 20, 'stepik': 2013 } json_data = json.dumps(data, skipkeys=True) # преобразуем dict в json print(json_data) # Вывод: {\"beegeek\": 2018, \"stepik\": 2013} Инфо\rВ JSON ключами словаря могут быть только строки. Но, если в словаре Python использовались числа, булевы значения или None, то ошибки не будет, вместо этого они будут преобразованы в строки.\r","date":"09-07-2024","objectID":"/notes/csv_json/:4:6","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Кириллические символы в json\rВывод следующего кода может вызвать смущение: import json data = {'firstName': 'Иван', 'lastName': 'Иванов'} s = json.dumps(data) print(s) # Вывод: {\"firstName\": \"\\u0418\\u0432\\u0430\\u043d\", \"lastName\": \"\\u0418\\u0432\\u0430\\u043d\\u043e\\u0432\"} Каждая буква из строк Иван и Иванов будет заменена на её код. Эти коды стандартны, и код для каждой из букв индивидуален. Например 0438 — код буквы и. Обратное преобразование из строки в словарь вернет закодированное значение в первоначальный вид. С помощью необязательного аргумента ensure_ascii функций dumps() и dump() можно отказаться от такого кодирования: import json data = {'firstName': 'Тимур', 'lastName': 'Гуев'} s = json.dumps(data, ensure_ascii=False) print(s) result = json.loads(s) print(result) # Вывод: {\"firstName\": \"Тимур\", \"lastName\": \"Гуев\"} {'firstName': 'Тимур', 'lastName': 'Гуев'} Python преобразует такую строку обратно в словарь без проблем (поскольку использует Unicode по умолчанию), но нужно помнить, что это может привести к проблемам с преобразованием в программах, написанных на других языках программирования. ","date":"09-07-2024","objectID":"/notes/csv_json/:4:7","tags":["python","files","modules"],"title":"Работа с csv и json файлами в Python","uri":"/notes/csv_json/"},{"categories":["python"],"content":"Кратко про потоковый ввод stdin и потоковый вывод stdout. Что это и для чего нужно, как с этим работать ","date":"03-07-2024","objectID":"/notes/stdin_stdout/:0:0","tags":["python"],"title":"Потоковый ввод и вывод","uri":"/notes/stdin_stdout/"},{"categories":["python"],"content":"Потоковый ввод\rsys.stdin – это специальный объект (итератор) в программе, куда попадает весь текст, который ввёл пользователь. Потоком его называют потому, что данные хранятся в нём до тех пор, пока программа их не прочитала. Таким образом, данные поступают в программу и временно сохраняются в потоке ввода (sys.stdin), а программа может забрать их оттуда, например, с помощью встроенной функции input(). В момент прочтения, данные пропадают из потока ввода, так как он хранит их до тех пор, пока они не будут прочитаны. Для работы с потоками необходимо подключить модуль sys: import sys. С помощью потока ввода можно в одну строчку кода прочитать весь пользовательский ввод в список. Примеры: data = [line.strip() for line in sys.stdin] или data = list(map(str.strip, sys.stdin)). Из stdin можно считать сразу все строки с помощью методов read() и readlines(). К слову, потоковый ввод тем и удобен, что не нужно беспокоиться о количестве введённых строк, ведь работать можно со всем сразу. ","date":"03-07-2024","objectID":"/notes/stdin_stdout/:1:0","tags":["python"],"title":"Потоковый ввод и вывод","uri":"/notes/stdin_stdout/"},{"categories":["python"],"content":"Потоковый вывод\rАналогичным образом можно работать с потоковым выводом (sys.stdout). По умолчанию функция print() перенаправляет вывод данных именно в sys.stdout, но всё же мы и сами можем писать в него. import sys print('Hello') sys.stdout.write('world!') print('from') sys.stdout.write('python\\n') print('Bye-bye') # Вывод: Hello world!from python Bye-bye Функция print() добавляет перевод на новую строку, а явная запись данных в sys.stdout с помощью метода write() нет. Чтобы добавить перевод на новую строку, мы используем стандартный символ \\n. Также нужно иметь в виду, что при использовании потока вывода нужно самостоятельно преобразовывать данные к строковому типу данных (функция print() это делает автоматически). ","date":"03-07-2024","objectID":"/notes/stdin_stdout/:2:0","tags":["python"],"title":"Потоковый ввод и вывод","uri":"/notes/stdin_stdout/"},{"categories":["python"],"content":"Больше модулей для работы с временем и датой, измерение времени выполнения программы ","date":"30-06-2024","objectID":"/notes/date_and_time_2/:0:0","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Модуль time\rДля использования: import time В Python помимо встроенного модуля datetime есть еще модуль time, который обычно используется для работы с текущим временем. Его работа основывается на общепринятой системе описания времени. Согласно ее концепции, текущее время представляется в виде обыкновенного вещественного значения в секундах, прошедших с момента начала эпохи (полночь 1 января 1970 года) и до сегодняшнего дня. Возможности модуля: отображает информацию о времени, прошедшем с начала эпохи преобразовывает значение системного времени в удобный вид прерывает выполнение программы на заданное количество секунд измеряет время выполнения программы или её отдельных модулей Инфо\rdatetime.time и модуль time – не одно и то же!\r","date":"30-06-2024","objectID":"/notes/date_and_time_2/:1:0","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Функция time()\rВозвращает количество секунд, прошедших с начала эпохи: import time seconds = time.time() # получаем количество прошедших секунд в виде float числа print('Количество секунд с начала эпохи =', seconds) # Вывод: Количество секунд с начала эпохи = 1630387918.354396 ","date":"30-06-2024","objectID":"/notes/date_and_time_2/:1:1","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Функция ctime()\rДля того чтобы получить текущую дату в более удобном для человека виде, нужно использовать функцию ctime(), которая принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает строку, представляющую собой локальное время: import time local_time = time.ctime(time.time()) # аналогично local_time = time.ctime() print(local_time) # Вывод: текущая дата и время на вашем пк Инфо\rЕсли вызвать ctime() без аргументов, результат будет аналогичным\r","date":"30-06-2024","objectID":"/notes/date_and_time_2/:1:2","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Функция sleep()\rИспользуется для добавления задержки в выполнение программы. В качестве аргумента принимает количество секунд (secs) – задержка в секундах. secs может быть как int, так и float import time print('Before the sleep statement') time.sleep(3) print('After the sleep statement') Инфо\rФункция sleep() нередко используется для тестирования кода и намеренного внесения задержек на различных этапах выполнения программы\r","date":"30-06-2024","objectID":"/notes/date_and_time_2/:1:3","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Измерение времени выполнения программы\rЧтобы найти время выполнения программы или её части, достаточно посчитать разницу времени в секундах между точкой старта и местом, где она завершается. Пример: import time start_time = time.time() for i in range(5): time.sleep(1) end_time = time.time() elapsed_time = end_time - start_time print(f'Время работы программы = {elapsed_time}') # Вывод: Время работы программы = 5.022884845733643 Несмотря на простоту вышеописанного подхода, использовать его в серьезных целях, где требуется точный и независимый от операционной системы (ОС) результат, не рекомендуется. Всё дело в том, что числовое значение времени, получаемое таким образом, может иметь погрешности за счет внутренних особенностей работы компьютера, в среде которого выполняется программа. Более того, системные часы могут быть подкорректированы вручную пользователем во время выполнения программы. Инфо\rБывает так, что очередной вызов функции time() вернет значение меньше, чем значение, полученное при предыдущем вызове.\r","date":"30-06-2024","objectID":"/notes/date_and_time_2/:2:0","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Функция monotonic()\rДля измерения времени выполнения программы идеально подходит функция monotonic(), так как ее результат не зависит от корректировки системных часов и других внешних условий. import time start_time = time.monotonic() for i in range(5): time.sleep(1) end_time = time.monotonic() elapsed_time = end_time - start_time print(f'Время работы программы = {elapsed_time}') # Вывод: Время работы программы = 5.0 ","date":"30-06-2024","objectID":"/notes/date_and_time_2/:2:1","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Функция perf_counter()\rДля самого точного измерения времени выполнения программы следует использовать функцию perf_counter(). Данная функция использует таймер с наибольшим доступным разрешением, что делает эту функцию отличным инструментом для измерения времени выполнения кода на коротких интервалах. import time start_time = time.perf_counter() for i in range(5): time.sleep(1) end_time = time.perf_counter() elapsed_time = end_time - start_time print(f'Время работы программы = {elapsed_time}') # Вывод: Время работы программы = 5.042140900040977 ","date":"30-06-2024","objectID":"/notes/date_and_time_2/:2:2","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Замечания\rПри сравнении разных способов выполнить одно и то же действие, было замерено время выполнения каждого. Вот некоторые интересные замечания, которые мне хотелось бы выделить: По сравнению с собственными реализациями, функция factorial() из модуля math выполняется быстрее, так как реализована на языке C. Списочные выражения (или же list comprehensions) выполняются быстрее, чем использование цикла for на пару с методом append. В случае если требуется создать список на основе итерируемого объекта или коллекции без какого-либо изменения элементов, то лучшим вариантом будет функция list(). ","date":"30-06-2024","objectID":"/notes/date_and_time_2/:2:3","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Тип данных struct_time\rЕдинственный тип данных, который имеется в модуле time – struct_time. Он представляет собой именованный кортеж, содержащий информацию о времени. Структура представления времени struct_time чем-то похожа на уже изученный тип datetime. Сделать\rИменованные кортежи будут описаны подробнее в следующих конспектах\rИменованный кортеж struct_time состоит из следующих атрибутов: Номер индекса Атрибут Значение 0 tm_year диапазон от 0000 до 9999 1 tm_mon диапазон от 1 до 12 2 tm_mday диапазон от 1 до 31 3 tm_hour диапазон от 0 до 23 4 tm_min диапазон от 0 до 59 5 tm_sec диапазон от 0 до 61 (високосная секунда) 6 tm_wday диапазон от 0 до 6, понедельник=0 7 tm_yday диапазон от 1 до 366 8 tm_isdst значения -1, 0, 1 N/A tm_zone сокращение названия часового пояса N/A tm_gmtoff смещение к востоку от UTC в секундах Создавать объекты типа struct_time можно на основе кортежа: import time time_tuple = (2021, 8, 31, 5, 31, 58, 1, 243, 0) time_obj = time.struct_time(time_tuple) На практике же редко приходится собственноручно создавать объекты этого типа. Обычно используют функции модуля time, которые сами создают и оперируют ими. Функция localtime()\rlocaltime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает кортеж struct_time в локальном времени. Инфо\rЕсли функции localtime() передан аргумент None, вернется значение time()\rimport time result = time.localtime(1630387918) print('Результат:', result) print('Год:', result.tm_year) print('Месяц:', result.tm_mon) print('День:', result.tm_mday) print('Час:', result.tm_hour) # Вывод: Результат: time.struct_time(tm_year=2021, tm_mon=8, tm_mday=31, tm_hour=8, tm_min=31, tm_sec=58, tm_wday=1, tm_yday=243, tm_isdst=0) Год: 2021 Месяц: 8 День: 31 Час: 8 Также мы могли бы обращаться к данным именованного кортежа по индексам. К примеру, print('Год:', result[0]), вывел бы ту же строку, что и print('Год:', result.tm_year) в коде выше. Функция gmtime()\rgmtime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает кортеж struct_time в UTC. Инфо\rЕсли функции gmtime() передан аргумент None, также вернется значение time()\rФункция mktime()\rmktime() принимает struct_time (или кортеж, содержащий 9 значений, относящихся к этому типу) в качестве аргумента и возвращает количество секунд, прошедших с начала эпохи, в местном времени. import time time_tuple = (2021, 8, 31, 5, 31, 58, 1, 243, 0) time_obj = time.mktime(time_tuple) print('Локальное время в секундах:', time_obj) # Вывод: Локальное время в секундах: 1630377118.0 Функция mktime() является обратной к функции localtime(). Посмотрим на пример этой связи: import time seconds = 1630377118 time_obj = time.localtime(seconds) # возвращает struct_time print(time_obj) time_seconds = time.mktime(time_obj) # возвращает секунды из struct_time print(time_seconds) # Вывод: time.struct_time(tm_year=2021, tm_mon=8, tm_mday=31, tm_hour=5, tm_min=31, tm_sec=58, tm_wday=1, tm_yday=243, tm_isdst=0) 1630377118.0 Опасность\rЕсли кортеж с неправильной длиной или имеющий элементы неправильного типа передаётся функции, ожидающей struct_time, возникает ошибка TypeError!\rФункция asctime()\rasctime() принимает struct_time (или кортеж, содержащий 9 значений, относящихся к этому типу) в качестве аргумента и возвращает строку, представляющую собой дату и время. import time time_tuple = (2021, 8, 31, 5, 31, 58, 1, 243, 0) result = time.asctime(time_tuple) print('Результат:', result) # Вывод: Результат: Tue Aug 31 05:31:58 2021 ","date":"30-06-2024","objectID":"/notes/date_and_time_2/:2:4","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Форматированный вывод\rФункции ctime() и asctime() имеют практически одинаковый функционал, за тем исключением, что первая функция принимает количество прошедших от начала эпохи секунд, а вторая принимает struct_time (или соответствующий кортеж). Обе функции представляют время в более удобном виде, благодаря автоматическому форматированию. Однако, автоматическое форматирование не всегда то, что нужно, поскольку может показаться чересчур сложным для восприятия, либо же недостаточно информативным. Именно поэтому функции strftime() и strptime() модуля time позволяют создавать свои уникальные типы форматирования. strftime() принимает строку с некоторым набором правил для форматирования и объект struct_time (или соответствующий кортеж) в качестве аргументов и возвращает строку с датой в зависимости от использованного формата: import time time_obj = time.localtime() result = time.strftime('%d.%m.%Y, %H:%M:%S', time_obj) print(result) # Вывод: 01.09.2021, 08:50:32 strptime() делает разбор строки в зависимости от использованного формата и возвращает объект struct_time: import time time_string = '1 September, 2021' result = time.strptime(time_string, '%d %B, %Y') print(result) # Вывод: time.struct_time(tm_year=2021, tm_mon=9, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=244, tm_isdst=-1) Опасность\rПри этом строка time_string должна полностью соответствовать формату %d %B, %Y, в противном случае возникнет исключение ValueError!\r","date":"30-06-2024","objectID":"/notes/date_and_time_2/:2:5","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Модуль calendar\rДля использования: import calendar По умолчанию модуль calendar следует григорианскому календарю, где понедельник является первым днём недели (номер 0), а воскресенье – последним (номер 6). В отличии от предыдущих модулей date и time, которые также предоставляют функции, связанные с календарём, модуль calendar предоставляет основные функции, связанные с отображением и манипулированием календарями. ","date":"30-06-2024","objectID":"/notes/date_and_time_2/:3:0","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Атрибуты calendar\rАтрибут calendar.day_name возвращает итерируемый объект, содержащий названия дней недели на английском языке: import calendar for name in calendar.day_name: print(name) # Вывод: Monday Tuesday Wednesday Thursday Friday Saturday Sunday Атрибут calendar.day_abbr возвращает итерируемый объект, содержащий сокращенные названия дней недели: import calendar, locale for name in calendar.day_abbr: print(name, end=' ') locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8') print() for name in calendar.day_abbr: print(name, end=' ') # Вывод: Mon Tue Wed Thu Fri Sat Sun Пн Вт Ср Чт Пт Сб Вс Атрибут calendar.month_name возвращает итерируемый объект, содержащий названия месяцев года: import calendar, locale english_names = list(calendar.month_name) print(english_names) locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8') russian_names = list(calendar.month_name) print(russian_names) # Вывод: ['', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'] ['', 'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'] Инфо\rАтрибут month_name соответствует обычному соглашению, что январь – это месяц номер 1, поэтому список имеет длину в 13 элементов, первый из которых – пустая строка\rАтрибут calendar.month_abbr возвращает итерируемый объект, содержащий сокращенные названия месяцев года: import calendar, locale english_names = list(calendar.month_abbr) print(english_names) locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8') russian_names = list(calendar.month_abbr) print(russian_names) # Вывод: ['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] ['', 'янв', 'фев', 'мар', 'апр', 'май', 'июн', 'июл', 'авг', 'сен', 'окт', 'ноя', 'дек'] Инфо\rОбъекты, доступные по атрибутам day_name, day_abbr, month_name и month_abbr, поддерживают индексацию\rДля получения номеров дней недели можно использовать атрибуты: MONDAY, TUESDAY, ..., SUNDAY. К примеру, print(calendar.MONDAY) выведет 0. ","date":"30-06-2024","objectID":"/notes/date_and_time_2/:3:1","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Функции calendar\rФункция setfirstweekday() устанавливает заданный день недели в качестве начала недели. Например, чтобы установить первый будний день воскресенье, мы используем код: import calendar calendar.setfirstweekday(calendar.SUNDAY) Функция firstweekday() возвращает целое число, означающее день недели, установленное в качестве начала недели: import calendar print(calendar.firstweekday()) calendar.setfirstweekday(calendar.SUNDAY) print(calendar.firstweekday()) # Вывод: 0 6 Функция isleap() возвращает True, если год високосен, иначе – False. Функция leapdays(y1, y2) возвращает количество високосных лет в диапазоне от y1 до y2 (не включая), где y1 и y2 – годы: import calendar print(calendar.leapdays(2020, 2025)) # Вывод: 2 Функция weekday(year, month, day) возвращает день недели в виде целого числа (где 0 – понедельник, 6 – воскресенье) для заданной даты. Аргументы функции year – год начиная с 1970, month – месяц в диапазоне 1-12, day – число в диапазоне 1-31: import calendar print(calendar.weekday(2021, 9, 1)) # среда print(calendar.weekday(2021, 9, 2)) # четверг # Вывод: 2 3 Функция monthrange(year, month) возвращает день недели первого дня месяца и количество дней в месяце в виде кортежа для указанного года year и месяца month import calendar print(calendar.monthrange(2022, 1)) # январь 2022 года print(calendar.monthrange(2021, 9)) # сентябрь 2021 года # Вывод: (5, 31) (2, 30) Функция monthcalendar(year, month) возвращает матрицу, представляющую календарь на месяц. Каждая строка матрицы представляет неделю: import calendar print(*calendar.monthcalendar(2021, 9), sep='\\n') # Вывод: [0, 0, 1, 2, 3, 4, 5] [6, 7, 8, 9, 10, 11, 12] [13, 14, 15, 16, 17, 18, 19] [20, 21, 22, 23, 24, 25, 26] [27, 28, 29, 30, 0, 0, 0] Инфо\rДни, которые не входят в указанный месяц, представлены нулями. При этом каждая неделя начинается с понедельника, если не установлено другое функцией ​​setfirstweekday()\rФункция month(year, month, w=0, l=0) возвращает календарь на месяц в многострочной строке. Аргументами функции являются: year (год), month (месяц), w (ширина столбца даты) и l (количество строк, отводимые на неделю). Инфо\rАргументы w и l имеют значения по умолчанию, поэтому их можно не передавать явно при вызове функции\rimport calendar print(calendar.month(2021, 9)) print(calendar.month(2021, 10)) print(calendar.month(2021, 9, w=3)) print(calendar.month(2021, 9, l=2)) print(calendar.month(2021, 9, w=5, l=2)) # Вывод: September 2021 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 October 2021 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 September 2021 Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 September 2021 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 September 2021 Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Функция calendar(year, w=2, l=1, c=6, m=3) возвращает календарь на весь год в виде многострочной строки. Аргументами функции являются: year (год), w (ширина столбца даты), l (количество строк, отводимые на неделю), c (количество пробелов между столбцом месяца) и m (количество столбцов). Инфо\rАргументы w, l, c, m имеют значения по умолчанию, поэтому их можно не передавать явно при вызове функции\rimport calendar print(calendar.calendar(2021)) # Вывод: 2021 January February March Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su 1 2 3 1 2 3 4 5 6 7 1 2 3 4 5 6 7 4 5 6 7 8 9 10 8 9 10 11 12 13 14 8 9 10 11 12 13 14 11 12 13 14 15 16 17 15 16 17 18 19 20 21 15 16 17 18 19 20 21 18 19 20 21 22 23 24 22 23 24 25 26 27 28 22 23 24 25 26 27 28 25 26 27 28 29 30 31 29 30 31 April May June Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su 1 2 3 4 1 2 1 2 3 4 5 6 5 6 7 8 9 10 11 3 4 5 6 7 8 9 7 8 9 10 11 12 13 12 13 14 15 16 17 1","date":"30-06-2024","objectID":"/notes/date_and_time_2/:3:2","tags":["python","time","calendar","modules","datatypes"],"title":"Работа с датой и временем. Часть II","uri":"/notes/date_and_time_2/"},{"categories":["python"],"content":"Модули и типы данных для работы со временем, датой и временными промежутками в языке программирования Python. Локализация ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:0:0","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Типы данных date и time\rДля удобной работы с датой и временем в Python есть модуль datetime. Он состоит из нескольких типов данных. Благодаря их наличию, программист получает доступ ко многим полезным функциям: получение текущих системных даты и времени; вычисление разницы между датами и другие арифметические операции над ними; сравнение даты и времени; форматированный вывод информации о дате и времени. ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:1:0","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Типы данных модуля datetime\rНазвание типа данных Характеристика date Представляет собой информацию о дате на основе Григорианского календаря time Представляет собой информацию о времени datetime Содержит информацию о времени и дате на основе Григорианского календаря timedelta Описывает определённый период во времени, который находится между двумя различными моментами tzinfo Представляет различные сведения о часовом поясе timezone Содержит информацию о времени в формате UTC ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:1:1","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Тип данных date\rДля использования: from datetime import date. Тип данных (класс) date используется для представления данных о дате и включает информацию о годе, месяце и дне. При создании новой даты нужно указать год, месяц и день. При этом, как и положено, нельзя указать значение day большее 31 и/или значение month большее 12: from datetime import date my_date = date(1992, 10, 6) # тип date: год + месяц + день print(my_date) print(type(my_date)) # Вывод: 1992-10-06 \u003cclass 'datetime.date'\u003e Получить доступ к отдельным составляющим даты можно с помощью атрибутов year, month, day: from datetime import date my_date = date(1992, 10, 6) print('Год =', my_date.year) print('Месяц =', my_date.month) print('День =', my_date.day) # Вывод: Год = 1992 Месяц = 10 День = 6 Метод today() нужен, чтобы получить текущую дату с компьютера: today_date = date.today() С помощью метода weekday() можно определить день недели (нумерация начинается с нуля: 0=понедельник, 1=вторник, …, 6=воскресенье). Если нужна нумерация с единицы, можно воспользоваться методом isoweekday(). Атрибуты min и max используются, чтобы получить минимальную и максимальную соответственно возможную дату (в рамках типа данных date): from datetime import date print(date.min) print(date.max) # Вывод: 0001-01-01 9999-12-31 Метод fromordinal() позволяет создать дату из номера дня, начиная с 0001-01-01, а метод toordinal(), наоборот, преобразует дату в номер дня: from datetime import date date1 = date.fromordinal(365) date2 = date(1999, 12, 26) print(date1) print(date2.toordinal()) # Вывод: 0001-12-31 730114 ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:1:2","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Тип данных time\rДля использования: from datetime import time Тип данных (класс) time используется для представления данных о времени и включает информацию о часах, минутах, секундах и микросекундах (одна миллионная доля секунды). При создании времени нужно указать часы, минуты, секунды и микросекунды. При этом, значение hour не может быть больше 23, а значение second больше 59: from datetime import time my_time = time(11, 20, 54, 1234) # тип time: часы + минуты + секунды + микросекунды print(my_time) print(type(my_time)) # Вывод: 11:20:54.001234 \u003cclass 'datetime.time'\u003e В отличие от дат (тип данных date), чтобы создать объект типа time, необязательно указывать все его атрибуты в конструкторе. Недостающие данные о времени автоматически заполняются нулями. Так же, как и при работе с типом данных date, пользуясь типом time, можно получать доступ к отдельным значениям созданного времени: часам, минутам, секундам и микросекундам с помощью атрибутов hour, minute, second, microsecond: from datetime import time my_time = time(11, 20, 54, 1234) print('Часы =', my_time.hour) print('Минуты =', my_time.minute) print('Секунды =', my_time.second) print('Микросекунды =', my_time.microsecond) # Вывод: Часы = 11 Минуты = 20 Секунды = 54 Микросекунды = 1234 Опасность\rВ случае использования неверного значения для атрибутов (year, month, day и т.д.) возникает ошибка (исключение) ValueError.\r","date":"16-06-2024","objectID":"/notes/date_and_time_1/:1:3","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Связь дат и времени\rdate и time можно сравнивать с помощью операторов ==, !=, \u003c, \u003e, \u003c= и \u003e=: from datetime import date, time date1 = date(2022, 10, 15) date2 = date(1999, 12, 26) time1 = time(13, 10, 5) time2 = time(21, 32, 59) print(date1 \u003c date2) print(time1 \u003c time2) # Вывод: False True При работе с этими типами данных можно использовать встроенные функции min(), max() и sorted(): from datetime import date dates = [date(2021, 12, 31), date(2025, 3, 19), date(2017, 5, 25)] print(min(dates)) print(max(dates)) print(sorted(dates)) # Вывод: 2017-05-25 2025-03-19 [datetime.date(2017, 5, 25), datetime.date(2021, 12, 31), datetime.date(2025, 3, 19)] Инфо\rОба типа данных date и time являются неизменяемыми\r","date":"16-06-2024","objectID":"/notes/date_and_time_1/:1:4","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Функции str() и repr()\rВстроенная функция str() возвращает объект в неформальном (понятном человеку) строковом представлении. В следующем коде str() вызывается неявно и преобразует указанные объекты в понятный нам вид: from datetime import date, time my_date = date(2021, 12, 31) my_time = time(11, 20, 54) print(str(my_date)) # Аналогичен коду print(my_date) print(str(my_time)) # Аналогичен коду print(my_time) # Вывод: 2021-12-31 11:20:54 Встроенная функция repr() возвращает объект в формальном (понятном интерпретатору) строковом представлении: print(repr(my_date)) print(repr(my_time)) # Вывод: datetime.date(2021, 12, 31) datetime.time(11, 20, 54) Для встроенных типов данных при печати одиночного значения объекта явно вызывать функцию str() не требуется, однако при печати списка таких объектов может произойти следующее: from datetime import date dates = [date(2021, 12, 31), date(2019, 10, 6), date(2022, 11, 8)] # список дат print(dates) # Вывод: [datetime.date(2021, 12, 31), datetime.date(2019, 10, 6), datetime.date(2022, 11, 8)] Поэтому, если нам нужно вывести дату или время в нормальном виде, нужно воспользоваться распаковкой (str() также будет вызвана неявно): print(*dates, sep=', ') # Вывод: 2021-12-31, 2019-10-06, 2022-11-08 ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:1:5","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Форматирование даты и времени\rПо умолчанию вывод даты и времени осуществляется в ISO формате: дата имеет вид: YYYY-MM-DD время имеет вид: HH:MM:SS или HH:MM:SS.ffffff Для форматированного вывода даты и времени используется метод strftime() (для обоих типов date и time): from datetime import date, time my_date = date(2021, 8, 10) my_time = time(7, 18, 34) print(my_date) # вывод в ISO формате print(my_time) # вывод в ISO формате print(my_date.strftime('%d/%m/%y')) # форматированный вывод даты print(my_date.strftime('%A %d, %B %Y')) # форматированный вывод даты print(my_time.strftime('%H.%M.%S')) # форматированный вывод времени # Вывод: 2021-08-10 07:18:34 10/08/21 Tuesday 10, August 2021 07.18.34 Таблица аргументов параметра: Формат Значение Пример %a Сокращённое название дня недели Sun, Mon, …, Sat (en_US) Пн, Вт, …, Вс (ru_RU) %A Полное название дня недели Sunday, Monday, …, Saturday (en_US) понедельник, …, воскресенье (ru_RU) %w Номер дня недели [0, …, 6] 0, 1, …, 6 (0=воскресенье, 6=суббота) %d День месяца [01, …, 31] 01, 02, …, 31 %b Сокращенное название месяца Jan, Feb, …, Dec (en_US); янв, …, дек (ru_RU) %B Полное название месяца January, February, …, December (en_US); Январь, …, Декабрь (ru_RU) %m Номер месяца [01, …,12] 01, 02, …, 12 %y Год без века [00, …, 99] 00, 01, …, 99 %Y Год с веком 0001, 0002, …, 2013, 2014, …, 9999 В Linux год выводится без ведущих нулей: 1, 2, …, 2013, 2014, …, 9999 %H Час (24-часовой формат) [00, …, 23] 00, 01, …, 23 %I Час (12-часовой формат) [01, …, 12] 01, 02, …, 12 %p До полудня или после (при 12-часовом формате) AM, PM (en_US) %M Число минут [00, …, 59] 00, 01, …, 59 %S Число секунд [00, …, 59] 00, 01, …, 59 %f Число микросекунд 000000, 000001, …, 999999 %z Разница с UTC в формате ±HHMM[SS[.ffffff]] +0000, -0400, +1030, +063415, … %Z Временная зона UTC, EST, CST %j День года [001,366] 001, 002, …, 366 %U Номер недели в году (неделя начинается с воскр.). Неделя, предшествующая первому воскресенью, является нулевой. [00, …, 53] 00, 01, …, 53 %W Номер недели в году (неделя начинается с пон.). Неделя, предшествующая первому понедельнику, является нулевой. [00, …, 53] 00, 01, …, 53 %c Дата и время Tue Aug 16 21:30:00 1988 (en_US); 03.01.2019 23:18:32 (ru_RU) %x Дата 08/16/88 (None); 08/16/1988 (en_US); 03.01.2019 (ru_RU) %X Время 21:30:00 При форматировании даты все временные характеристики сбрасываются в минимально возможные (нулевые значения). Аналогично при форматировании времени все характеристики даты сбрасываются в минимально возможные: from datetime import date, time my_date = date(2021, 8, 10) my_time = time(7, 18, 34) print(my_date.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X')) print(my_time.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X')) # Вывод: Tue Tuesday 2 10 Aug August 08 21 2021 00 12 AM 00 00 000000 222 32 32 Tue Aug 10 00:00:00 2021 08/10/21 00:00:00 Mon Monday 1 01 Jan January 01 00 1900 07 07 AM 18 34 000000 001 00 01 Mon Jan 1 07:18:34 1900 01/01/00 07:18:34 Для создания новой даты на основе уже существующей можно использовать метод replace(). Он возвращает новую дату с переданными изменёнными значениями атрибутов year, month, day: from datetime import date date1 = date(1992, 10, 6) date2 = date1.replace(year=1995) # заменяем год date3 = date1.replace(month=12, day=17) # заменяем месяц и число print(date1) print(date2) print(date3) # Вывод: 1992-10-06 1995-10-06 1992-12-17 Инфо\rАналогичным способом можно создать и новое время на основе существующего.\rДля того, чтобы получить строковое представление объектов типа date и time в ISO формате, можно воспользоваться методом isoformat(): from datetime import date, time my_date = date(2021, 12, 31) my_time = time(21, 15, 17) print('Дата: ' + my_date.isoformat()) # Аналогично коду print('Дата: ' + str(my_date)) print('Время: ' + my_time.isoformat()) # Аналогично коду print('Дата: ' + str(my_time)) # Вывод: Дата: 2021-12-31 Время: 21:15:17 А чтобы преобразовать ст","date":"16-06-2024","objectID":"/notes/date_and_time_1/:1:6","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Использование локализации\rДля использования: import locale Приведённый ниже код устанавливает русскую локализацию: from datetime import date import locale locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8') my_date = date(2021, 8, 10) print(my_date.strftime(\"%A %d, %B %Y\")) # форматированный вывод даты в русской локализации # Вывод: вторник 10, Август 2021 ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:1:7","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Тип данных datetime\rДля использования: from datetime import datetime Этот тип данных позволяет работать одновременно и с датой, и с временем. Он является неизменяемым. При создании новой даты-времени (тип datetime) нужно указать год, месяц, день, часы, минуты, секунды и микросекунды. При этом год, месяц и день являются обязательными, а часы, минуты, секунды и микросекунды необязательными: from datetime import datetime my_datetime = datetime(1992, 10, 6, 9, 40, 23, 51204) # создаем полную дату-время only_date = datetime(2021, 12, 31) # создаем дату-время с нулевой временной информацией print(my_datetime) print(only_date) print(type(my_datetime)) # Вывод: 1992-10-06 09:40:23.051204 2021-12-31 00:00:00 \u003cclass 'datetime.datetime'\u003e Так же, как и при работе с типами date и time, в datetime с помощью атрибутов (year, month, day, hour, minute, second и microsecond) можно получать доступ к отдельным значениям созданной даты-времени: годам, месяцам, дням, часам, минутам, секундам и микросекундам: from datetime import datetime my_datetime = datetime(1992, 10, 6, 9, 40, 23, 51204) print('Год =', my_datetime.year) print('Месяц =', my_datetime.month) print('День =', my_datetime.day) print('Часы =', my_datetime.hour) print('Минуты =', my_datetime.minute) print('Секунды =', my_datetime.second) print('Микросекунды =', my_datetime.microsecond) # Вывод: Год = 1992 Месяц = 10 День = 6 Часы = 9 Минуты = 40 Секунды = 23 Микросекунды = 51204 Инфо\rТип данных datetime наследует весь функционал (атрибуты и методы) от типа date\r","date":"16-06-2024","objectID":"/notes/date_and_time_1/:2:0","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Методы datetime\rСформировать новый объект типа datetime можно с помощью двух разных объектов, представляющих дату и время (date и time). Для этого используется метод combine(): from datetime import date, time, datetime my_date = date(1992, 10, 6) my_time = time(10, 45, 17) my_datetime = datetime.combine(my_date, my_time) print(my_datetime) # Вывод: 1992-10-06 10:45:17 Если же, наоборот, нужно из datetime получить date и time, то используются методы date() и time() соответственно: from datetime import datetime my_datetime = datetime(2022, 10, 7, 14, 15, 45) my_date = my_datetime.date() # получаем только дату (тип date) my_time = my_datetime.time() # получаем только время (тип time) print(my_datetime, type(my_datetime)) print(my_date, type(my_date)) print(my_time, type(my_time)) Метод now() используется для получения локального времени: from datetime import datetime print(datetime.now()) print(datetime.utcnow()) При этом, если нужно отобразить код определённого часового пояса, рекомендуется использовать код: import datetime as dt print(dt.datetime.now(dt.timezone.utc)) Метод today() аналогичен методу now(), но рекомендуется использовать именно метод now(). Метод timestamp() преобразует объект типа datetime в количество секунд, прошедших с начала эпохи (возвращает значение типа float), а метод fromtimestamp(), наоборот, преобразует количество секунд, прошедших с начала эпохи, в datetime (возвращает объект datetime в локальном часовом поясе). При работе с объектами типа datetime мы также можем использовать функции min(), max(), sorted() и операторы сравнения. Если нужно создать новый объект datetime на основании уже существующего, можно использовать метод replace(), который вернёт новый объект datetime с переданными изменёнными значениями атрибутов: from datetime import datetime datetime1 = datetime(1992, 10, 6, 10, 12, 45) datetime2 = datetime1.replace(year=1995, month=12) datetime3 = datetime1.replace(day=17, hour=14, minute=37) print(datetime1) print(datetime2) print(datetime3) # Вывод: 1992-10-06 10:12:45 1995-12-06 10:12:45 1992-10-17 14:37:45 ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:2:1","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Форматирование datetime\rКак и объекты типа date и time, datetime выводится в формате ISO 8601. Для преобразования в строку нужного формата нужно использовать старый-добрый метод strftime(): from datetime import datetime my_datetime = datetime(2021, 8, 10, 18, 20, 34) print(my_datetime) # вывод в ISO формате print(my_datetime.strftime('%d.%m.%y --- %H::%M::%S')) print(my_datetime.strftime('%d/%m/%y')) print(my_datetime.strftime('%A %d, %B %Y')) print(my_datetime.strftime('%H:%M:%S')) # Вывод: 2021-08-10 18:20:34 10.08.21 --- 18::20::34 10/08/21 Tuesday 10, August 2021 18:20:34 Аргументы, которые можно передать в strftime() уже были приведены в виде таблицы в параграфе “Форматирование даты и времени”. Если нужно получить представление даты-времени в ISO формате, можно воспользоваться методом isoformat() или функцией str(): from datetime import datetime my_datetime = datetime(1992, 10, 6, 10, 12, 45) print(my_datetime.isoformat()) print(str(my_datetime)) # Вывод: 1992-10-06T10:12:45 1992-10-06 10:12:45 ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:2:2","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Преобразование строки в datetime\rПреобразовать строку в объект типа datetime можно: Вручную, используя split(); С помощью метода strptime(). Второй способ компактнее и читабельнее, поэтому поощряется в большей степени. Метод strptime() принимает два аргумента: первый – строку, второй – формат Инфо\rstrptime() – это парсер, который превращает произвольную строку в объект типа datetime strftime() – это форматтер, который превращает объект datetime в строку заданного формата\rfrom datetime import datetime datetime0 = datetime.strptime('10.08.2034 13:55:59', '%d.%m.%Y %H:%M:%S') datetime1 = datetime.strptime('10/08/21', '%d/%m/%y') datetime2 = datetime.strptime('Tuesday 10, August 2021', '%A %d, %B %Y') datetime3 = datetime.strptime('18.20.34', '%H.%M.%S') datetime4 = datetime.strptime('2021/08/10', '%Y/%m/%d') datetime5 = datetime.strptime('10.08.2021 (Tuesday, August)', '%d.%m.%Y (%A, %B)') datetime6 = datetime.strptime('Year: 2021, Month: 08, Day: 10, Hour: 18.', 'Year: %Y, Month: %m, Day: %d, Hour: %H.') print(datetime0, datetime1, datetime2, datetime3, datetime4, datetime5, datetime6, sep='\\n') print(my_datetime) # Вывод: 2034-08-10 13:55:59 2021-08-10 00:00:00 2021-08-10 00:00:00 1900-01-01 18:20:34 2021-08-10 00:00:00 2021-08-10 00:00:00 2021-08-10 18:00:00 Опасность\rПервый аргумент должен соответствовать формату второго аргумента. Иначе возникнет исключение ValueError\rfrom datetime import datetime my_datetime = datetime.strptime('10/08/2034 13:55:59', '%d.%m.%Y %H:%M:%S') print(my_datetime) # Вывод: ValueError: time data '10/08/2034 13:55:59' does not match format '%d.%m.%Y %H:%M:%S' Инфо\rПри создании объекта datetime из строки с помощью метода strptime() необязательно, чтобы строка содержала год, месяц и день, в отличие от ручного создания этого объекта\r","date":"16-06-2024","objectID":"/notes/date_and_time_1/:2:3","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Тип данных timedelta\rТип данных timedelta представляет собой временной интервал (разница между двумя объектами datetime или date) и используется для удобного выполнения различных манипуляций над типами datetime или date. Он, как и предыдущие, неизменяем. При создании объекта timedelta можно указать следующие аргументы: недели (weeks), дни (days), часы (hours), минуты (minutes), секунды (seconds), миллисекунды (milliseconds), микросекунды (microseconds). Все они являются необязательными и по умолчанию равны нулю. from datetime import timedelta delta = timedelta(days=7, hours=20, minutes=7, seconds=17) print(delta) print(type(delta)) # Вывод: 7 days, 20:07:17 \u003cclass 'datetime.timedelta'\u003e Инфо\rАргументы могут быть целыми числами или же числами с плавающей точкой, кроме того они могут быть отрицательными\rtimedelta хранит только days, seconds, microseconds, в то время как остальные переданные аргументы сводятся к ним по следующим правилам: milliseconds преобразуется в 1000 microseconds minutes в 60 seconds hours в 3600 seconds weeks в 7 days Сами атрибуты days, seconds и microseconds имеют ограничения и нормализуются так, чтобы представление было уникальным: 0 \u003c= microseconds \u003c 1000000 0 \u003c= seconds \u003c 3600*24 (количество секунд в одном дне) -999999999 \u003c= days \u003c= 999999999 Пример: from datetime import timedelta delta1 = timedelta(days=50, seconds=27, microseconds=10, milliseconds=29000, minutes=5, hours=8, weeks=2) delta2 = timedelta(weeks=1, hours=23, minutes=61) delta3 = timedelta(hours=25) delta4 = timedelta(minutes=300) print(delta1, delta2, delta3, delta4, sep='\\n') # Вывод: 64 days, 8:05:56.000010 8 days, 0:01:00 1 day, 1:00:00 5:00:00 Также timedelta может представлять собой отрицательный временной интервал: from datetime import timedelta delta1 = timedelta(minutes=-40) delta2 = timedelta(seconds=-10, weeks=-2) print(delta1) print(delta2) # Вывод: -1 day, 23:20:00 -15 days, 23:59:50 В первом случае, если мы сложим -1 день с временем 23:20, то как раз получим введённые -40 минут. Аналогично и со вторым примером. Инфо\rОбъект timedelta не хранит отрицательное число секунд и микросекунд, но может хранить отрицательное количество дней\rЕсли нужно получить из отрицательного значения timedelta положительное, можно использовать встроенную функцию abs(): from datetime import timedelta delta = timedelta(days=-2, minutes=-300) abs_delta = abs(delta) print('Исходная:', delta.days, delta.seconds, delta, sep='\\n') print('С модулем:', abs_delta.days, abs_delta.seconds, abs_delta, sep='\\n') # Вывод: Исходная: -3 68400 -3 days, 19:00:00 С модулем: 2 18000 2 days, 5:00:00 Для преобразования timedelta к строковому типу можно использовать встроенные функции str() и repr() (первая вызывается автоматически при печати значения объекта этого типа): from datetime import timedelta delta1 = timedelta(weeks=1, hours=23, minutes=61) delta2 = timedelta(minutes=-300) print(str(delta1), str(delta2), sep='\\n') print(repr(delta1), repr(delta2), sep='\\n') 8 days, 0:01:00 -1 day, 19:00:00 datetime.timedelta(days=8, seconds=60) datetime.timedelta(days=-1, seconds=68400) ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:3:0","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Метод total_seconds()\rtotal_seconds() возвращает общее количество секунд, содержащееся во временном интервале timedelta У типа timedelta нет атрибутов hours, minutes и week, поэтому, чтобы получить, к примеру, часы и минуты, можно воспользоваться следующим кодом: def hours_minutes(td): return td.seconds // 3600, (td.seconds // 60) % 60 ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:3:1","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Сравнение временных интервалов\rОбъекты типа timedelta можно сравнивать между собой, как и любые другие. Опасность\rНо если временной интервал сравнивается с другим типом данных операторами \u003c, \u003e, \u003c=, \u003e=, возникает ошибка (исключение) TypeError.\r","date":"16-06-2024","objectID":"/notes/date_and_time_1/:3:2","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Операции с timedelta\rСложение и разность временных интервалов: from datetime import timedelta delta1 = timedelta(days=5) + timedelta(seconds=3600) # 5 дней + 1 час delta2 = timedelta(days=5) - timedelta(seconds=3600) # 5 дней - 1 час print(delta1) print(delta2) # Вывод: 5 days, 1:00:00 4 days, 23:00:00 Умножение интервала на число: from datetime import timedelta delta1 = 48 * timedelta(hours=1) delta2 = timedelta(weeks=1) * (3/7) print(delta1) print(delta2) 2 days, 0:00:00 3 days, 0:00:00 Инфо\rПри умножении интервала на float число может произойти округление!\rДеление интервала на число from datetime import timedelta delta = timedelta(hours=1, minutes=6) delta1 = delta / 2 delta2 = delta // 5 print(delta1) print(delta2) # Вывод: 0:33:00 0:13:12 Деление временных интервалов друг на друга. По сути общая длительность первого интервала делится на общую длительность второго (которые вычисляются методом total_seconds()): from datetime import timedelta delta1 = timedelta(weeks=1) / timedelta(hours=5) # обычное деление, результат float delta2 = timedelta(weeks=1) // timedelta(hours=5) # целочисленное деление, результат int print(delta1) print(delta2) # Вывод: 33.6 33 Также можно найти остаток от деления двух интервалов, при этом вернётся объект timedelta: from datetime import timedelta delta1 = timedelta(weeks=1) % timedelta(hours=5) # 3 часа delta2 = timedelta(hours=1) % timedelta(minutes=7) # 4 минуты print(delta1) print(delta2) # Вывод: 3:00:00 0:04:00 ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:3:3","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":["python"],"content":"Операции с datetime и date\rК объектам типа datetime и date можно прибавлять (вычитать) временные интервалы, формируя новые объекты тех же типов данных: from datetime import datetime, date, timedelta my_datetime1 = datetime(2021, 1, 1, 12, 15, 20) + timedelta(weeks=1, hours=25) my_datetime2 = datetime(2021, 1, 1, 12, 15, 20) - timedelta(weeks=1, hours=25) my_date1 = date(2021, 1, 1) + timedelta(hours=49) my_date2 = date(2021, 1, 1) - timedelta(hours=49) print(my_datetime1, my_datetime2, my_date1, my_date2, sep='\\n') # Вывод: 2021-01-09 13:15:20 2020-12-24 11:15:20 2021-01-03 2020-12-30 Инфо\rПри прибавлении timedelta к data неполные сутки отбрасываются\rПри вычитании объектов date или datetime получается объект timedelta: from datetime import datetime, date, timedelta delta1 = datetime(2021, 1, 1, 12, 15, 20) - datetime(2020, 5, 1, 10, 5, 10) delta2 = date(2020, 2, 29) - date(2019, 9, 1) delta3 = date(2019, 9, 1) - date(2020, 2, 29) print(type(delta1)) print(type(delta2)) print(type(delta3)) # Вывод: \u003cclass 'datetime.timedelta'\u003e \u003cclass 'datetime.timedelta'\u003e \u003cclass 'datetime.timedelta'\u003e ","date":"16-06-2024","objectID":"/notes/date_and_time_1/:3:4","tags":["python","datetime","date","modules","datatypes"],"title":"Работа с датой и временем. Часть I","uri":"/notes/date_and_time_1/"},{"categories":null,"content":" Всё о парадигмах программирования: особенности, механизмы, какие языки поддерживают и т.д. ","date":"25-05-2024","objectID":"/notes/programming_paradigms/:0:0","tags":["paradigms"],"title":"Парадигмы программирования","uri":"/notes/programming_paradigms/"},{"categories":null,"content":"Императивное программирование\rВычислительная техника создавалась для решения математических задач – расчета баллистических траекторий, численного решения уравнений и т.д. Для этого же предназначены первые языки программирования, такие как Fortran, Алгол, реализованные в парадигме императивного программирования. Характеристики: в исходном коде программы записаны инструкции (команды); инструкции должны выполняться последовательно; данные, полученные при выполнении инструкции, могут записываться в память; данные, получаемые при выполнении предыдущих инструкций, могут читаться из памяти последующими инструкциями. Основные механизмы управления: последовательное исполнение команд; использование именованных переменных; использование оператора присваивания; использование ветвления (оператор if); использование безусловного перехода (оператор goto). Ключевой идеей императивного программирования является работа с переменными, как с временным хранением данных в оперативной памяти. ","date":"25-05-2024","objectID":"/notes/programming_paradigms/:0:1","tags":["paradigms"],"title":"Парадигмы программирования","uri":"/notes/programming_paradigms/"},{"categories":null,"content":"Структурное программирование\rСтрук­тур­ная парадигма программирования на­це­ле­на на со­кра­ще­ние вре­ме­ни раз­ра­бот­ки и уп­ро­ще­ние поддержки про­грамм за счёт ис­поль­зо­ва­ния блочных опе­ра­то­ров и под­про­грамм. От­ли­чительная чер­та струк­тур­ных про­грамм – от­каз от опе­ра­то­ра безусловного пе­ре­хо­да (goto), который широко использовался в 1970-х годах. Основные механизмы управления: последовательное исполнение команд; использование именованных переменных; использование оператора присваивания; использование ветвления (оператор if); использование циклов; использование подпрограмм (функций). Инфо\rПарадигму структурного программирования предложил нидерландский ученый Эдсгер Дейкстра.\r","date":"25-05-2024","objectID":"/notes/programming_paradigms/:0:2","tags":["paradigms"],"title":"Парадигмы программирования","uri":"/notes/programming_paradigms/"},{"categories":null,"content":"Объектно-ориентированное программирование\rВ объектно-ориентированной парадигме программа раз­би­ва­ет­ся на объ­ек­ты – структуры дан­ных, со­стоя­щие из по­лей, опи­сы­ваю­щих со­стоя­ние, и ме­то­дов – функций, при­ме­няе­мых к объ­ек­там для изменения или за­про­са их со­стоя­ния. Объ­ект­но-ори­ен­ти­ро­ван­ную парадигму программирования под­дер­жи­ваю­т: Python; C#; Java; C++; JavaScript; и другие. Основные механизмы управления: абстракция; класс; объект; полиморфизм; инкапсуляция; наследование. ","date":"25-05-2024","objectID":"/notes/programming_paradigms/:0:3","tags":["paradigms"],"title":"Парадигмы программирования","uri":"/notes/programming_paradigms/"},{"categories":null,"content":"Декларативное программирование\rДекларативное программирование – парадигма программирования, в которой задаётся спецификация решения задачи, то есть описывается ожидаемый результат, а не способ его получения. Противоположностью декларативного является императивное программирование, при котором на том или ином уровне детализации требуется описание последовательности шагов для решения задачи. В качестве примеров декларативных языков обычно приводят HTML и SQL. При создании HTML с помощью тегов описывается, какую нужно получить страничку в браузере, а не то, как нарисовать на экране заголовок статьи, оглавление и текст. К подвидам декларативного программирования также зачастую относят функциональное и логическое программирование. Несмотря на то, что программы на таких языках нередко содержат алгоритмические составляющие, архитектура в императивном понимании (как нечто отдельное от кодирования) в них также отсутствует: схема программы является непосредственно частью исполняемого кода. ","date":"25-05-2024","objectID":"/notes/programming_paradigms/:0:4","tags":["paradigms"],"title":"Парадигмы программирования","uri":"/notes/programming_paradigms/"},{"categories":null,"content":"Логическое программирование\rПри использовании логического программирования программа содержит описание проблемы в терминах фактов и логических формул, а решение проблемы система находит с помощью механизмов логического вывода. В конце 60-х годов XX века Корделл Грин предложил использовать резолюцию как основу логического программирования. Алан Колмеро создал язык логического программирования Prolog в 1971 году. Логическое программирование пережило пик популярности в середине 80-х годов XX века, когда было положено в основу проекта разработки программного и аппаратного обеспечения вычислительных систем пятого поколения. Важное его преимущество – достаточно высокий уровень машинной независимости, а также возможность откатов, возвращения к предыдущей подцели при отрицательном результате анализа одного из вариантов в процессе поиска решения. Один из концептуальных недостатков логического подхода – специфичность класса решаемых задач. Недостаток практического характера – сложность эффективной реализации для принятия решений в реальном времени, скажем, для систем жизнеобеспечения. ","date":"25-05-2024","objectID":"/notes/programming_paradigms/:0:5","tags":["paradigms"],"title":"Парадигмы программирования","uri":"/notes/programming_paradigms/"},{"categories":null,"content":"Функциональное программирование\rОсновной инструмент функционального программирования (ФП) – математические функции. Математические функции выражают связь между исходными данными и итогом процесса. Процесс вычисления также имеет вход и выход, поэтому функция – вполне подходящее и адекватное средство описания вычислений. Именно этот простой принцип положен в основу функциональной парадигмы программирования. Инфо\rФункциональное программирование – декларативная парадигма программирования.\rФункциональная программа – набор определений функций. Функции определяются через другие функции или рекурсивно через самих себя. При выполнении программы функции получают аргументы, вычисляют и возвращают результат, при необходимости вычисляя значения других функций. Основные идеи функционального программирования: неизменяемые переменные – в функциональном программировании можно определить переменную, но изменить ее значение нельзя; чистая функция – это функция, результат работы которой предсказуем. При вызове с одними и теми же аргументами, такая функция всегда вернет одно и то же значение. Про такие функции говорят, что они не вызывают побочных эффектов; функции высшего порядка – могут принимать другие функции в качестве аргумента или возвращать их; рекурсия – поддерживается многими языками программирования, а для функционального программирования обязательна. Дело в том, что в языках ФП отсутствуют циклы, поэтому для повторения операций служит рекурсия. Использование рекурсии в языках ФП оптимизировано, и происходит быстрее, чем в языках императивного программирования; лямбда-выражения – способ определения анонимных функциональных объектов. Сильные стороны функционального программирования: повышенная надёжность кода; удобство организации модульного тестирования; возможности оптимизации при компиляции; возможности параллелизма. Недостатки: отсутствие присваиваний и замена их на порождение новых данных приводят к необходимости постоянного выделения и автоматического освобождения памяти, поэтому в системе исполнения функциональной программы обязательным компонентом становится высокоэффективный сборщик мусора. ","date":"25-05-2024","objectID":"/notes/programming_paradigms/:0:6","tags":["paradigms"],"title":"Парадигмы программирования","uri":"/notes/programming_paradigms/"},{"categories":["python"],"content":"Всё про нотацию Big O на примерах базовых коллекций в Python Big O — нотация, использующаяся в программировании, информатике для описания сложности алгоритмов. Она характеризует скорость роста времени выполнения алгоритма с ростом объёма входных данных, используя для оценки верхнюю границу (наихудший исход). Примеры нотаций Big O в порядке убывания скорости выполнения соответствующих им алгоритмов: O(1): Константная сложность. Читается как “сложность порядка 1”. Время выполнения алгоритма не зависит от размера входных данных, то есть если даже алгоритм выполняется постоянно в 3 шага, то он будет не O(3), а O(1). Является идеальной с точки зрения производительности, однако зачастую недостижима. Примеры: Доступ к элементу в массиве по индексу; Вставка или удаление элемента в конец списка (очереди) фиксированной длины. O(log n): Логарифмическая сложность. Время выполнения алгоритма растет медленно с увеличением размера входных данных. Например, бинарный поиск в отсортированном массиве. Пример: Бинарный поиск. В этом алгоритме на каждом шаге половина данных отсекается, и поиск продолжается в оставшейся половине. Это означает, что при увеличении размера входных данных вдвое, бинарный поиск требует всего одного дополнительного шага. O(n): Линейная сложность. Читается как “сложность порядка n”. Время выполнения алгоритма пропорционально размеру входных данных. Пример: Поиск максимального значения в списке: def find_max(my_list): max_num = my_list[0] for i in range(len(my_list)): if my_list[i] \u003e max_num: max_num = my_list[i] return max_num O(n log n): Линейно-логарифмическая сложность. Время выполнения алгоритма растет быстрее, чем линейно, но медленнее, чем квадратично. Пример: Сортировка слиянием. O(n^2): Квадратичная сложность. Примеры: Сортировка пузырём; Поиск суммы всех пар элементов списка: def pairs_sum(my_list): summ = 0 for i in range(my_list): for j in range(my_list): summ += my_list[i] + my_list[j] return summ O(n^3): Кубическая сложность. Пример: Алгоритмы, имеющие три вложенных цикла. O(2^n): Экспоненциальная сложность. Она обычно не является оптимальным решением из-за своей высокой вычислительной нагрузки при увеличении размера входных данных. Пример: Алгоритмы, использующие рекурсию без оптимизации (рекурсивное вычисление чисел Фибоначчи). O(n!): Факториальная сложность. Это самая высокая степень роста времени выполнения алгоритма. Этот тип сложности встречается, например, при переборе всех возможных комбинаций элементов, что делает его чрезвычайно неэффективным для больших значений n. Пример: Перебор всех перестановок элементов массива. ","date":"20-05-2024","objectID":"/notes/big_o/:0:0","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"График сложностей алгоритмов\r","date":"20-05-2024","objectID":"/notes/big_o/:0:1","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"Несущественное не учитывается\rПри оценке сложности алгоритмов лучше игнорировать константы и несущественные части, от которых скорость выполнения практически не зависит. Например, при оценке 5n^2 + 3n + 2 можно откинуть 5, 3n, 2. В результате мы получим O(n^2). Или при оценке n^2 + n + log(n) оставляем самую значимую часть (перемененную с наибольшей степенью) и получаем тот жеO(n^2). ","date":"20-05-2024","objectID":"/notes/big_o/:0:2","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"Сложность операций в Python\rРассмотрим некоторые операции, которые часто используют для базовых структур в языке программирования Python. n — размер структуры данных ","date":"20-05-2024","objectID":"/notes/big_o/:1:0","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"Списки:\rОперация Пример Сложность Примечание Получение элемента l[i] O(1) Присваивание значения элементу l[i] = 0 O(1) Размер списка len(l) O(1) Добавление элемента в конец списка l.append(5) O(1) Скорее всего это неверно Удаление последнего элемента l.pop() O(1) Аналогично l.pop(-1) Очищение списка l.clear() O(1) Аналогично l = [] Добавление нескольких элементов l1.extend(l2) O(len(n)) Прямая зависимость с размером l2 Создание списка list(l) O(n) Прямая зависимость с разером l Получение среза l[a:b] O(n) O(a - b) Сравнение списков l1 == l2 O(n) Вставка через срез l[a:b] O(n) Проверка наличия элемента в списке x is/not in l O(n) Тот же перебор элементов Поверхностное копирование списка l.copy() O(n) Аналогично l[:] Удаление элемента через del del l[i] O(n) Перебор до совпадения индексов, а значит зависит от i Удаление элемента через remove l.remove(...) O(n) Удаление элемента через pop l.pop(i) O(n) O(n-i) Получение крайнего значения min(l)/max(l) O(n) Снова перебор элементов Получение обратного списка l.reverse() O(n) Перебор for i in l: O(n) Сортировка l.sort() O(n * log(n)) Или sorted(l) Умножение списка на константу k*l O(k*n) 5*l =\u003e O(n), len(l)*l =\u003e O(n^2) ","date":"20-05-2024","objectID":"/notes/big_o/:1:1","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"Кортежи:\rКортежи — те же самые списки, только неизменяемые. Поэтому к ним применимы все операции, не изменяющие структуру данных, и они имеют такие же нотации сложности, как и списки. ","date":"20-05-2024","objectID":"/notes/big_o/:1:2","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"Множества:\rОперация Пример Сложность Примечание Размер множества len(s) O(1) Добавление элемента s.add(5) O(1) Проверка наличия элемента в множестве x is/not in s O(1) Удаления элемента через discard s.discard(...) O(1) Удаления элемента через remove s.remove(...) O(1) Удаления элемента через pop s.pop() O(1) Удаляемый элемент выбирается случайно Очищение множества s.clear() O(1) Аналогично s = set() Создание множества set(...) O(n) Сравнение множеств через ==, != s != t O(n) Сравнение множеств через \u003c=, \u003c s \u003c= t O(n) Аналогично s.issubset(t) Сравнение множеств через \u003e=, \u003e s \u003e= t O(n) Аналогично s.issuperset(t) Объединение s | t O(n) Аналогично s.union(t) Пересечение s \u0026 t O(n) Аналогично s.intersection(t) Разность s - t O(n) Аналогично s.difference(t) Симметрическая разность s ^ t O(n) Аналогично s.symmetric_difference(t) Перебор for i in s: O(n) Копирование s.copy() O(n) ","date":"20-05-2024","objectID":"/notes/big_o/:1:3","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"Неизменяемые множества\rПоддерживают все операции обычного множества за исключением тех, который изменяют структуру данных, и имеют те же нотации сложности, как у изменяемых множеств. ","date":"20-05-2024","objectID":"/notes/big_o/:1:4","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"Словари\rОперация Пример Сложность Примечание Получение элемента d[key] O(1) Добавление элемента/ Изменение значения d[key] = val O(1) Размер словаря len(d) O(1) Удаление элемента через del del d[key] O(1) Удаление элемента через popitem d.popitem() O(1) Удаляемый элемент выбирается случайно Удаление элемента через pop d.pop(key) O(1) get() и setdefault() d.get(key) O(1) Очищение словаря d.clear O(1) Аналогично s = {} или s = dict() Получение списка ключей/значений d.keys() O(1) Создание словаря dict(...) O(n) Перебор элементов for key in d: O(n) Для .keys(), .values(), .items() ","date":"20-05-2024","objectID":"/notes/big_o/:1:5","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"Прочие обозначения\rКроме обозначения “Big O”, существуют другие обозначения для оценки сложности алгоритмов: Big Theta (Θ): Big Theta также оценивает верхнюю и нижнюю границы временной сложности алгоритма, но описывает точную сложность, а не только наихудший случай, как Big O. Θ(f(n)) обозначает, что время выполнения алгоритма ограничено функцией f(n) как сверху, так и снизу. Big Omega (Ω): Big Omega оценивает нижнюю границу временной сложности алгоритма. Ω(f(n)) говорит о том, что алгоритм выполнится не быстрее, чем функция f(n). Little O (o): Little O представляет собой верхнюю границу, которая строже, чем Big O. Если f(n) является o(g(n)), это означает, что время выполнения алгоритма ограничивается функцией g(n), но алгоритм работает быстрее, чем g(n). Little Omega (ω): Little Omega представляет собой нижнюю границу, которая строже, чем Big Omega. Если f(n) является ω(g(n)), это означает, что алгоритм работает медленнее, чем g(n), но не медленнее, чем f(n). ","date":"20-05-2024","objectID":"/notes/big_o/:2:0","tags":["big O","algorithms","python"],"title":"Big O","uri":"/notes/big_o/"},{"categories":["python"],"content":"Управление текстовыми и бинарными файлами в языке программирования Python Программы, которые мы писали до сих пор, требовали повторного ввода данных при каждом запуске, потому что, как только программа заканчивает свою работу, данные для переменных исчезают из оперативной памяти. Если их нужно сберечь между выполнениями программы, требуется запись. Данные записываются в файл, обычно сохраняющийся на диске компьютера. Сохраненные в файле данные обычно остаются в нем после завершения работы программы, их можно позже извлечь и использовать. ","date":"17-05-2024","objectID":"/notes/work_with_files/:0:0","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Файловый ввод и вывод\rКогда программе нужно сохранить данные для дальнейшего использования, она пишет их в файл. Из файла записанные данные можно считать. Программисты называют такой процесс сохранения данных – запись данных в файл. Когда часть данных пишется в файл, она копируется из переменной, находящейся в оперативной памяти. Файл, куда сохраняются данные, называется файл вывода, потому что программа помещает в него выходные данные. Процесс извлечения данных из файла называется чтением данных из файла. Данные считываются из файла ввода. Программа извлекает входные данные из этого файла. Когда порция данных считывается из файла, она копируется в оперативную память, где на нее ссылается переменная. Когда в программе используется файл, как правило требуется выполнить три шага: Открыть файл. В процессе открытия файла создается связь между файлом и программой. Открытие файла вывода обычно создает файл на диске и позволяет программе записать в него данные. Открытие файла ввода позволяет программе прочитать данные из файла. Обработать файл. На этом шаге данные либо записываются в файл (если это файл вывода), либо считываются из файла (если это файл ввода). Закрыть файл. После использования файла программой его нужно закрыть, тем самым освободить ресурс и разорвать связь файла с программой. ","date":"17-05-2024","objectID":"/notes/work_with_files/:1:0","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Типы файлов\rСуществует два типа файлов: текстовые и двоичные (бинарные). Python позволяет работать с любыми из них. Текстовый файл содержит данные, которые были закодированы в виде текста при помощи такой схемы кодирования, как ASCII или Юникод. Даже если файл содержит числа, эти числа в файле хранятся как набор символов. В результате файл можно открыть и просмотреть в текстовом редакторе, таком как Блокнот. Двоичный файл содержит данные, которые не были преобразованы в текст. Данные, которые помещены в двоичный файл, предназначены только для чтения программой, и такой файл невозможно просмотреть в текстовом редакторе. ","date":"17-05-2024","objectID":"/notes/work_with_files/:1:1","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Методы доступа к файлам\rБольшинство языков программирования обеспечивают два способа получения доступа к данным в файле: последовательный, прямой или произвольный. Последовательный, как при проигрывании кассет с записью на пленке, выдает порции информации одну за другой. При работе с таким файлом не получится перескочить сразу к нужной части данных, сначала придется прочитать все предыдущие. При работе с файлом с прямым или произвольным доступом можно перескочить непосредственно к любой порции данных, не читая предыдущие. Как проигрыватель компакт-дисков или МР3-плеер перескакивает сразу к любой песне. ","date":"17-05-2024","objectID":"/notes/work_with_files/:1:2","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Кодировка файлов\rКодировка UTF-8 самая распространенная, рекомендуется использовать именно ее в качестве кодировки по умолчанию для текстовых файлов. Она довольно сложная, и на кодирование одного символа может уходить до 6 байт. В операционной системе Windows до сих пор используется однобайтовая кодировка Windows-1251. Чтобы избежать проблем при работе с текстовыми файлами в Windows нужно явно указывать кодировку. ","date":"17-05-2024","objectID":"/notes/work_with_files/:1:3","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Работа с текстовыми файлами\r","date":"17-05-2024","objectID":"/notes/work_with_files/:2:0","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Открытие файла\rФункция open() открывает файлы в Python. Она создает файловый объект и связывает его с файлом на диске. Формат применения: файловая_переменная = open(имя_файла, режим_доступа), где файловая_переменная – имя переменной, которая ссылается на файловый объект (такую переменную называют дескриптор файла); имя_файла – строковый литерал/ключ, задающий имя файла; режим_доступа – строковый литерал/ключ, задающий режим доступа. Ключи режима доступа: Ключ Режим Примечание 'r' Чтение В этом режиме файл не изменить 'w' Запись Если файл уже существует, содержимое стирается 'a' Добавление Открывает для записи. Добавляет данные в конец файла. Если файла не существует, он будет создан 'r+' Чтение и запись Частичная перезапись содержимого файла 'x' Создание Если файл существует, произойдёт ошибка Ключи режима обработки файлов: Ключ Режим 't' Текстовый 'b' Бинарный Чтобы открыть бинарный файл для чтения, можно воспользоваться следующим кодом: file = open('file.dat', 'rb'). По умолчанию режим доступа определён для чтения, поэтому, к примеру, файл students.txt можно открыть для чтения так: student_file = open('students.txt'). Аналогично, по умолчанию режим обработки определён как текстовый. Предположим, надо создать файл с именем sales.txt и записать в него данные о продажах. Это можно сделать так: sales_file = open('sales.txt', 'w') ","date":"17-05-2024","objectID":"/notes/work_with_files/:2:1","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Указание места расположения файла\rКогда в open() передается имя файла без указания пути, интерпретатор Python исходит из предположения, что место расположения файла то же, что у исполняемой программы (используется относительный путь). Если же требуется указать путь, то это можно сделать так: test_file = open('C:\\\\Users\\\\temp\\\\test.txt', 'w'). При этом вместо экранирования символа \\ можно воспользоваться “raw strings”: test_file = open(r'C:\\Users\\temp\\test.txt', 'w'). ","date":"17-05-2024","objectID":"/notes/work_with_files/:2:2","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Кодировка\rПри открытии файлов следует указывать его кодировку. Например, если открывается файл на русском языке, нужно использовать параметр encoding: file = open('info.txt', 'r', encoding='utf-8'). Чтобы получить кодировку уже открытого файла, используют файловое свойство encoding: file1 = open('students.txt', 'w') file2 = open('customers.txt', 'w', encoding='utf-8') print(file1.encoding) print(file2.encoding) file1.close() file2.close() # Вывод: cp1252 utf-8 ","date":"17-05-2024","objectID":"/notes/work_with_files/:2:3","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Закрытие файлов\rПосле окончания работы с файлом его необходимо закрыть по следующим причинам: если файл изменялся, это позволит корректно его сохранить; если открытый файл потребуется другим программам, программа на Python может его блокировать; не стоит держать в памяти лишние, уже не нужные, данные; удалить открытый кем-то файл проблематично. Для закрытия файла используется метод close(): file = open('info.txt', 'r') file.close() Чтобы проверить открыт файл или закрыт можно использовать файловое свойство (атрибут) closed: file1 = open('students.txt', 'w') file2 = open('customers.txt', 'w') file1.close() print(file1.closed) print(file2.closed) file2.close() # Вывод: True False ","date":"17-05-2024","objectID":"/notes/work_with_files/:2:4","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Чтение файлов\rДля чтения содержимого открытого для чтения файла используются три файловых метода: read() – читает все содержимое файла; readline() – читает одну строку из файла; readlines() – читает все содержимое файла и возвращает список строк. Предположим, в папке с исполняемой программой есть текстовый файл languages.txt с содержимым: Python Java Javascript C# C C++ PHP R Objective-C Метод read()\rread() считывает все содержимое из файла и возвращает строку, которая может содержать символы перехода на новую строку '\\n'. Приведённый ниже код считывает содержимое файла languages.txt в переменную content. В который будет содержаться строка 'Python\\nJava\\nJavascript\\nC#\\nC\\nC++\\nPHP\\nR\\nObjective-C'. При этом, если методу read() передать целочисленный параметр, то будет считано не более заданного количества символов. Например, считывать файл посимвольно можно при помощи метода read(1). Метод readline()\rreadline() считывает одну строку из файла (до символа конца строки '\\n'), при этом возвращается считанная строка вместе с символом '\\n'. Если считать строку не удалось – достигнут конец файла и больше строк в нем нет, возвращается пустая строка. Этот метод удобен, когда нужно управлять процессом чтения из файла, особенно если файл очень большой и его полное считывание может привести к нехватке памяти. Чтобы прочитать содержимое всего файла построчно, можно воспользоваться циклами while или for (второй предпочтительнее). Сам же файл позволяет итерироваться по строкам, поэтому его можно использовать в качестве аргументов функции map(), к примеру, или перебрать его строки в цикле, не объявляя отдельную переменную с содержимым файла: file = open('languages.txt', 'r', encoding='utf-8') for line in file: print(line.strip()) file.close() Метод readlines()\rreadlines() считывает все строки из файла и возвращает список из всех считанных строк (одна строка – один элемент списка). При этом, каждая строка в списке заканчивается символом переноса строки '\\n'. Чтобы удалить символ '\\n' можно использовать списочное выражение, лямбда-функцию или функцию map(): languages = list(map(str.strip, file.readlines())) Если передать в функцию list() ссылку на файловый объект list(file), получим тот же результат, что при вызове метода file.readlines(). ","date":"17-05-2024","objectID":"/notes/work_with_files/:2:5","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Курсор в файле\rВызов методов read(), readlines(), readline() перемещает текущую позицию (курсор) туда, где завершилось чтение. Для методов read() и readlines() это конец файла, для метода readline() – следующая строка после прочитанной. После завершения чтения всего файла не получится считать ни одного символа. Все последующие вызовы методов read() или readline() будут приводить к считыванию пустой строки. Для повторного чтения данных из файла, можно: переоткрыть файл, тогда курсор снова попадёт в начало; переместить курсор с помощью файлового метода seek(). Файловые методы seek() и tell()\rseek() задаёт позицию курсора в байтах от начала файла. Чтобы перевести курсор в самое начало файла необходимо вызвать метод seek(), передав ему в качестве аргумента значение 0. Пусть есть файл languages.txt: Python Java Javascript C# C++ PHP R Objective-C Тогда приведённый ниже код даст одинаковый вывод Python: file = open('languages.txt', 'r', encoding='utf-8') line1 = file.readline() file.seek(0) # переводим курсор в самое начало line2 = file.readline() print(line1, line2) file.close() Метод tell() возвращает позицию курсора в байтах от начала файла: file = open('languages.txt', 'r', encoding='utf-8') print(file.tell()) line1 = file.readline() print(file.tell()) file.close() # Вывод: 0 8 ","date":"17-05-2024","objectID":"/notes/work_with_files/:2:6","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Менеджер контекста\rЧтобы автоматически закрывать файл сразу после окончания работы с ним и осуществлять закрытие даже при возникновении ошибки, можно воспользоваться менеджером контекстов. Менеджер контекста – объект, реализующий одноименный протокол. Объекты, реализующие этот протокол, позволяют использовать следующий специальный синтаксис: with object as name: # Здесь нам доступен ресурс name. # Это тело with-блока. # А здесь ресурс name уже освобождён, даже если в теле with-блока произошла ошибка. Весь код в теле with-блока работает “в контексте”. Чаще всего контекст подразумевает выделение некоего ресурса, например, файла. По выходу из контекста ресурс автоматически освобождается, даже если при выполнении блока возникло исключение. Как только закончится код, оформленный с отступами в with, это будет означать, что контекст закончился, и Python автоматически закроет файл. Следующие два блока кода эквиваленты по результату выполнения: file = open('languages.txt', 'r', encoding='utf-8') for line in file: print(line) file.close() # ручное закрытие файла print('Файл закрыт') with open('languages.txt', 'r', encoding='utf-8') as file: for line in file: print(line) # автоматическое закрытие файла print('Файл закрыт') С помощью менеджера контекста можно работать с несколькими файлами: with open('input.txt', 'r') as input_file, open('output.txt', 'w') as output_file: # обработка файлов ","date":"17-05-2024","objectID":"/notes/work_with_files/:2:7","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Запись данных в файл\rДля записи используются два файловых метода (файл должен быть открыт для записи – режимы 'w', 'а', 'r+', иначе произойдет ошибка): write() – записывает переданную строку в файл; writelines() – записывает переданный список строк в файл. Метод write()\rРассмотрим текстовый файл myfile.txt, содержащий следующие строки: First line of the file. Second line of the file. Third line of the file. Если файл открыт в режиме 'w', то его содержимое сначала полностью стирается, а уже затем в него добавляются данные: with open('myfile.txt', 'w', encoding='utf-8') as file: file.write('Python and beegeek forever\\n') file.write('We love stepik \u003c3') # Файл myfile.txt будет содержать следующее: # Python and beegeek forever # We love stepik \u003c3 Если файл открыт в режиме 'a', то запись происходит в самый конец файла (результат очевиден). Если файл открыт в режиме 'r+', то происходит частичная перезапись его содержимого: with open('myfile.txt', 'r+', encoding='utf-8') as file: file.write('Python and beegeek forever\\n') file.write('We love stepik.') # Файл myfile.txt будет содержать следующее: # Python and beegeek forever # We love stepik. file. # Third line of the file. Последовательные вызовы метода write() дописывают текст в конец файла. Приведенный ниже код создает файл philosophers.txt и записывает в него три строки текста: with open('philosophers.txt', 'w', encoding='utf-8') as file: file.write('Джoн Локк\\n') file.write('Дэвид Хьюм\\n') file.write('Эдмyнд Берк\\n') Метод writelines()\rНа практике часто приходится записывать в файл содержимое целого списка. Это можно сделать с помощью цикла или метода writelines(), что удобнее. Метод writelines() принимает в качестве аргумента список строк и записывает его в файл. Приведенный ниже код создает файл philosophers.txt и записывает в него содержимое списка philosophers: philosophers = ['Джoн Локк\\n', 'Дэвид Хьюм\\n', 'Эдмyнд Берк\\n'] with open('philosophers.txt', 'w', encoding='utf-8') as file: file.writelines(philosophers) Запись в файл при помощи функции print()\rДля записи данных в файл можно также использовать встроенную функцию print(). Для этого нужно передать ей еще один именованный аргумент file, указывающий на открытый файл. При этом функция print() автоматически добавляет переход на новую строку: with open('philosophers.txt', 'w', encoding='utf-8') as output: print('Джoн Локк', file=output) print('Дэвид Хьюм', file=output) print('Эдмyнд Берк', file=output) # Файл будет содержать: # Джoн Локк # Дэвид Хьюм # Эдмyнд Берк ","date":"17-05-2024","objectID":"/notes/work_with_files/:2:8","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Немного про буфер\rВ некоторых операционных системах невыполнение операции закрытия файла может привести к потере данных. Данные сначала пишутся в буфер – небольшую область временного хранения в оперативной памяти. Когда буфер заполняется, система записывает его содержимое в файл. Это увеличивает производительность системы, потому что запись данных в оперативную память быстрее записи на диск. Процесс закрытия файла записывает любые несохраненные данные из буфера в файл. Чтобы принудительно записать содержимое буфера в файл, используется файловый метод flush(). ","date":"17-05-2024","objectID":"/notes/work_with_files/:2:9","tags":["python","files"],"title":"Работа с txt файлами в Python","uri":"/notes/work_with_files/"},{"categories":["python"],"content":"Вторая часть функций в Python (совсем базу вряд-ли буду выкладывать). Типы аргументов, некоторые встроенные и lambda функции ","date":"16-05-2024","objectID":"/notes/functions2/:0:0","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Необязательные и именованные аргументы\r","date":"16-05-2024","objectID":"/notes/functions2/:1:0","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Позиционные аргументы\rКогда мы вызываем функции c позиционными аргументами, значения в них подставляются согласно позиции их имен в определении функции. Например код ниже выведет число 7. При вызове функции diff() первому параметру x будет соответствовать первый переданный аргумент – 10, а второму параметру y – второй аргумент – 3. def diff(x, y): return x - y res = diff(10, 3) # используем позиционные аргументы print(res) ","date":"16-05-2024","objectID":"/notes/functions2/:1:1","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Именованные аргументы\rАргументы, передаваемые с именами, называются именованными. Чтобы передать именованные аргументы в функцию, нужно указать их имена, которые были заданы при объявлении функции: def bar(length, char1, char2): return (char1 + char2) * length + char1 print(bar(length=3, char1='-', char2='*')) # =\u003e -*-*-*- print(bar(char1='-', char2='*', length=3)) # =\u003e -*-*-*- print(bar(char2='*', length=3, char1='-')) # =\u003e -*-*-*- При вызове функции меняется порядок передаваемых аргументов. Когда функции назначаются соответствующие значения именованных аргументов, Python учитывает их имена, а не позиции. В результате функция будет всегда выводить одно и то же значение независимо от позиций переданных ей аргументов. Совет\rРекомендация по тому, когда стоит использовать именованные аргументы: если функция принимает больше трёх аргументов, нужно хотя бы часть из них указать по имени.\rdef make_circle(x, y, radius, line_width, fill): # тело функции make_circle(x=200, y=300, radius=17, line_width=2.5, fill=True) Предупреждение\rМы можем вызывать функции, используя именованные и позиционные аргументы одновременно. Но позиционные значения должны быть указаны до любых именованных!\r","date":"16-05-2024","objectID":"/notes/functions2/:1:2","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Необязательные аргументы\rБывает, что какой-то параметр функции часто принимает одно и то же значение. Например, для функции print() установили значения параметров sep и end равными символу пробела и символу перевода строки, поскольку эти значения используют наиболее часто. Другим примером служит функция int(), преобразующая строку в число. Она принимает два аргумента: первый аргумент – строка, которую нужно преобразовать в число, второй аргумент – основание системы счисления, значение по умолчанию которого равно 10. Чтобы задать значение параметра по умолчанию, в списке параметров функции достаточно после имени переменной написать знак равенства и нужное значение. Параметры со значением по умолчанию идут последними. Изменяемые типы данных в качестве значений по умолчанию\rРассмотрим определение функции append(), где в качестве значения по умолчанию используется изменяемый тип данных: def append(element, seq=[]): seq.append(element) return seq Если вызвать функцию так, то мы получим неожиданный результат: print(append(10)) print(append(5)) print(append(1)) # Вывод: [10] [10, 5] [10, 5, 1] Значение по умолчанию для параметра создается единожды при определении функции (обычно при загрузке модуля) и становится её атрибутом (свойством). Поэтому, если значение по умолчанию изменяемый объект, то его изменение повлияет на каждый следующий вызов функции. Для решения проблемы можно использовать константу None в качестве значения параметра по умолчанию, а в теле функции устанавливать нужное значение: def append(element, seq=None): if seq is None: seq = [] seq.append(element) return seq print(append(10)) print(append(5)) print(append(1)) # Вывод: [10] [5] [1] ","date":"16-05-2024","objectID":"/notes/functions2/:1:3","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функции с переменным количеством аргументов\r","date":"16-05-2024","objectID":"/notes/functions2/:2:0","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Позиционные аргументы – *args\rРассмотрим определение функции my_func(): def my_func(*args): print(type(args)) print(args) my_func() my_func(1, 2, 3) my_func('a', 'b') # Вывод: \u003cclass 'tuple'\u003e () \u003cclass 'tuple'\u003e (1, 2, 3) \u003cclass 'tuple'\u003e ('a', 'b') В заголовке функции my_func() указан всего один параметр args, но со звездочкой перед ним. Звездочка в определении функции означает, что переменная (параметр) args получит в виде кортежа все аргументы, переданные в функцию при ее вызове от текущей позиции и до конца. При описании функции можно использовать только один параметр помеченный звездочкой, причем располагаться он должен в конце списка параметров, иначе последующим параметрам не достанется значений. Параметр со звёздочкой работает, даже если не передать аргументов. Если мы хотим просуммировать несколько разных значений, не упаковывая их в список, можем написать следующую функцию (списки и кортежи при вызове нужно распаковывать): def my_sum(*args): return sum(args) print(my_sum(1, 2, *[3, 4, 5], *(7, 8, 9), 10)) # Вывод: 49 ","date":"16-05-2024","objectID":"/notes/functions2/:2:1","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Именованные аргументы – **kwargs\rdef my_func(**kwargs): print(type(kwargs)) print(kwargs) my_func() my_func(a=1, b=2) my_func(name='Timur', job='Teacher') # Вывод: \u003cclass 'dict'\u003e {} \u003cclass 'dict'\u003e {'a': 1, 'b': 2} \u003cclass 'dict'\u003e {'name': 'Timur', 'job': 'Teacher'} Именованные аргументы получаются в виде словаря, что позволяет сохранить имена аргументов в ключах. Именованные аргументы можно передавать в функцию “пачкой” в виде словаря. Для этого нужно перед словарём поставить две звёздочки. Параметр **kwargs пишется в самом конце, после последнего аргумента со значением по умолчанию. При этом функция может содержать и *args и **kwargs параметры: def my_func(a, b, *args, name='Gvido', age=17, **kwargs): print(a, b) print(args) print(name, age) print(kwargs) my_func(1, 2, 3, 4, name='Timur', age=28, job='Teacher', language='Python') my_func(1, 2, name='Timur', age=28, job='Teacher', language='Python') my_func(1, 2, 3, 4, job='Teacher', language='Python') # Вывод: 1 2 (3, 4) Timur 28 {'job': 'Teacher', 'language': 'Python'} 1 2 () Timur 28 {'job': 'Teacher', 'language': 'Python'} 1 2 (3, 4) Gvido 17 {'job': 'Teacher', 'language': 'Python'} ","date":"16-05-2024","objectID":"/notes/functions2/:2:2","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Keyword-only аргументы\rВ Python 3 добавили возможность пометить именованные аргументы функции так, чтобы вызвать функцию можно было, только передав эти аргументы по именам. Такие аргументы называются keyword-only и их нельзя передать в функцию в виде позиционных: def make_circle(x, y, radius, *, line_width=1, fill=True): #код make_circle(10, 20, 5) # x=10, y=20, radius=5, line_width=1, fill=True make_circle(x=10, y=20, radius=7) # x=10, y=20, radius=7, line_width=1, fill=True make_circle(10, 20, radius=10, line_width=2, fill=False) # x=10, y=20, radius=10, line_width=2, fill=False make_circle(x=10, y=20, radius=17, line_width=3) # x=10, y=20, radius=17, line_width=3, fill=True Здесь * выступает разделителем: отделяет обычные аргументы (их можно указывать по имени и позиционно) от строго именованных. То есть аргументы x, y и radius могут быть переданы в качестве как позиционных, так и именованных аргументов. При этом аргументы line_width и fill могут быть переданы только как именованные аргументы. Такой разделитель можно использовать только один раз в определении функции. Его нельзя применять в функциях с неограниченным количеством позиционных аргументов *args. ","date":"16-05-2024","objectID":"/notes/functions2/:3:0","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функции как объекты\rВстроенные функции имеют следующий тип объекта: print(type(print)) # \u003cclass 'builtin_function_or_method'\u003e Тогда как функции, объявленные программистом, имеют тип \u003cclass 'function'\u003e. Поскольку функции тоже объекты, работать с ними можно и как с объектами: записывать их в переменные, передавать в качестве аргументов другим функциям, возвращать из функций и т.д. def hello(): print('Hello from function') func = hello # присваиваем переменной func функцию hello func() # вызываем функцию # Вывод: Hello from function writeln = print writeln('Hello world!') writeln('Python') # Вывод: Hello world! Python Присваивание переменной списка функций: def f(x): return x**2 def g(x): return x**3 funcs = [f, g] print(funcs[0](5), funcs[1](5)) # Вывод: 25 125 Инфо\rФункции, способные в качестве аргумента принимать или/и возвращать другие функции, называются функциями высшего порядка. Функция, определяющая условия сравнения элементов, называется компаратор.\rТакие встроенные функции, как min(), max(), sorted() могут принимать необязательный аргумент key – функцию, определяющую, по какому правилу будут сравниваться элементы (значение key должно быть функцией, принимающей один аргумент и возвращающей на его основе ключ для сравнения). numbers = [10, -7, 8, -100, -50, 32, 87, 117, -210] print(max(numbers, key=abs)) print(min(numbers, key=abs)) print(sorted(numbers, key=abs)) # Вывод: -210 # максимальный по модулю элемент -7 # минимальный по модулю элемент [-7, 8, 10, 32, -50, 87, -100, 117, -210] def compare_by_second(point): return point[1] def compare_by_sum(point): return point[0] + point[1] points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)] print(sorted(points, key=compare_by_second)) # сортируем по второму значению кортежа print(sorted(points, key=compare_by_sum)) # сортируем по сумме кортежа ","date":"16-05-2024","objectID":"/notes/functions2/:4:0","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функции в качестве возвращаемых значений других функций\rВ Python можно определять функцию внутри функции, ведь функция это объект: def generator(): def hello(): print('Hello from function!') return hello func = generator() func() # Вывод: Hello from function! Мы можем написать генератор функций, который по параметрам a,b,c, построит и вернет нам конкретный квадратный трехчлен: def generator_square_polynom(a, b, c): def square_polynom(x): return a * x**2 + b * x + c return square_polynom f = generator_square_polynom(a=1, b=2, c=1) g = generator_square_polynom(a=2, b=0, c=-3) h = generator_square_polynom(a=-3, b=-10, c=50) print(f(1)) print(g(2)) print(h(-1)) # Вывод: 4 5 57 Вложенную функцию (square_polynom()), которая использует параметры внешней функции (generator_square_polynom()), называют замыканием. ","date":"16-05-2024","objectID":"/notes/functions2/:4:1","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функции высшего порядка\rФункции, которые принимают и/или возвращают другие функции, называются функциями высшего порядка. ","date":"16-05-2024","objectID":"/notes/functions2/:5:0","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функция map()\rФункция, преобразующая каждый элемент переданного итерируемого объекта (можно воспринимать как классическое представление функции в математике – отображение множества в другое множество). Возможная реализация: def map(function, items): result = [] for item in items: new_item = function(item) result.append(new_item) return result Мы можем совершать преобразования, используя функцию высшего порядка map(): def square(x): return x**2 def cube(x): return x**3 numbers = [1, 2, -3, 4, -5, 6, -9, 0] strings = map(str, numbers) # используем в качестве преобразователя функцию str abs_numbers = map(abs, numbers) # используем в качестве преобразователя функцию abs squares = map(square, numbers) # используем в качестве преобразователя функцию square cubes = map(cube, numbers) # используем в качестве преобразователя функцию cube print(strings) print(abs_numbers) print(squares) print(cubes) # Вывод: ['1', '2', '-3', '4', '-5', '6', '-9', '0'] [1, 2, 3, 4, 5, 6, 9, 0] [1, 4, 9, 16, 25, 36, 81, 0] [1, 8, -27, 64, -125, 216, -729, 0] Мы также можем строить цепочки преобразований, несколько раз вызывая функцию map() (сначала мы преобразуем список строк в список чисел, затем находим их модуль внешней функцией map()): numbers = ['-1', '20', '3', '-94', '65', '6', '-970', '8'] new_numbers = map(abs, map(int, numbers)) print(new_numbers) # Вывод: [1, 20, 3, 94, 65, 6, 970, 8] ","date":"16-05-2024","objectID":"/notes/functions2/:5:1","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функция filter()\rЭта функция отображает часть элементов итерируемого объекта по определённому критерию. Возможная реализация: def filter(function, items): result = [] for item in items: if function(item): result.append(item) # добавляем элемент item если функция function вернула значение True return result Функция filter() применяет предикат function к каждому элементу и добавляет в итоговый список только те элементы, для которых предикат вернул True. def is_odd(num): return num % 2 def is_word_long(word): return len(word) \u003e 6 numbers = list(range(15)) words = ['В', 'новом', 'списке', 'останутся', 'только', 'длинные', 'слова'] odd_numbers = filter(is_odd, numbers) large_words = filter(is_word_long, words) print(odd_numbers) print(large_words) # Вывод: [1, 3, 5, 7, 9, 11, 13] ['останутся', 'длинные'] ","date":"16-05-2024","objectID":"/notes/functions2/:5:2","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функция reduce()\rФункция, применяющая указанную функцию к элементам последовательности, сводя её к единственному значению. Возможная реализация: def reduce(operation, items, initial_value): acc = initial_value for item in items: acc = operation(acc, item) return acc def add(x, y): return x+y def mult(x, y): return x*y numbers = [1, 2, 3, 4, 5] total = reduce(add, numbers, 0) product = reduce(mult, numbers, 1) print(total) print(product) # Вывод: 15 120 ","date":"16-05-2024","objectID":"/notes/functions2/:5:3","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Встроенные функции map(), filter(), reduce()\r","date":"16-05-2024","objectID":"/notes/functions2/:6:0","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Встроенная функция map()\rФункция, применяющая другую функцию к итерируемому объекту. Имеет сигнатуру map(func, *iterables). В отличии от нашей реализации она может принимать сразу несколько последовательностей, переменное количество аргументов. Под подпоследовательностями имеются ввиду списки, строки, кортежи, множества, словари. def increase(num): return num + 7 numbers = [1, 2, 3, 4, 5, 6] new_numbers = map(increase, numbers) # используем встроенную функцию map() print(new_numbers) # Вывод: \u003cmap object at 0x...\u003e Вернулся итерируемый объект \u003cmap object at 0x...\u003e. Подобные ему объекты называются итераторами. Если мы хотим получить список/кортеж из итератора, нужно воспользоваться функцией list()/tuple(), а если распаковать, то * (при этом сделать эти действия возможно только единожды, т.к. итератор “исчерпывает” себя). Функции map() можно передать несколько последовательностей. В этом случае в функцию обратного вызова func будут передаваться сразу несколько элементов, расположенных в последовательностях на одинаковых позициях. При этом, если в последовательностях разное количество элементов, то последовательность с минимальным количеством элементов становится ограничителем. def func(elem1, elem2, elem3): return elem1 + elem2 + elem3 numbers1 = [1, 2, 3, 4, 5] numbers2 = [10, 20, 30, 40, 50] numbers3 = [100, 200, 300, 400, 500] new_numbers = list(map(func, numbers1, numbers2, numbers3)) # преобразуем итератор в список print(new_numbers) # Вывод: [111, 222, 333, 444, 555] Пример удобного использования функции map(), которой передано две последовательности: circle_areas = [3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213] result1 = list(map(round, circle_areas, [1]*6)) # округляем числа до 1 знака после запятой result2 = list(map(round, circle_areas, range(1, 7))) # округляем числа до 1,2,...,6 знаков после запятой print(circle_areas) print(result1) print(result2) # Вывод: [3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213] [3.6, 5.6, 4.3, 6.2, 91.0, 32.0] [3.6, 5.58, 4.319, 6.2024, 91.01344, 32.01213] ","date":"16-05-2024","objectID":"/notes/functions2/:6:1","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Встроенная функция filter()\rФункция отображает часть элементов итерируемого объекта по определённому критерию. Имеет сигнатуру filter(func, iterable). В отличии от нашей реализации она может принимать любой итерируемый объект (список, строку, кортеж, и т.д.). def func(elem): return elem \u003e= 0 numbers = [-1, 2, -3, 4, 0, -20, 10] positive_numbers = list(filter(func, numbers)) # преобразуем итератор в список print(positive_numbers) # Вывод: [2, 4, 0, 10] Функция filter() также возвращает итератор. Встроенной функции filter() можно в качестве первого параметра func передать значение None. В таком случае каждый элемент последовательности будет проверен на соответствие значению True. Если элемент в логическом контексте возвращает значение False, то он не будет добавлен в возвращаемый результат. В следующем коде значения списка [0, '', None, [], ()] позиционируется как False: true_values = filter(None, [1, 0, 10, '', None, [], [1, 2, 3], ()]) for value in true_values: print(value) # Вывод: 1 10 [1, 2, 3] ","date":"16-05-2024","objectID":"/notes/functions2/:6:2","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функция reduce()\rДля использования: from functools import reduce. Функция, применяющая указанную функцию к элементам последовательности, сводя её к единственному значению. Имеет сигнатуру reduce(func, iterable, initializer=None). Если начальное значение не установлено, то в его качестве используется первое значение из последовательности iterable. from functools import reduce def func(a, b): return a + b numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] total = reduce(func, numbers, 0) # в качестве начального значения 0 print(total) # Вывод: 55 ","date":"16-05-2024","objectID":"/notes/functions2/:6:3","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Анонимные функции\rlambda – безымянные однострочные функции (называются анонимными или лямбда-функциями). По сути эти функции являются выражениями, при этом они имеют такой же тип данных, как обычные функции – \u003cclass 'function'\u003e. После определения их можно сразу вызвать: print((lambda х, у: х + у)(5, 10)) # 5 + 10. Общий формат определения: lambda список_параметров: выражение. В теле лямбда-функции нельзя использовать несколько действий и циклы, но можно использовать тернарный условный оператор. Применение таких функций оправдано в следующих случаях: однократное использование функции; передача функций в качестве аргумента другим функциям; возвращение функции в качестве результата другой функции. def standard_function(x): # стандартное объявление функции return x*2 lambda_function = lambda x: x*2 # объявление анонимной функции print(standard_function(7)) print(lambda_function(7)) # Вывод: 14 14 f1 = lambda: 10 + 20 # функция без параметров f2 = lambda х, у: х + у # функция с двумя параметрами f3 = lambda х, у, z: х + у + z # функция с тремя параметрами print(f1()) print(f2(5, 10)) print(f3(5, 10, 30)) Лямбда-функции для нетипичной сортировки кортежей: points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)] print(sorted(points, key=lambda point: point[1])) # сортируем по второму значению кортежа print(sorted(points, key=lambda point: point[0] + point[1])) # сортируем по сумме элементов кортежа ","date":"16-05-2024","objectID":"/notes/functions2/:7:0","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Передача лямбда-функций в качестве аргументов\rФункция map(): numbers = [1, 2, 3, 4, 5, 6] new_numbers1 = list(map(lambda x: x+1, numbers)) # увеличиваем на 1 new_numbers2 = list(map(lambda x: x*2, numbers)) # удваиваем new_numbers3 = list(map(lambda x: x**2, numbers)) # возводим в квадрат strings = ['a', 'b', 'c', 'd', 'e'] numbers = [3, 2, 1, 4, 5] new_strings = list(map(lambda x, y: x*y, strings, numbers)) Функция filter(): numbers = [-1, 2, -3, 4, 0, -20, 10, 30, -40, 50, 100, 90] positive_numbers = list(filter(lambda x: x \u003e 0, numbers)) # положительные числа large_numbers = list(filter(lambda x: x \u003e 50, numbers)) # числа, большие 50 even_numbers = list(filter(lambda x: x % 2 == 0, numbers)) # четные числа words = ['python', 'stepik', 'beegeek', 'iq-option'] new_words1 = list(filter(lambda w: len(w) \u003e 6, words)) # слова длиною больше 6 символов new_words2 = list(filter(lambda w: 'e' in w, words)) # слова содержащие букву e Функция reduce(): from functools import reduce words = ['python', 'stepik', 'beegeek', 'iq-option'] numbers = [1, 2, 3, 4, 5, 6] summa = reduce(lambda x, y: x + y, numbers, 0) product = reduce(lambda x, y: x * y, numbers, 1) sentence = reduce(lambda x, y: x + ' loves ' + y, words, 'Everyone') # Вывод: 21 720 Everyone loves python loves stepik loves beegeek loves iq-option ","date":"16-05-2024","objectID":"/notes/functions2/:7:1","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Возвращение лямбда-функции в качестве результата другой функции\rСледующий пример показывает, что анонимные функции являются замыканиями, т.е. возвращаемая функция запоминает значения переменных a, b, c из внешнего окружения: def generator_square_polynom(a, b, c): return lambda x: a*x**2 + b*x + c ","date":"16-05-2024","objectID":"/notes/functions2/:7:2","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Условный оператор в теле лямбда-функции\rОбщий вид: значение1 if условие else значение2. numbers = [-2, 0, 1, 2, 17, 4, 5, 6] result = list(map(lambda x: 'even' if x % 2 == 0 else 'odd', numbers)) print(result) # Вывод: ['even', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even'] ","date":"16-05-2024","objectID":"/notes/functions2/:7:3","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Передача аргументов в анонимную функцию\rАнонимные функции поддерживают все способы передачи аргументов: позиционные; именованные; *args – переменный список позиционных аргументов; **kwargs – переменный список именованных аргументов; * – обязательные аргументы. f1 = lambda x, y, z: x + y + z f2 = lambda x, y, z=3: x + y + z f3 = lambda *args: sum(args) f4 = lambda **kwargs: sum(kwargs.values()) f5 = lambda x, *, y=0, z=0: x + y + z print(f1(1, 2, 3)) print(f2(1, 2)) print(f2(1, y=2)) print(f3(1, 2, 3, 4, 5)) print(f4(one=1, two=2, three=3)) print(f5(1)) print(f5(1, y=2, z=3)) # Вывод: 6 6 6 15 6 1 6 ","date":"16-05-2024","objectID":"/notes/functions2/:7:4","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функции any(), all(), zip(), enumerate()\r","date":"16-05-2024","objectID":"/notes/functions2/:8:0","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функция all()\rВстроенная функция all() возвращает значение True, если все элементы переданной ей коллекции истинны, и False в противном случае. При работе со словарями функция all() проверяет на соответствие параметрам True ключи словаря. print(all([1, 2, 3])) print(all([1, 2, 3, 0, 5])) print(all([True, 0, 1])) print(all(('', 'red', 'green'))) print(all({0j, 3+4j})) print() dict1 = {0: 'Zero', 1: 'One', 2: 'Two'} dict2 = {'Zero': 0, 'One': 1, 'Two': 2} print(all(dict1)) print(all(dict2)) # Вывод: True False False False False False True Если переданный итерируемый объект пуст, то функция all() возвращает значение True. print(all([])) # передаем пустой список print(all(())) # передаем пустой кортеж print(all('')) # передаем пустую строку print(all([[], []])) # передаем список, содержащий пустые списки # Вывод: True True True False ","date":"16-05-2024","objectID":"/notes/functions2/:8:1","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функция any()\rВстроенная функция any() возвращает значение True, если хотя бы один элемент переданной ей коллекции является истинным, и False в противном случае. При работе со словарями функция any() проверяет на соответствие True ключи словаря. print(any([0, 0, 0])) print(any([0, 1, 0])) print(any([False, 0, 1])) print(any(['', [], 'green'])) print(any({0j, 3+4j, 0.0})) print() dict1 = {0: 'Zero'} dict2 = {'Zero': 0, 'One': 1} print(any(dict1)) print(any(dict2)) # Вывод: False True True True True False True Если переданный итерируемый объект пуст, то функция any() возвращает значение False. print(any([])) # передаем пустой список print(any(())) # передаем пустой кортеж print(any('')) # передаем пустую строку print(any([[], []])) # передаем список, содержащий пустые списки # Вывод: False False False False ","date":"16-05-2024","objectID":"/notes/functions2/:8:2","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функции all(), any() в связке с map()\rСледующий код проверяет, все ли элементы списка больше 10: numbers = [17, 90, 78, 56, 231, 45, 5, 89, 91, 11, 19] result = all(map(lambda x: True if x \u003e 10 else False, numbers)) # анонимную функцию можно упростить до lambda x: x \u003e 10 if result: print('Все числа больше 10') else: print('Хотя бы одно число меньше или равно 10') Следующий код проверяет, чётен ли хотя бы один элемент коллекции: numbers = [17, 91, 78, 55, 231, 45, 5, 89, 99, 11, 19] result = any(map(lambda x: x % 2 == 0, numbers)) if result: print('Хотя бы одно число четное') else: print('Все числа нечетные') ","date":"16-05-2024","objectID":"/notes/functions2/:8:3","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функция enumerate()\rВстроенная функция enumerate() возвращает кортеж из индекса элемента и самого элемента переданной ей коллекции: enumerate(iterable, start), где iterable – итерируемый объект (коллекция), а start – необязательный параметр, задающий начальное значение индекса (по умолчанию start = 0). Эта функция возвращает объект-итератор, который можно перебрать, преобразовать в список функцией list() или распаковать *. colors = ['red', 'green', 'blue'] print(list(enumerate(colors, start=1))) # Вывод: [(1, 'red'), (2, 'green'), (3, 'blue')] ","date":"16-05-2024","objectID":"/notes/functions2/:8:4","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Функция zip()\rВстроенная функция zip() объединяет отдельные элементы из каждой переданной ей коллекции в кортежи. Также возвращает итератор, который можно перебрать, преобразовать или распаковать. Если функции zip() передать итерируемые объекты, имеющие разную длину, то объект с наименьшим количеством элементов определяет итоговую длину. numbers = [1, 2, 3, 4] words = ['one', 'two'] romans = ['I', 'II', 'III'] result = zip(numbers, words, romans) print(list(result)) # Вывод: [(1, 'one', 'I'), (2, 'two', 'II')] numbers = [1, 2, 3] words = ['one', 'two', 'three'] romans = ['I', 'II', 'III'] result = zip(numbers, words, romans) print(list(result)) # Вывод: [(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', 'III')] Частые случаи использования zip(): Для создания словарей, если ключи и значения находятся в разных списках: keys = ['name', 'age', 'gender'] values = ['Timur', 28, 'male'] info = dict(zip(keys, values)) print(info) # Вывод: {'name': 'Timur', 'age': 28, 'gender': 'male'} Для параллельного итерирования по разным коллекциям: name = ['Timur', 'Ruslan', 'Rustam'] age = [28, 21, 19] for x, y in zip(name, age): print(x, y) # Вывод: Timur 28 Ruslan 21 Rustam 19 ","date":"16-05-2024","objectID":"/notes/functions2/:8:5","tags":["python","functions"],"title":"Функции в Python","uri":"/notes/functions2/"},{"categories":["python"],"content":"Точные числа с плавающей точкой, дроби и комплексные числа. Как с ними работать в Python? ","date":"14-05-2024","objectID":"/notes/dec_frac_compl/:0:0","tags":["python","datatypes","decimal","fractions"],"title":"Decimal, Fraction и комплексные числа в Python","uri":"/notes/dec_frac_compl/"},{"categories":["python"],"content":"Модуль decimal\rДля использования: from decimal import *. Если мы хотим сравнить два числа float, то нужно воспользоваться кодом ниже вместо обычного сравнения ==, так как существуют ограничения в сохранении точного значения чисел: num = 0.1 + 0.1 + 0.1 eps = 0.000000001 # точность сравнения if abs(num - 0.3) \u003c eps: # число num отличается от числа 0.3 менее чем 0.000000001 print('YES') else: print('NO') Особенности и характеристики: Тип данных Decimal - класс из модуля decimal, который тоже представляет собой число с плавающей точкой, и служит для того, чтобы выполнять операции над вещественными числами без ошибок. С ними работают все привычные операции (сложение, умножение и т.д., но не рекомендуется оперировать между Decimal и float), их можно передавать как аргумент в математические функции (при этом вернётся float), их можно сравнивать между собой (также допускается точное равенство), можно формировать списки из Decimal и искать среди них min и max. Тип данных Decimal является неизменяемым. Отличие float и Decimal: В Python тип данных float реализован по стандарту IEEE-754 как число с плавающей точкой двойной точности (64 бита) с основанием экспоненты равным 2. Так как float поддерживается аппаратно, быстродействие при использовании этого типа данных сравнительно велико. Тип данных Decimal – число с плавающей точкой с основанием экспоненты 10 Он реализован по стандарту IBM: General Decimal Arithmetic Specification, в свою очередь основанному на стандартах IEEE. Тип данных Decimal реализован программно, поэтому он в разы медленнее типа данных float. Сам тип данных Decimal написан на языке С. Характеристика / тип float Decimal Реализация аппаратная программная Размер 64 бит не ограничен Основание экспоненты 2 10 Скорость ✔️ ❌ Настраиваемость ❌ ✔️ Для высокоточных вычислений ❌ ✔️ Для типа данных Decimal можно настроить: точность выполнения операций в количестве десятичных знаков (по умолчанию - 28); режимы округления; режимы обработки исключительных ситуаций (деление на ноль, переполнение и т. д). Создать Decimal число можно из обычного целого числа (int), из числа с плавающей точкой (float) или из строки (str): from decimal import * d1 = Decimal(1) d2 = Decimal(567) d3 = Decimal(-93) d4 = Decimal('12345') d5 = Decimal('52.198') При создании Decimal чисел из чисел с плавающей точкой (float) возникают проблемы, так как float числа округляются внутри до ближайшего возможного, а Decimal об этом ничего не знает и копирует содержимое float: from decimal import * num = Decimal(0.1) print(num) # Вывод: 0.1000000000000000055511151231257827021181583404541015625 ","date":"14-05-2024","objectID":"/notes/dec_frac_compl/:1:0","tags":["python","datatypes","decimal","fractions"],"title":"Decimal, Fraction и комплексные числа в Python","uri":"/notes/dec_frac_compl/"},{"categories":["python"],"content":"Методы decimal\rУ Decimal есть некоторые встроенные математические методы: Функция Описание sqrt() вычисляет квадратный корень из Decimal числа exp() возвращает e^x для Decimal числа ln() вычисляет натуральный логарифм Decimal числа log10() вычисляет десятичный логарифм Decimal числа as_tuple() - возвращает кортеж из 3-ёх элементов: sign – знак числа (0 для положительного числа и 1 для отрицательного числа); digits – цифры числа (цифра 0 не учитывается, если целая часть равна нулю); exponent – значение экспоненты (количество цифр после точки, умноженное на −1), from decimal import * num1 = Decimal('-1.4568769017') num2 = Decimal('0.523') num_tuple = num.as_tuple() print(num1.as_tuple()) print(num2.as_tuple()) print(num1_tuple.sign) print(num1_tuple.digits) print(num1_tuple.exponent) # Вывод: DecimalTuple(sign=1, digits=(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7), exponent=-10) DecimalTuple(sign=0, digits=(5, 2, 3), exponent=-3) 1 (1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7) -10 getcontext() - просмотр базовых параметров Decimal from decimal import * print(getcontext()) # Вывод: Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow]) quantize() - принимает в качестве аргумента объект Decimal, указывающий на формат округления: from decimal import * getcontext().prec = 4 # устанавливаем точность числа num = Decimal('3.1415926535') print(num.quantize(Decimal('1.000'))) # округление до 3 цифр в дробной части print(num.quantize(Decimal('1.00'))) # округление до 2 цифр в дробной части print(num.quantize(Decimal('1.0'))) # округление до 1 цифр в дробной части Опасность\rПри этом, если точность числа установлена в 2, а формат округления Decimal('1.00'), то возникнет ошибка.\rВ качестве второго параметра этот метод принимает стратегию округления: ROUND_CEILING – округление в сторону бесконечности (Infinity); ROUND_FLOOR – округляет в сторону минус бесконечности (- Infinity); ROUND_DOWN – округление в сторону нуля; ROUND_HALF_EVEN – округление до ближайшего четного числа, число 6.5 округлится не до 7, а до 6; ROUND_HALF_DOWN – округление до ближайшего нуля; ROUND_UP – округление от нуля; ROUND_05UP – округление от нуля (если последняя цифра после округления до нуля была бы 0 или 5, в противном случае к нулю). from decimal import * num = Decimal('3.456') print(num.quantize(Decimal('1.00'), ROUND_CEILING)) print(num.quantize(Decimal('1.00'), ROUND_FLOOR)) # Вывод: 3.46 3.45 ","date":"14-05-2024","objectID":"/notes/dec_frac_compl/:1:1","tags":["python","datatypes","decimal","fractions"],"title":"Decimal, Fraction и комплексные числа в Python","uri":"/notes/dec_frac_compl/"},{"categories":["python"],"content":"Модуль fractions\rДля использования: from fractions import Fraction Тип данных Fraction представляет из себя рациональное число в виде дроби. Особенности и характеристики: Fraction, как и Decimal, реализован программно, поэтому он в разы медленнее встроенных числовых типов данных int и float. Тип данных Fraction неизменяемый. Операции над данными этого типа приводят к созданию новых объектов, при этом старые не меняются. Fraction числа можно сравнивать между собой точно так же, как и любые другие числа (также можно сравнить Fraction и целые числа без явного приведения типов); с ним работает все арифметические операции (возведение в степень может вернуть float). При создании рационального числа Fraction, автоматически происходит сокращение числителя и знаменателя дроби, а если результат - целое число, то оно и будет выведено. Fraction числа можно передавать как аргументы функций, ожидающих float. Тогда они будут преобразованы во float. К примеру, модуль math, оперирующий float числами, может работать и с Fraction числами (возвращать функции будут float). Создать Fraction число можно несколькими способами: из целых чисел, передав значения числителя и знаменателя дроби; из строки на основании десятичного представления; из строки на основании обыкновенной дроби; из числа с плавающей точкой (не рекомендуется, так как в Fraction попадет уже неправильно округленное число). from fractions import Fraction num1 = Fraction(3, 4) # 3 – числитель, 4 – знаменатель num2 = Fraction('0.55') num3 = Fraction('1/9') ","date":"14-05-2024","objectID":"/notes/dec_frac_compl/:2:0","tags":["python","datatypes","decimal","fractions"],"title":"Decimal, Fraction и комплексные числа в Python","uri":"/notes/dec_frac_compl/"},{"categories":["python"],"content":"Методы и свойства\rnumerator - для получения числителя, denominator - для получения знаменателя: from fractions import Fraction num = Fraction('5/16') print('Числитель дроби равен:', num.numerator) print('Знаменатель дроби равен:', num.denominator) # Вывод: Числитель дроби равен: 5 Знаменатель дроби равен: 16 as_integer_ratio() – возвращает кортеж, состоящий из числителя и знаменателя данного Fraction числа. limit_denominator() – возвращает самую близкую к данному числу рациональную дробь, чей знаменатель не превосходит переданного аргумента: from fractions import Fraction import math print('PI =', math.pi) num = Fraction(str(math.pi)) print('No limit =', num) for d in [1, 5, 50, 90, 100, 500, 1000000]: limited = num.limit_denominator(d) print(limited) # Вывод: PI = 3.141592653589793 No limit = 3141592653589793/1000000000000000 3 16/5 22/7 267/85 311/99 355/113 3126535/995207 Инфо\rВ Python нельзя совершать арифметические операции (+, -, *, /) между типами Decimal и Fraction.\r","date":"14-05-2024","objectID":"/notes/dec_frac_compl/:2:1","tags":["python","datatypes","decimal","fractions"],"title":"Decimal, Fraction и комплексные числа в Python","uri":"/notes/dec_frac_compl/"},{"categories":["python"],"content":"Комплексные числа в Python\rОбщая форма представления комплексного числа следующая: real + imag j, где real – вещественная часть комплексного числа; imag – мнимая часть комплексного числа, которая завершается символом j или J. Особенности и характеристики: С complex числами работают все привычные операции: сложение, вычитание, умножение, деление, возведение в степень. Мы также можем совершать арифметические операции над complex и целыми числами (миксовать complex, int, float). Для работы с комплексными числами вместо модуля math нужно использовать модуль cmath z1 = 5 + 7j z2 = 1j z3 = -3 + 5J z4 = 1.5 + 3.2j print(z1, z2, z3, z4, sep='\\n') print(type(z1)) # Вывод: (5+7j) 1j (-3+5j) (1.5+3.2j) \u003cclass 'complex'\u003e Комплексные числа можно создать с помощью литерала, как выше, а можно с помощью функции complex(), которая принимает два аргумента: вещественную и мнимую часть числа, либо строковое представление числа: z1 = -3 + 2j # создание на основе литерала z2 = complex(6, -8) # z2 = 6 - 8j z3 = complex(0, 2.5) # z3 = 2.5j z4 = complex(5, 0) # z4 = 5 + 0j z5 = complex('3+4j') # создание на основе строки print(z1, z2, z3, z4, z5, sep='\\n') # Вывод: (-3+2j) (6-8j) 2.5j (5+0j) (3+4j) ","date":"14-05-2024","objectID":"/notes/dec_frac_compl/:3:0","tags":["python","datatypes","decimal","fractions"],"title":"Decimal, Fraction и комплексные числа в Python","uri":"/notes/dec_frac_compl/"},{"categories":["python"],"content":"Методы и свойства\rreal - для получения вещественной части, а imag - для мнимой: z = 3+4j print('Действительная часть =', z.real) print('Мнимая часть =', z.imag) # Вывод: Действительная часть = 3.0 Мнимая часть = 4.0 conjugate() - возвращает сопряжённое комплексное число. Для нахождения модуля комплексного числа, используется встроенная функция abs(). ","date":"14-05-2024","objectID":"/notes/dec_frac_compl/:3:1","tags":["python","datatypes","decimal","fractions"],"title":"Decimal, Fraction и комплексные числа в Python","uri":"/notes/dec_frac_compl/"},{"categories":["python"],"content":"Модуль random\rДля использования: import random Функции и методы: randint() - принимает два обязательных аргумента a и b и возвращает псевдослучайное целое число из [a, b]; randrange() - может принимать те же аргументы, что и range(), но вместо обычной последовательности чисел возвращает псевдослучайное число из этой последовательности; random() - не принимает аргументов и возвращает псевдослучайное число с плавающей точкой в диапазоне [0.0, 1.0); uniform() - возвращает псевдослучайное число с плавающей точкой в указанном диапазоне [a, b]; seed() - указывает начальное для генератора псевдослучайных чисел (по умолчанию начальное значение - системное время); shuffle() - принимает список в качестве обязательного аргумента и перемешивает его случайным образом; choice() - принимает список (строку, кортеж) в качестве обязательного аргумента и возвращает один случайный элемент; sample() - принимает два обязательных аргумента: первый – коллекция (последовательность), которая поддерживает индексацию (список, строка, кортеж), второй – количество случайных элементов. Возвращает список из указанного количества уникальных (имеющих разные индексы) случайных элементов. ","date":"13-05-2024","objectID":"/notes/random_string/:1:0","tags":["python","string","random","modules"],"title":"Модули random и string","uri":"/notes/random_string/"},{"categories":["python"],"content":"Модуль string\rДля использования: import string В модуле string есть удобные константные строки, которыми можно воспользоваться: print(string.ascii_letters) print(string.ascii_uppercase) print(string.ascii_lowercase) print(string.digits) print(string.hexdigits) print(string.octdigits) print(string.punctuation) print(string.printable) # Вывод: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 0123456789abcdefABCDEF 01234567 !\"#$%\u0026'()*+,-./:;\u003c=\u003e?@[\\]^_`{|}~ 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%\u0026'()*+,-./:;\u003c=\u003e?@[\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c ","date":"13-05-2024","objectID":"/notes/random_string/:2:0","tags":["python","string","random","modules"],"title":"Модули random и string","uri":"/notes/random_string/"},{"categories":["python"],"content":"Списки (кратко), кортежи (кратко), множества, словари и всё, что с ними связано ","date":"12-05-2024","objectID":"/notes/collections/:0:0","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Just notes\rЗдесь опишу не совсем очевидные для меня вещи (на момент, когда я о них узнал). Если в функцию filter() передаётся lambda-функция, то она работает медленнее list comprehensions. В случае же, когда в filter() помещаются встроенные методы (например str.alpha), то, наоборот, filter() работает быстрее, чем списочные выражения. Следующие строки кода являются эквивалентными: 'Super' 'sonic', 'Super' + 'sonic'. Согласно документации, строковые литералы, которые являются частью одного выражения и имеют только пробелы между ними, будут неявно преобразованы в один строковый литерал. Синглтон - это паттерн проектирования, гарантирующий, что у класса будет только один экземпляр. Функция-критерий, которая возвращает значение True или False, называется предикатом. Итератор - итерируемый объект (например \u003cmap object at 0x...\u003e). Коллекциями в языке Python принято называть типы данных, в том или ином виде хранящие ссылки на ряд других объектов. Сравнение строк происходит по старшинству в алфавите, а старше та буква, которая ближе к концу алфавита. print((\"NO\", \"YES\")[num1.issuperset(num2)]) - в квадратных скобках мы получаем результат логического выражения (True - 1 или False - 0). Значит после кортежа будет либо [0], либо [1] - индекс элемента, который мы выберем из самого кортежа. Чтобы не использовать экранирование при работе с текстом, можно воспользоваться raw strings, т.е. вместо такого кода: path = 'C:\\\\new\\\\text.txt', использовать код: path = r'C:\\new\\text.txt'. При вызове метода мы используем скобки: (например) close(), а при вызове свойства (атрибута) скобок нет closed. Методы совершают действия, а свойства возвращают информацию об объекте. При конвертации строки в число, функция int() игнорирует пробелы и символы табуляции, перевода строки и т.п. Если использовать строчные методы islower()/isupper() для строки, состоящей только из небуквенных символов, вернётся False. ","date":"12-05-2024","objectID":"/notes/collections/:1:0","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Списки\rСписки изменяемы; в них допускается выход на границы, просто возьмется весь список до конца; список может содержать элементы разных типов данных; списки - ссылочный тип даных. Если мы хотим копировать список letters = ['a', 'b', 'c', 'd'], мы можем сделать это следующими способами: new_letters = letters[:] new_letters = list(letters) new_letters = letters.copy() Совет\rЧтобы вывести список в одну строку, можно воспользоваться методом join() или распаковать print(*student)\rСписочные методы и операторы: метод append() добавляет новый элемент в конец списка; метод extend() расширяет один список другим списком; метод insert() вставляет значение в список в заданной позиции; метод index() возвращает индекс первого элемента, значение которого равняется переданному в метод значению; метод remove() удаляет первый элемент, значение которого равняется переданному в метод значению; метод pop() удаляет элемент по указанному индексу и возвращает его; метод count() возвращает количество элементов в списке, значения которых равны переданному в метод значению; метод reverse() инвертирует порядок следования значений в списке, то есть меняет его на противоположный; метод copy() создает поверхностную копию списка.; метод clear() удаляет все элементы из списка; оператор del позволяет удалять элементы списка по определенному индексу. Методы строк, работающие со списками: Метод split() разбивает строку на слова, используя в качестве разделителя последовательность пробельных символов, символ табуляции (\\t) или символ новой строки (\\n). Метод join() собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод. Совет\rЕсли нужно получить очищенную от знаков препинания и заглавных букв строку, можно воспользоваться следующей конструкцией: text = [word.strip('.,!?:;-') for word in input().lower().split()]\r","date":"12-05-2024","objectID":"/notes/collections/:2:0","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Матрицы\rИндексы i и j элементов на главной диагонали квадратной матрицы связаны соотношением i = j. На побочной диагонали: i + j + 1 = n (или j = n - i - 1), где n — размерность матрицы. Заметим также, что: если элемент находится выше главной диагонали, то i \u003c j, если ниже – i \u003e j. если элемент находится выше побочной диагонали, то i + j + 1 \u003c n, если ниже - i + j + 1 \u003e n. Если мы вводим элементы построчно, то может задать матрицу так: n, m = [int(i) for i in input().split()] matrix = [[int(i) for i in input().split()] for _ in range(n)] ","date":"12-05-2024","objectID":"/notes/collections/:2:1","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Кортежи\rКортежи являются неизменяемыми списками. В литеральной форме кортеж записывается в виде последовательности элементов в круглых скобках, а список – в квадратных. Для создания кортежа с единственным элементом после значения элемента ставят замыкающую запятую: my_tuple = (1,). Важно понимать: список внутри кортежа можно изменить. Списки являются ссылочными типами данных, поэтому в кортеже хранится ссылка на список, которая не меняется при изменении самого списка. Инфо\rФункции, возвращающие несколько значений, возвращают кортеж.\rКортежи поддерживают: доступ к элементу по индексу (только для получения значений элементов); методы, в частности index(), count(); встроенные функции, в частности len(), sum(), min() и max(); срезы; оператор принадлежности in; операторы конкатенации (+) и повторения (*). Чтобы присвоить переменным значения элементов кортежа, можно воспользоваться следующим кодом (кол-во переменных должно совпадать с кол-вом элементов кортежа): colors = ('red', 'green', 'blue', 'cyan') (a, b, c, d) = colors # Скобки можно опустить Однако, если необходимо получить лишь какие-то отдельные значения, то в качестве “ненужных” переменных позволено использовать символ нижнего подчеркивания _. Есть способ собрать сразу несколько значений в одну переменную. Это делается при помощи звездочки перед именем переменной. a, b, *tail = 1, 2, 3, 4, 5, 6 - в этом случае в переменной a будет записана единица, в переменной b — двойка, а в переменной tail — список, состоящий из всех аргументов, которые не попали в предыдущие переменные. В данном случае tail будет равен [3, 4, 5, 6]. tail всегда будет списком, даже когда в него попадает лишь один элемент или даже ноль. Звездочка может быть только у одного аргумента, но необязательно у последнего. Если нужно распаковать единственное значение в кортеже, после имени переменной должна идти запятая. Приведенный ниже код: a = 1, # не распаковка, а просто присвоение b, = 1, # распаковка print(a) print(b) # Вывод: (1,) 1 Инфо\rТаким же образом можно распаковывать и список, и строку\r","date":"12-05-2024","objectID":"/notes/collections/:3:0","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Множества\r","date":"12-05-2024","objectID":"/notes/collections/:4:0","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Общая информация\rМножество – структура данных, организованная так же, как математические множества. Особенности: все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение; множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке; элементы множества должны относиться к неизменяемым типам данных; хранящиеся в множестве элементы могут иметь разные типы данных. Чтобы создать множество, нужно перечислить его элементы через запятую в фигурных скобках: numbers = {2, 4, 6, 8, 10} languages = {\"Python\", \"C#\", \"C++\", \"Java\"} Пустое множество создаётся, например, через set(). При выводе множества порядок элементов может отличаться от существовавшего при его создании, поскольку множества — неупорядоченные коллекции данных. Встроенная функция set() помимо создания пустого множества может преобразовывать некоторые типы объектов в множества. В неё можно передать один аргумент, который, в свою очередь, должен быть итерируемым объектом (таким как список, кортеж или строковое значение). Отдельные элементы объекта, передаваемого в качестве аргумента, становятся элементами множества: myset1 = set(range(10)) # множество из элементов последовательности myset2 = set([1, 2, 3, 4, 5]) # множество из элементов списка myset3 = set('abcd') # множество из элементов строки myset4 = set((10, 20, 30, 40)) # множество из элементов кортежа Опасность\rПопытка добавить в множество кортеж со списком приведёт к ошибке!\rmytuple = ([1, 2, 3], [4, 5, 6]) myset = set(mytuple) # Вывод: TypeError: unhashable type: 'list' Если требуется создать множество, в котором каждый элемент — строковое значение, содержащее более одного символа, то используем код: myset = set(['aaa', 'bbbb', 'cc']). Проверить принадлежит ли какой-либо объект множеству можно с помощью оператора in: tremendously_huge_set = {\"red\", \"green\", \"blue\"} if \"green\" in tremendously_huge_set: print(\"Green is there!\") else: print(\"Unfortunately, there is no green...\") # Вывод: Green is there! Индексация, конкатенация, умножение на число и срезы недоступны для множеств, а значит перебор элементов по индексу не получится, поэтому, например, в цикле, мы должны перебирать сами элементы из множества. Чтобы вывести все элементы множества, мы можем его распаковать (при этом не гарантируется, что вывод будет упорядоченным): numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7} print(*numbers, end=' ') # Вывод: 0 1 1 2 3 3 3 5 6 7 7 Если мы хотим упорядочить вывод множества, можем воспользоваться встроенной функцией sorted() (возвращает список): numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7} sorted_numbers = sorted(numbers) print(*sorted_numbers, end=' ') Встроенная функция sorted() имеет опциональный параметр reverse. Если установить этот параметр в значение True, произойдет сортировка по убыванию. Также есть второй параметр key, с помощью которого можно указать функцию, по которой будет происходить сортировка (например, int или len). Важно, что функция при этом пишется без скобок, как это обычно происходит. ","date":"12-05-2024","objectID":"/notes/collections/:4:1","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Методы множеств\rДля добавления нового элемента в множество используется метод add(); Метод remove() удаляет элемент из множества с генерацией исключения (ошибки) в случае, если такого элемента нет; Метод discard() удаляет элемент из множества без генерации исключения (ошибки), если элемент отсутствует; Метод pop() удаляет и возвращает случайный элемент из множества с генерацией исключения (ошибки) при попытке удаления из пустого множества; Метод clear() удаляет все элементы из множества. Методы, НЕ изменяющие сами множества\runion() - объединение множеств. myset1 = {1, 2, 3, 4, 5} myset2 = {3, 4, 6, 7, 8} myset3 = myset1.union(myset2) print(myset3) Для объединения двух множеств можно также использовать оператор |. myset1 = {1, 2, 3, 4, 5} myset2 = {3, 4, 6, 7, 8} myset3 = myset1 | myset2 print(myset3) intersection() - пересечение множеств. Альтернатива: оператор \u0026. difference() - разность множеств. Альтернатива: оператор -. symmetric_difference() - симметрическая разность множеств. Альтернатива: оператор ^. Методы, ИЗМЕНЯЮЩИЕ множества\rupdate() - изменяет исходное множество по объединению. Аналогичный результат получается, если использовать оператор |=. intersection_update() - изменяет исходное множество по пересечению. Аналогичный результат получается, если использовать оператор \u0026=. difference_update() - изменяет исходное множество по разности. Аналогичный результат получается, если использовать оператор -=. symmetric_difference_update() - изменяет исходное множество по симметрической разности. Аналогичный результат получается, если использовать оператор ^=. Все основные операции над множествами выполняются двумя способами: при помощи метода или соответствующего ему оператора. Различие заключается в том, что метод может принимать в качестве аргумента не только множество (тип данных set), но и любой итерируемый объект (список, строку, кортеж и т.д.) mylist = [2021, 2020, 2019, 2018, 2017, 2016] mytuple = (2021, 2020, 2016) mystr = 'abcd' myset = {2009, 2010, 2016} print(myset.union(mystr)) # объединяем со строкой print(myset.intersection(mylist)) # пересекаем со списком print(myset.difference(mytuple)) # находим разность с кортежем # Вывод: {2016, 'c', 'b', 'a', 'd', 2009, 2010} {2016} {2009, 2010} Некоторые методы (union(), intersection(), difference()) и операторы (|, \u0026, -, ^) позволяют совершать операции над несколькими множествами сразу. Оператор ^ симметрической разности позволяет использовать несколько множеств, а метод symmetric_difference() – нет. Приоритет операторов в порядке убывания (верхние операторы имеют более высокий приоритет, чем нижние): Оператор Описание - разность \u0026 пересечение ^ симметрическая разность | объединение Другие методы\rissubset() - используется для определения, является ли одно из множеств подмножеством другого. Возвращает True или False. set1 = {2, 3} set2 = {1, 2, 3, 4, 5, 6} print(set1.issubset(set2)) # Вывод: True Для определения, является ли одно из множеств подмножеством другого, также применяются операторы \u003c= (нестрогое подмножество) и \u003c (строгое подмножество). Следующий код аналогичен предыдущему по функционалу: set1 = {2, 3} set2 = {1, 2, 3, 4, 5, 6} print(set1 \u003c= set2) issuperset() - используется для определения, является ли одно из множеств надмножеством другого. Возвращает True или False. В качестве альтернативы используются операторы \u003e= (нестрогое надмножество) и \u003e (строгое надмножество). isdisjoint() - используется для определения отсутствия общих элементов в множествах. Возвращает True или False. Данные методы могут принимать в качестве аргумента не только set(), но и любой итерируемый объект (список, строку, кортеж…). В то же время они могут применяться только к set() или неизменяемому множеству (тип данных frozenset). При этом операторы \u003e, \u003c, \u003e=, \u003c= требуют наличия в качестве операндов множества. ","date":"12-05-2024","objectID":"/notes/collections/:4:2","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Генератор множеств\rЧтобы создать множество, содержащее цифры введённого числа, можно воспользоваться следующей конструкцией: digits = {int(c) for c in input()} Общий вид генератора множеств следующий: {выражение for переменная in последовательность}, где выражение – некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы множества; переменная – имя некоторой переменной; последовательность – последовательность значений, которые она принимает (любой итерируемый объект). В генераторах множеств можно использовать условный оператор. Например, если требуется создать множество, заполненное только цифрами некоторой строки, то мы можем написать такой код: digits = {int(d) for d in 'abcd12ef78ghj90' if d.isdigit()} Если же нужно включить else, то используется тернарный условный оператор: alnums = {int(d) if d.isdigit() else ord(d) for d in 'abcd12ef78ghj90'} ","date":"12-05-2024","objectID":"/notes/collections/:4:3","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Frozenset\rТип коллекций frozenset() - это неизменяемое множество. Создание неизменяемых множеств: myset1 = frozenset({1, 2, 3}) # на основе множества myset2 = frozenset([1, 1, 2, 3, 4, 4, 4, 5, 6, 6]) # на основе списка myset3 = frozenset('aabcccddee') # на основе строки Над замороженными множествами можно производить все операции, которые можно производить над обычными множествами (само собой, если операция не изменяет исходное множество). Результатом операций над замороженными множествами будут также замороженные множества. Будучи изменяемыми, обычные множества не могут быть элементами других множеств. Замороженные множества являются неизменяемыми, а значит могут быть элементами других множеств. Инфо\rСравнивать обычные и неизменяемые множества можно.\r","date":"12-05-2024","objectID":"/notes/collections/:4:4","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Словари\r","date":"12-05-2024","objectID":"/notes/collections/:5:0","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Общая информация\rСловари (тип данных dict) – изменяемые коллекции элементов с произвольными индексами – ключами. Если в списках элементы индексируются целыми числами, начиная с 0, то в словарях — уникальными ключами, в том числе в виде строк. Инфо\rСловарь — реализация структуры данных “ассоциативный массив” или “хеш таблица”.\rВ словарях нет привычных индексов (0, 1, 2, …)! Ключи должны быть неизменяемым типом данных, а тип данных значения - произволен. Словари принципиально отличаются от списков по структуре хранения в памяти. Список — последовательная область памяти, то есть все его элементы (указатели на элементы) действительно хранятся в указанном порядке, расположены последовательно. Благодаря этому и можно быстро «прыгнуть» к элементу по его индексу. В словаре же используется специальная структура данных — хеш-таблица. Она позволяет вычислять числовой хеш от ключа и использовать обычные списки, где в качестве индекса элемента берется этот хеш. Чтобы создать словарь, нужно перечислить его элементы (пары ключ-значение) через запятую в фигурных скобках, как и элементы множества. Первым указывается ключ, после двоеточия – значение, доступное в словаре по этому ключу. Приведенный ниже код создает словарь, в котором ключом служит строка – название языка программирования, а значением – имя создателя языка. languages = {'Python': 'Гвидо ван Россум', 'C#': 'Андерс Хейлсберг', 'Java': 'Джеймс Гослинг', 'C++': 'Бьёрн Страуструп'} Извлекать значение словаря слудует также, как если бы мы извлекали элемент списка, но вместо индекса пишем ключ в квадратных скобках: print('Создателем языка C# является', languages['C#']) В качестве ключа можно указать выражение. Python вычислит его значение и обратится к искомому элементу: print('Создателем языка C# является', languages['C' + '#']) Если ключи словаря – строки без каких-либо специальных символов, то для создания словаря можно использовать функцию dict(). Приведённый ниже код создает словарь с тремя элементами, ключами которого служат строки ’name’, ‘age’, ‘job’, а значениями – ‘Timur’, 28, ‘Teacher’. info = dict(name = 'Timur', age = 28, job = 'Teacher') Создавать словари можно на основе списков кортежей или кортежей списков. Первый элемент списка или кортежа станет ключом, второй — значением. Если необходимо создать словарь, каждому ключу которого соответствует одно и то же значение, можно воспользоваться методом fromkeys(). Приведенный ниже код создает словарь с тремя элементами, где ключи — строки ’name’, ‘age’, ‘job’, а соответствующие им значения: ‘Missed information’, ‘Missed information’, ‘Missed information’. dict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed information') Если методу fromkeys() не передать второй параметр, то по умолчанию присваивается значение None. ","date":"12-05-2024","objectID":"/notes/collections/:5:1","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Пустой словарь\rПустой словарь можно создать так: dict1 = {} dict2 = dict() Начиная с версии Python 3.6, словари являются упорядоченными, то есть сохраняют порядок следования ключей в порядке их внесения в словарь. ","date":"12-05-2024","objectID":"/notes/collections/:5:2","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Основы работы со словарями\rОператор in позволяет проверить, содержит ли словарь заданный ключ; Встроенная функция sum() принимает в качестве аргумента словарь с числовыми ключами и вычисляет сумму его ключей; Встроенные функции min() и max() принимают в качестве аргумента словарь и находят минимальный и максимальный ключ соответственно, при этом ключ может принадлежать к любому типу данных, для которого возможны операции порядка \u003c, \u003c=, \u003e, \u003e= (числа, строки, и т.д.); Словари можно сравнивать между собой операторами == и !=. Равные словари имеют одинаковое количество элементов и содержат равные элементы (ключ: значение); Срезы, операция конкатенации и умножения на число недоступны для словарей. ","date":"12-05-2024","objectID":"/notes/collections/:5:3","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Перебор элементов словаря\rВывод ключей: capitals = {\"Россия\": \"Москва\", \"Франция\": \"Париж\", \"Чехия\": \"Прага\"} for key in capitals: print(key) Вывод значений: for key in capitals: print(capitals[key]) Словарный метод keys() возвращает список ключей всех элементов словаря: for key in capitals.keys(): # итерируем по списку [\"Россия\", \"Франция\", \"Чехия\"] print(key) # Вывод: Россия Франция Чехия Словарный метод values() возвращает список значений всех элементов словаря. Словарный метод items() возвращает список всех элементов словаря, состоящий из кортежей пар (ключ, значение). Инфо\rСловарные методы items(), keys(), values() возвращают не совсем обычные списки. Типы этих списков называются итераторами – dict_items, dict_keys, dict_values, соответственно, в отличие от обычных списков list. Методы обычных списков недоступны для списков типа dict_items, dict_keys, dict_values. Нужно использовать явное преобразование с помощью функции list() для получения доступа к методам списков.\rЕсли требуется вывести только ключи словаря, то мы так же можем использовать операцию распаковки словаря: print(*capitals, sep=\"\\n\") Сортировка по ключам выполняется с использованием функции sorted() (возвращает отсортированный список ключей, а не словарь): for key in sorted(capitals): print(key) Для сортировки словаря по значениям можно использовать функцию sorted() вместе с методом items() (возвращает не словарь, а отсортированный по значениям список кортежей): for key, value in sorted(capitals.items(), key=lambda x: x[1]): print(value) ","date":"12-05-2024","objectID":"/notes/collections/:5:4","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Методы и операторы словарей\rЧтобы изменить значение по определенному ключу в словаре, достаточно использовать индексацию вместе с оператором присваивания. При этом если ключ уже присутствует в словаре, его значение заменяется новым, если же ключ отсутствует – то в словарь будет добавлен новый элемент. info = {'name': 'Sam', 'age': 28, 'job': 'Teacher'} info['name'] = 'Timur' # изменяем значение по ключу name info['email'] = 'timyr-guev@yandex.ru' # добавляем в словарь элемент с ключом email print(info) Для того чтобы избежать возникновения ошибки в случае отсутствия ключа в словаре, можно использовать метод get(), способный кроме ключа принимать и второй аргумент – значение, которое вернется, если заданного ключа нет. Когда второй аргумент не указан, то метод в случае отсутствия ключа возвращает None. info = {'name': 'Bob', 'age': 25, 'job': 'Dev'} item1 = info.get('salary') item2 = info.get('salary', 'Информации о зарплате нет') print(item1) print(item2) # Вывод: None Информации о зарплате нет Метод update() реализует своеобразную операцию конкатенации для словарей. Он объединяет ключи и значения одного словаря с ключами и значениями другого. При совпадении ключей в итоге сохранится значение словаря, указанного в качестве аргумента метода update(). info1 = {'name': 'Bob', 'age': 25, 'job': 'Dev'} info2 = {'age': 30, 'city': 'New York', 'email': 'bob@web.com'} info1.update(info2) print(info1) # Вывод: {'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'} Инфо\rВ Python 3.9 появились операторы | и |=, которые реализуют операцию конкатенации словарей.\rМетод setdefault() позволяет получить значение из словаря по заданному ключу, автоматически добавляя элемент словаря, если он отсутствует. Метод принимает два аргумента: key: ключ, значение по которому следует получить, если таковое имеется в словаре, либо создать. default: значение, которое будет использовано при добавлении нового элемента в словарь. Инфо\rВажно! get() только получает значение, не меняя словарь, в то время как setdefault() не только получает значение, но и изменяет словарь.\rС помощью оператора del можно удалять элементы словаря по ключу: del info['email'] (если удаляемого ключа в словаре нет, возникнет ошибка KeyError). Метод pop() удаляет элемент словаря по ключу, возвращая его значение: email = info.pop('email') (при отсутствии ключа также возвращает ошибку, если не передать второй аргумент). Метод popitem() удаляет из словаря последний добавленный элемент и возвращает удаляемый элемент в виде кортежа (ключ, значение). Метод clear() удаляет все элементы из словаря: info.clear(). Метод copy() создает поверхностную копию словаря: info_copy = info.copy() (оператор присваивания (=) не копирует словарь, а лишь присваивает ссылку на старый словарь новой переменной.). ","date":"12-05-2024","objectID":"/notes/collections/:5:5","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Вложенные словари\rЧтобы обратиться к элементу вложенного словаря, нужно указать ключи в нескольких квадратных скобках (подобно спискам). ","date":"12-05-2024","objectID":"/notes/collections/:5:6","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"},{"categories":["python"],"content":"Генераторы словарей\rОбщий вид: {ключ: значение for переменная in последовательность} Примеры использования: Чтобы создать словарь, где ключи – числа от 0 до 5, а значения – квадраты ключей, можем воспользоваться следующим кодом: squares = {i: i**2 for i in range(6)}; Для вычисления ключа и значения в генераторе словаря могут быть использованы выражения: lst = ['ReD', 'GrEeN', 'BlUe'] dct = {c.lower(): c.upper() for c in lst} print(dct) # Вывод: {'red': 'RED', 'green': 'GREEN', 'blue': 'BLUE'} Извлечение из словаря элементов с определенными ключами: dict1 = {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E', 5: 'F'} selected_keys = [0, 2, 5] dict2 = {k: dict1[k] for k in selected_keys} print(dict2) # Вывод: {0: 'A', 2: 'C', 5: 'F'} Мы также можем использовать генераторы словарей для создания вложенных словарей: squares = {i: {j: j**2 for j in range(i + 1)} for i in range(5)} for value in squares.values(): print(value) # Вывод: {0: 0} {0: 0, 1: 1} {0: 0, 1: 1, 2: 4} {0: 0, 1: 1, 2: 4, 3: 9} {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} В генераторах словарей можно использовать условный оператор. Приведенный ниже код создает словарь, ключами которого являются четные числа от 0 до 9, а значениями – квадраты ключей: squares = {i: i**2 for i in range(10) if i % 2 == 0} (можно обойтись и без условного оператора, установив параметр step в функции range()). ","date":"12-05-2024","objectID":"/notes/collections/:5:7","tags":["python","datatypes"],"title":"Коллекции в Python. Часть I","uri":"/notes/collections/"}]