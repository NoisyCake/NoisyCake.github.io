<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HFK</title>
    <link>http://localhost:1313/</link>
    <description>HFK</description>
    <generator>Hugo 0.138.0 &amp; FixIt v0.3.14</generator>
    <language>ru</language>
    <managingEditor>darkgxd@vk.com (NoisyCake)</managingEditor>
    <webMaster>darkgxd@vk.com (NoisyCake)</webMaster>
    <lastBuildDate>Sun, 15 Sep 2024 17:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Основы статистики</title>
      <link>http://localhost:1313/notes/basics_of_statistics/</link>
      <pubDate>Sun, 15 Sep 2024 17:00:00 +0000</pubDate><author>darkgxd@vk.com (NoisyCake)</author>
      <guid>http://localhost:1313/notes/basics_of_statistics/</guid>
      <category domain="http://localhost:1313/categories/math/">Math</category>
      <description>&lt;p&gt;Попытка объяснить основы математической статистики на простом языке&lt;/p&gt;&#xA;&lt;div class=&#34;details admonition warning open&#34;&gt;&#xD;&#xA;  &lt;div class=&#34;details-summary admonition-title&#34;&gt;&lt;i class=&#34;icon fa-fw fa-solid fa-exclamation-triangle&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;Предупреждение&lt;i class=&#34;details-icon fa-solid fa-angle-right fa-fw&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/div&gt;&#xD;&#xA;  &lt;div class=&#34;details-content&#34;&gt;&#xD;&#xA;    &lt;div class=&#34;admonition-content&#34;&gt;В процессе написания&lt;/div&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;генеральная-совокупность-и-выборка&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Генеральная совокупность и выборка&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d0%b3%d0%b5%d0%bd%d0%b5%d1%80%d0%b0%d0%bb%d1%8c%d0%bd%d0%b0%d1%8f-%d1%81%d0%be%d0%b2%d0%be%d0%ba%d1%83%d0%bf%d0%bd%d0%be%d1%81%d1%82%d1%8c-%d0%b8-%d0%b2%d1%8b%d0%b1%d0%be%d1%80%d0%ba%d0%b0&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Генеральная совокупность (ГС) — это множество всех объектов, относительно которых предполагается делать выводы в рамках конкретного исследования.&lt;/p&gt;&#xA;&lt;p&gt;Выборка — часть генеральной совокупности. Требуется, если невозможно провести исследования над всей генеральной совокупностью.&lt;/p&gt;&#xA;&lt;p&gt;Репрезентативная выборка — такая выборка, в которой все основные признаки генеральной совокупности, из которой извлечена данная выборка, представлены приблизительно в той же пропорции или с той же частотой, что и в этой ГС.&lt;/p&gt;&#xA;&lt;p&gt;Способы выборок:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Простейшая случайная выборка. В ней объекты выбираются случайным образом из всей ГС.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/selection1.png&#34; alt=&#34;/notes/basics_of_statistics/images/selection1.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/selection1.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/selection1.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/selection1.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/selection1.png&#34; style=&#34;--width: 1055px;--aspect-ratio: 1055 / 522;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;Стратифицированная выборка. Генеральная совокупность в такой выборке разбивается на страпы (группы) на основе определённого признака/признаков, затем из каждой группы случайным образом берутся элементы.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/selection2.png&#34; alt=&#34;/notes/basics_of_statistics/images/selection2.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/selection2.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/selection2.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/selection2.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/selection2.png&#34; style=&#34;--width: 1056px;--aspect-ratio: 1056 / 510;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;Групповая (кластерная) выборка. Совокупность также разделяется на группы, но не по какому-то признаку, а случайным образом. Следующим шагом выбираются несколько групп, из которых элементы берутся также случайно.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/selection3.png&#34; alt=&#34;/notes/basics_of_statistics/images/selection3.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/selection3.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/selection3.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/selection3.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/selection3.png&#34; style=&#34;--width: 1056px;--aspect-ratio: 1056 / 514;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;типы-переменных&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Типы переменных&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d1%82%d0%b8%d0%bf%d1%8b-%d0%bf%d0%b5%d1%80%d0%b5%d0%bc%d0%b5%d0%bd%d0%bd%d1%8b%d1%85&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Переменными выборки называют те или иные признаки объектов, которые собираются исследовать. Они бывают нескольких видов.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Количественные&lt;/strong&gt; — переменные, которые можно измерить (к примеру, рост). Если переменная может принимать любое значение на определённом промежутке, то она называется &lt;strong&gt;непрерывной&lt;/strong&gt; количественной переменной (например, рост в промежутке от 150 до 200). &lt;strong&gt;Дискретными&lt;/strong&gt; переменными называются те, которые могут принять отдельное возможное значение с определённой вероятностью (количество детей в семье).&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Номинативные (качественные)&lt;/strong&gt; — также бывают двух видов. Первые — &lt;strong&gt;номинальные&lt;/strong&gt; переменные, использующиеся как имена для групп. Например, можно обозначить группу мужчин за x, а группу женщин за y. Вторые — &lt;strong&gt;ранговые&lt;/strong&gt; переменные, представляющие упорядоченные категории. К примеру, степень удовлетворённости обслуживанием в кафе или порядковый номер бегуна в забеге.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;меры-центральной-тенденции&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Меры центральной тенденции&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d0%bc%d0%b5%d1%80%d1%8b-%d1%86%d0%b5%d0%bd%d1%82%d1%80%d0%b0%d0%bb%d1%8c%d0%bd%d0%be%d0%b9-%d1%82%d0%b5%d0%bd%d0%b4%d0%b5%d0%bd%d1%86%d0%b8%d0%b8&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Гистограмма частот — графическое представление распределения количественного признака.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/histogram.png&#34; alt=&#34;/notes/basics_of_statistics/images/histogram.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/histogram.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/histogram.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/histogram.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/histogram.png&#34; style=&#34;--width: 1841px;--aspect-ratio: 1841 / 931;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Познакомимся с типами описательных статистик.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Меры центральной тенденции&lt;/strong&gt; — значения, вычисленные тем или иным путём исходя из графика, описывающие множество значений самого графика.&lt;/p&gt;&#xA;&lt;p&gt;Допустим, имеются 1000 значений некоторой количественной переменной. Требуется описать эти данные всего одним числом, содержащим ценную информацию.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Мода&lt;/strong&gt; — значение измеряемого признака, встречающееся наиболее часто.&lt;/p&gt;&#xA;&lt;p&gt;Рассмотрим следующий график. Числом, которое встречается чаще всего, является 172 — оно и будет модой распределения.&lt;/p&gt;&#xA;&lt;p&gt;Исключим одно значение, равное 172. Теперь имеем моду сразу из трёх значений: 167, 170, 172.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/fashion.png&#34; alt=&#34;/notes/basics_of_statistics/images/fashion.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/fashion.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/fashion.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/fashion.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/fashion.png&#34; style=&#34;--width: 1447px;--aspect-ratio: 1447 / 660;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Медиана&lt;/strong&gt; — значение признака, которое делит &lt;strong&gt;упорядоченное&lt;/strong&gt; множество данных пополам.&lt;/p&gt;&#xA;&lt;p&gt;При &lt;!-- raw HTML omitted --&gt;нечётном&lt;!-- raw HTML omitted --&gt; количестве элементов медианой является середина множества. При &lt;!-- raw HTML omitted --&gt;чётном&lt;!-- raw HTML omitted --&gt; же — среднее арифметическое двух центральных значений признака.&lt;/p&gt;&#xA;&lt;p&gt;Возьмём только первые 9 чисел из упорядоченного множества на графике. Имеем след. значения: 157, 159, 161, 164, 165, 166, 167, 167, 167. В данном случае медианой является 165.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Среднее значение&lt;/strong&gt; — среднее арифметическое всех значений признака.&lt;/p&gt;&#xA;&lt;p&gt;Данный показатель (вернее, среднее арифметическое) обладает некоторыми свойствами:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Если каждый элемент выборки увеличить на одно и то же число, то и среднее значение увеличится на это число.&lt;/li&gt;&#xA;&lt;li&gt;Если каждый элемент выборки умножить на одно и то же число, то и среднее значение у на это число.&lt;/li&gt;&#xA;&lt;li&gt;Если для каждого значения выборки рассчитать его отклонение от среднего арифметического, то сумма этих отклонений будет равна 0.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Обозначение: \(\Mu/\mu\) — для ГС или \(\bar{x}\) — для выборки&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Представленное выше распределение симметрично, унимодально (имеет одну моду) и не имеет заметных выбросов, поэтому для его описания можно использовать любую меру.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;меры-изменчивости&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Меры изменчивости&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d0%bc%d0%b5%d1%80%d1%8b-%d0%b8%d0%b7%d0%bc%d0%b5%d0%bd%d1%87%d0%b8%d0%b2%d0%be%d1%81%d1%82%d0%b8&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Чтобы рассчитать показатели, характеризующие изменчивость исследуемого признака, можно использовать следующие меры:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Размах&lt;/strong&gt; (range) — разность между максимальным и минимальным значением распределения. Данная мера использует всего два значения, из-за чего не является достаточно показательной.&lt;br&gt;&#xA;Обозначение: \(R\)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Дисперсия&lt;/strong&gt; — средний квадрат отклонений индивидуальных значений признака от их средней величины.&lt;/p&gt;&#xA;&lt;p&gt;Она вычисляется по следующей формуле: \(D = \frac{\sum(x_i - \bar{x})^2}{n}\). Важно уточнить, что данная формула применима только к генеральной совокупности. Для расчёта дисперсии выборки из знаменателя вычитают единицу: \(D = \frac{\sum(x_i - \bar{x})^2}{n-1}\)&lt;br&gt;&#xA;Обозначение: \(D\) или \(\sigma^2\)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Среднеквадратичное (стандартное) отклонение&lt;/strong&gt; — реальное среднее значение отклонений, получаемое извлечением корня из дисперсии. Соответственно, для нахождения, пользуемся формулой:&#xA;$$&#xA;\sqrt{\sigma = \frac{\sum(x_i - \bar{x})^2}{n-1}}&#xA;$$&#xA;Обозначение: \(\sigma\) — для ГС или \(sd\) — для выборки&lt;/p&gt;&#xA;&lt;p&gt;Разберём некоторые свойства дисперсии:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;\(D_{x+c} = D_x\)&lt;br&gt;&#xA;\(sd_{x+c} = sd_x\)&lt;/li&gt;&#xA;&lt;li&gt;\(D_{xc} = D_x * x^2\)&lt;br&gt;&#xA;\(sd_{xc} = sd_x * x\)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;квантили-распределения-box-plot&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Квантили распределения, box plot&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d0%ba%d0%b2%d0%b0%d0%bd%d1%82%d0%b8%d0%bb%d0%b8-%d1%80%d0%b0%d1%81%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f-box-plot&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Квантили&lt;/strong&gt; — такие значения признака, которые делят упорядоченные данные на некоторое число равных частей.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Квартили&lt;/strong&gt; — 3 квантиля, которые делят распределение на 4 равные части.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Box plot&lt;/strong&gt; (ящик с усами/боксплот) — график, компактно представляющий одномерное распределение вероятностей.&lt;br&gt;&#xA;Он показывает:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Медиану (средний квартиль на уровне 50%);&lt;/li&gt;&#xA;&lt;li&gt;Верхний квартиль (на уровне 75%);&lt;/li&gt;&#xA;&lt;li&gt;Нижний квартиль (на уровне 25%);&lt;/li&gt;&#xA;&lt;li&gt;Межквартильный размах (МКР — разница между верхним и нижним квартилями);&lt;/li&gt;&#xA;&lt;li&gt;Выбросы, т.е. те значения, которые выходят из промежутка [нижний квартиль - 1,5 * МКР; верхний квартиль + 1,5 * МКР]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/box%20plot.jpg&#34; alt=&#34;/notes/basics_of_statistics/images/box%20plot.jpg&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/box%20plot.jpg?size=small, http://localhost:1313/notes/basics_of_statistics/images/box%20plot.jpg?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/box%20plot.jpg?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/box%20plot.jpg&#34; style=&#34;--width: 800px;--aspect-ratio: 800 / 600;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;нормальное-распределение&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Нормальное распределение&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d0%bd%d0%be%d1%80%d0%bc%d0%b0%d0%bb%d1%8c%d0%bd%d0%be%d0%b5-%d1%80%d0%b0%d1%81%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Нормальное распределение (распределение Гаусса) — унимодальное и симметричное распределение, в котором отклонения значений от стандартного равновероятны и подчиняются следующему вероятностному закону:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;в диапазоне \(\pm\sigma\) стандартных отклонений от среднего значения находится  34.1*2 ≈ 64% наблюдений&lt;/li&gt;&#xA;&lt;li&gt;в диапазоне \(\pm2\sigma\) стандартных отклонений от среднего значения (34.1 + 13.6)*2 ≈ 95% наблюдений&lt;/li&gt;&#xA;&lt;li&gt;в диапазоне \(\pm3\sigma\) стандартных отклонений от среднего значения находится (34.1 + 13.6 + 2.1)*2 ≈ 100% наблюдений&lt;/li&gt;&#xA;&lt;li&gt;за последним диапазоном находится ≈ 0.1% наблюдений&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/standard-deviation.jpg&#34; alt=&#34;/notes/basics_of_statistics/images/standard-deviation.jpg&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/standard-deviation.jpg?size=small, http://localhost:1313/notes/basics_of_statistics/images/standard-deviation.jpg?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/standard-deviation.jpg?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/standard-deviation.jpg&#34; style=&#34;--width: 1920px;--aspect-ratio: 1920 / 960;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Z-преобразование&lt;/strong&gt; (стандартизация) — преобразование распределения таким образом, чтобы его среднее значение стало равно 0, а среднеквадратичное отклонение — 1.&lt;/p&gt;&#xA;&lt;p&gt;Осуществляется преобразование следующим образом:&lt;br&gt;&#xA;$$&#xA;z_i = \frac{x_i - \bar{x}}{\sigma}&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;При Z-преобразовании форма распределения никак не меняется:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/standartization.png&#34; alt=&#34;/notes/basics_of_statistics/images/standartization.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/standartization.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/standartization.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/standartization.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/standartization.png&#34; style=&#34;--width: 1463px;--aspect-ratio: 1463 / 902;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Другими словами, преобразование дает понять в скольких стандартных отклонениях находится отдельно взятое значение. Например, человек с ростом 186,2 находится примерно в 1.4 стандартных отклонениях от среднего (1.4*8 = 11,2, именно на столько отличается рост этого человека от среднего).&lt;/p&gt;&#xA;&lt;p&gt;Z-преобразование позволяет найти процент наблюдений, находящийся в произвольном диапазоне. Пусть \(\bar{x}=150\), \(sd=8\). Требуется найти долю значений, превышающих 154. В таком случае \(z = \frac{154 - 150}{8} = 0,5\). Воспользуемся следующей таблицей. В ней Значения z представлены для значений &lt;strong&gt;не больших чем z&lt;/strong&gt;, но нам нужно как раз обратное, поэтому вычитаем найденное число из единицы, получаем ≈ 0.3.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/table.png&#34; alt=&#34;/notes/basics_of_statistics/images/table.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/table.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/table.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/table.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/table.png&#34; style=&#34;--width: 680px;--aspect-ratio: 680 / 767;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Для нахождения долей также можно воспользоваться &lt;a href=&#34;https://gallery.shinyapps.io/dist_calc/&#34;target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;калькулятором&lt;i class=&#34;fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;центральная-предельная-теорема&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Центральная предельная теорема&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d1%86%d0%b5%d0%bd%d1%82%d1%80%d0%b0%d0%bb%d1%8c%d0%bd%d0%b0%d1%8f-%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d1%8c%d0%bd%d0%b0%d1%8f-%d1%82%d0%b5%d0%be%d1%80%d0%b5%d0%bc%d0%b0&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Центральная предельная теорема (ЦПТ) утверждает, что, при условии достаточного размера выборки, распределение выборочных средних приблизительно нормально со средним равным среднему признака в ГС, даже если распределение генеральной совокупности не является нормальным.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://gallery.shinyapps.io/CLT_mean/&#34;target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Сайт&lt;i class=&#34;fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt; с симуляцией данных для центральной предельной теоремы.&lt;/p&gt;&#xA;&lt;p&gt;Предположим, что некоторый признак распределён нормально в ГС и имеет \(\mu = 15\)&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT0.png&#34; alt=&#34;/notes/basics_of_statistics/images/CLT0.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT0.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/CLT0.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/CLT0.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/CLT0.png&#34; style=&#34;--width: 1256px;--aspect-ratio: 1256 / 492;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Многократно извлечём выборки по 50 наблюдений в каждой из ГС и взглянем на них. Внутри каждой рассчитано среднее значение и стандартное отклонение. Как видно, оба показателя варьируются от выборки к выборке, причём довольно сильно.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT1.png&#34; alt=&#34;/notes/basics_of_statistics/images/CLT1.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT1.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/CLT1.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/CLT1.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/CLT1.png&#34; style=&#34;--width: 1250px;--aspect-ratio: 1250 / 592;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Теперь построим распределение выборочных средних значений. Взглянем на следующую картинку. Наше среднее выборочных средних (да-да) достаточно близко к среднему ГС.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT2.png&#34; alt=&#34;/notes/basics_of_statistics/images/CLT2.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT2.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/CLT2.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/CLT2.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/CLT2.png&#34; style=&#34;--width: 1239px;--aspect-ratio: 1239 / 422;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Стандартное отклонение такого распределения называется ошибкой среднего и показывает, насколько в среднем выборочное значение отклоняется от среднего в ГС.&lt;/p&gt;&#xA;&lt;p&gt;Теперь увеличим объём каждой выборки до 500 наблюдений. Видим, что, во-первых, распределение в каждой выборке стало напоминать распределение в ГС, а во-вторых, выборочные оценки стали гораздо точнее.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT3.png&#34; alt=&#34;/notes/basics_of_statistics/images/CLT3.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT3.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/CLT3.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/CLT3.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/CLT3.png&#34; style=&#34;--width: 1241px;--aspect-ratio: 1241 / 589;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Снова вернёмся к распределению выборочных средних показателей. Как и ожидалось, стандартная ошибка значительно уменьшилась.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT4.png&#34; alt=&#34;/notes/basics_of_statistics/images/CLT4.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/CLT4.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/CLT4.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/CLT4.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/CLT4.png&#34; style=&#34;--width: 1252px;--aspect-ratio: 1252 / 422;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Стандартная ошибка&lt;/strong&gt; — мера оценки математического ожидания генеральной совокупности \(\mu\) на основании выборочного среднего \(\bar{x}\). Вычисляется она по следующей формуле:&#xA;$$&#xA;se = \frac{\sigma}{\sqrt{N}}&#xA;$$&#xA;, где N — число наблюдений ГС.&lt;/p&gt;&#xA;&lt;p&gt;Очевидно, что при увеличении количества наблюдений в выборке и уменьшении стандартного отклонения ГС, стандартная ошибка будет уменьшаться.&lt;/p&gt;&#xA;&lt;p&gt;Для репрезентативных (элементы отобраны случайно) выборок с числом наблюдений больше 30 стандартная ошибка вычисляется похожим образом (при этом будет равна стандартной ошибке ГС):&#xA;$$&#xA;se_x = \frac{sd_x}{\sqrt{n}}&#xA;$$&#xA;, где n — число наблюдений выборки.&lt;/p&gt;&#xA;&lt;p&gt;Таким образом, имея на руках только одну выборку, возможно предсказать, как бы вели себя все выборочные средние — они бы распределились вокруг среднего генеральной совокупности со стандартным отклонением равным \(se\).&lt;/p&gt;&#xA;&lt;p&gt;Обозначение стандартной ошибки: \(se\)&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;доверительные-интервалы-для-среднего&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Доверительные интервалы для среднего&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d0%b4%d0%be%d0%b2%d0%b5%d1%80%d0%b8%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d0%b2%d0%b0%d0%bb%d1%8b-%d0%b4%d0%bb%d1%8f-%d1%81%d1%80%d0%b5%d0%b4%d0%bd%d0%b5%d0%b3%d0%be&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Доверительный интервал — интервал, в пределах которого с заданной вероятностью лежат выборочные оценки статистических характеристик ГС (в данном случае — среднее значение).&lt;/p&gt;&#xA;&lt;p&gt;Разберём статистическую задачу. Нужно найти среднее значение (интервал, в котором оно будет с опред. долей вероятности) генеральной совокупности, о которой ничего не известно, зато есть выборка из 64 наблюдений, выборочное среднее которой равно 100, а среднеквадратичное отклонение — 4.&lt;/p&gt;&#xA;&lt;p&gt;Если бы эксперимент повторялся многократно, то все выборочные средние равномерно распределились бы относительно среднего ГС со стандартным отклонением \(se\). 95% всех выборочных средних лежали бы в диапазоне: \(\bar{x}\pm 1,96 * \sigma\). Так как выборка у нас всего одна, заменим \(\sigma\) на \(se\) — стандартную ошибку среднего.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/confidence_interval.png&#34; alt=&#34;/notes/basics_of_statistics/images/confidence_interval.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/confidence_interval.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/confidence_interval.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/confidence_interval.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/confidence_interval.png&#34; style=&#34;--width: 709px;--aspect-ratio: 709 / 410;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Неизвестно, где находится выборочное среднее, но известно, что среднее ГС располагается прямо по центру (вспоминаем центральную предельную теорему). Попробуем случайно поставить несколько выборочных средних и просчитать интервалы. Получим, что с вероятностью 0,95 имеющееся выборочное среднее будет включать среднее ГС.&lt;/p&gt;&#xA;&lt;p&gt;Вычислим границы интервала, в центре которого — выборочное среднее: \(a = 100 + 1,96 * \frac{4}{\sqrt{64}} = 100,98\) — правая граница; \(b = 100 - 1,96 * \frac{4}{\sqrt{64}} = 99,02\) — левая граница.&lt;/p&gt;&#xA;&lt;p&gt;И-так, рассчитав интервал таким образом, можно быть на 95% уверенным, что он содержит среднее значение ГС. Увеличивая степень уверенности, расширяется интервал.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;p-уровень-значимости&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;P-уровень значимости&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#p-%d1%83%d1%80%d0%be%d0%b2%d0%b5%d0%bd%d1%8c-%d0%b7%d0%bd%d0%b0%d1%87%d0%b8%d0%bc%d0%be%d1%81%d1%82%d0%b8&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Нулевая гипотеза&lt;/strong&gt; (обозн. \(H_0\)) — предположение о том, что не существует связи между двумя наблюдаемыми событиями.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;P-value&lt;/strong&gt; (p-уровень значимости) — вероятность получить для распределения случайной величины значений такое же или более экстремальное значение (медиана, среднее и т.д.), по сравнению с ранее наблюдаемым, при условии, что нулевая гипотеза верна. Неформально, p-value — вероятность ошибки в случае отклонении нулевой гипотезы.&lt;br&gt;&#xA;Чем меньше уровень значимости, тем больше оснований отклонить нулевую гипотезу. Считается, что при \(p &amp;lt; 0,05\) (что весьма и весьма спорно), можно принимать альтернативную гипотезу. В ином случае — оснований для отклонения нулевой гипотезы недостаточно.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Идея статистического вывода&lt;/strong&gt; — допустим, нулевая гипотеза верна, т.е. никаких различий или взаимосвязей в ГС нет. Теперь можно рассчитать вероятность того, что имеющиеся отклонения были получены абсолютно случайно.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Рассмотрим пример. Предположим, что на выздоровление при некотором заболевании в среднем требуется 20 дней, однако был разработали новый препарат, и нужно проверить, можно ли сократить этот срок. Была набрана выборка из 64 пациентов, на которых опробовали новый метод лечения. Оказалось, что средний срок выздоровления сократился до 18,5 дней при стандартном отклонении равным 4. Какой вывод можно сделать основываясь на данных?&lt;/p&gt;&#xA;&lt;p&gt;Нулевая гипотеза \(H_0\) — на самом деле никого воздействия новый препарат не оказывает, и среднее значение ГС тех пациентов, кто использует препарат, на самом деле не отличается от 20.&lt;/p&gt;&#xA;&lt;p&gt;Альтернативная гипотеза \(H_1\) — препарат влияет на скорость выздоровления, а среднее значение ГС тех, кто использует препарат, не равняется 20.&lt;/p&gt;&#xA;&lt;p&gt;Предположим, что верна нулевая гипотеза, тогда в соответствии с ЦПТ, при многократном повторении эксперимента выборочные средние распределились бы нормальным образом вокруг среднего ГС со стандартной ошибкой среднего \(se=4/\sqrt{64}=0.5\). Выясним, насколько далеко имеющееся выборочное среднее отклонилось от предполагаемого среднего ГС в единицах стандартного отклонения через z-преобразование: \(z=\frac{\bar{x}-\Mu}{se}=\frac{18.5 - 20}{0.5}=-3\).&lt;/p&gt;&#xA;&lt;p&gt;Таким образом, если бы в ГС среднее значение на самом деле равнялось 20, то имеющееся выборочное среднее отклонилось бы от него на \(-3\sigma\) в левую сторону. Воспользуемся свойством нормального распределения, чтобы рассчитать в &lt;a href=&#34;https://gallery.shinyapps.io/dist_calc/&#34;target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;калькуляторе&lt;i class=&#34;fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt; вероятность такого или еще больше выраженного отклонения от среднего значения.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/basics_of_statistics/images/p-value.png&#34; alt=&#34;/notes/basics_of_statistics/images/p-value.png&#34; srcset=&#34;http://localhost:1313/notes/basics_of_statistics/images/p-value.png?size=small, http://localhost:1313/notes/basics_of_statistics/images/p-value.png?size=medium 1.5x, http://localhost:1313/notes/basics_of_statistics/images/p-value.png?size=large 2x&#34; data-title=&#34;/notes/basics_of_statistics/images/p-value.png&#34; style=&#34;--width: 1896px;--aspect-ratio: 1896 / 924;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Получается, вероятность отклониться от среднего больше чем на 3 стандартных отклонения равняется приблизительно 0,0027, а значит, можно смело отвергать нулевую гипотезу.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Ошибка первого рода&lt;/strong&gt; (\(\alpha\)-ошибка, ложноположительное заключение) — ситуация, когда отвергнута верная нулевая гипотеза.&lt;br&gt;&#xA;&lt;strong&gt;Ошибка второго рода&lt;/strong&gt; (\(\beta\)-ошибка, ложноотрицательное заключение) — ситуация, когда принята неверная нулевая гипотеза.&lt;/p&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>Устройство памяти в Python</title>
      <link>http://localhost:1313/notes/memory_python/</link>
      <pubDate>Sun, 08 Sep 2024 17:00:00 +0000</pubDate><author>darkgxd@vk.com (NoisyCake)</author>
      <guid>http://localhost:1313/notes/memory_python/</guid>
      <category domain="http://localhost:1313/categories/python/">Python</category>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/memory_python/images/feature.png&#34; alt=&#34;/notes/memory_python/images/feature.png&#34; srcset=&#34;http://localhost:1313/notes/memory_python/images/feature.png?size=small, http://localhost:1313/notes/memory_python/images/feature.png?size=medium 1.5x, http://localhost:1313/notes/memory_python/images/feature.png?size=large 2x&#34; data-title=&#34;/notes/memory_python/images/feature.png&#34; style=&#34;--width: 1920px;--aspect-ratio: 1920 / 1101;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Конспект посвящён объяснению понятия компьютерной памяти и тому, как эта память устроена в языке программирования Python&lt;/p&gt;&#xA;&lt;h2 id=&#34;centerкомпьютерная-памятьcenter&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;&lt;!-- raw HTML omitted --&gt;Компьютерная память&lt;!-- raw HTML omitted --&gt;&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#center%d0%ba%d0%be%d0%bc%d0%bf%d1%8c%d1%8e%d1%82%d0%b5%d1%80%d0%bd%d0%b0%d1%8f-%d0%bf%d0%b0%d0%bc%d1%8f%d1%82%d1%8ccenter&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Как можем видеть из схемы ниже, память в компьюетере разделяется на &lt;strong&gt;внутреннюю&lt;/strong&gt; и &lt;strong&gt;внешнюю&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/memory_python/images/diagram0.png&#34; alt=&#34;/notes/memory_python/images/diagram0.png&#34; srcset=&#34;http://localhost:1313/notes/memory_python/images/diagram0.png?size=small, http://localhost:1313/notes/memory_python/images/diagram0.png?size=medium 1.5x, http://localhost:1313/notes/memory_python/images/diagram0.png?size=large 2x&#34; data-title=&#34;/notes/memory_python/images/diagram0.png&#34; style=&#34;--width: 3840px;--aspect-ratio: 3840 / 2939;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Посмотрим подробнее на каждый тип памяти.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;внутренняя-память&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Внутренняя память&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d0%b2%d0%bd%d1%83%d1%82%d1%80%d0%b5%d0%bd%d0%bd%d1%8f%d1%8f-%d0%bf%d0%b0%d0%bc%d1%8f%d1%82%d1%8c&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;Характерными особенностями внутренней памяти по сравнению с внешней являются высокое быстродействие и ограниченный объем. Физически внутренняя память компьютера представляет собой интегральные микросхемы, которые размещаются в специальных гнездах на материнской плате. Чем больше размер внутренней памяти, тем более сложную задачу и с большей скоростью может решить компьютер.&lt;/p&gt;&#xA;&lt;p&gt;Внутренняя память подразделяется на:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;постоянную память&lt;/li&gt;&#xA;&lt;li&gt;оперативную память&lt;/li&gt;&#xA;&lt;li&gt;кэш-память&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Постоянная память&lt;/strong&gt; (ROM — read-only memory) — энергозависимая память, использующаяся для долговременного хранения неизменяемого массива данных. Содержание ПЗУ специальным образом закладываестя при его изготовлении для постоянного хранения. Из название как раз можно понять, что данная память предназначена только для чтения.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Оперативная память&lt;/strong&gt; (RAM — Random Access Memory) — в большинстве случаев энергозависимая память, хранящая выполняемый машинный код программ, входные, выходные и промежуточные данные, обрабатываемые процессором в текущем сеансе работы ПК. После выключения питания компьютера, полностью очищается.&lt;/p&gt;&#xA;&lt;p&gt;Микросхемы оперативной памяти монтируются на печатной плате. Каждая такая плата снабжена контактами, расположенными вдоль нижнего края. Для подключения к другим устройствам компьютера такая плата вставляется своими контактами в специальный разъем (слот) на материнской плате. Материнская плата имеет несколько разъемов для модулей оперативной памяти, суммарный объем которых может принимать ряд фиксированных значений, например 2, 4, 8, 16, 32 Гб и более.&lt;/p&gt;&#xA;&lt;p&gt;Оперативная память бывает нескольких типов: SDRAM, DDR, DDR2, DDR3, DDR4, DDR5. Каждый последующий тип памяти представляет собой улучшение предыдущего и позволяет новой памяти работать с большей скоростью. В данный момент в современных компьютерах используется оперативная память типа DDR4 и DDR5.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Кэш-память&lt;/strong&gt; (cache) — промежуточный буфер с быстрым доступом к нему, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. Эта память испольлзуется при обмене данными между процессором и оперативной памятью. Алгоритм ее работы позволяет сократить частоту обращений процессора к оперативной памяти и, следовательно, повысить производительность компьютера.&lt;/p&gt;&#xA;&lt;p&gt;Современные процессоры оснащены кэшем, который состоит зачастую из трех уровней: L1 (первый уровень), L2 (второй уровень), L3 (третий уровень).&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;L1&lt;/strong&gt; — наиболее быстрый уровень кэш-памяти, который работает напрямую с ядром процессора, в следствии чего обладает наименьшим временем доступа и работает на частотах, близких процессору. Размер данного кэша обычно не велик, а количество микросхем зачастую привязано к количеству ядер процессора, при этом у каждого ядра кэш свой собственный. Размер блока может варьироваться от 64-256 КБ у десктопов и ноутбуков до 1-2 МБ для серверных решений.&lt;/p&gt;&#xA;&lt;p&gt;Сам L1 тоже имеет свое разделение. Он делится на кэш команд и кэш данных:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Первый содержит информацию об операции, которой занимается ЦП, проще говоря, отвечает на вопрос: «Что надо сделать»;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Второй хранит в себе данные, над которыми должны производиться вычисления.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;L2&lt;/strong&gt; — второй уровень более масштабный, нежели первый, но в результате, обладает меньшими скоростными характеристиками. Также привязан к ядру и не взаимодействует с остальными.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;L3&lt;/strong&gt; — третий уровень. Он более медленный, нежели два предыдущих, но всё же гораздо быстрее, чем оперативная память. Этот блок уже доступен для всех ядер процессора. На третьем уровне временно хранятся данные, которые хоть и важны для продуктивной работы, но регистры обращаются за этой информацией относительно нечасто.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/memory_python/images/diagram1.png&#34; alt=&#34;/notes/memory_python/images/diagram1.png&#34; srcset=&#34;http://localhost:1313/notes/memory_python/images/diagram1.png?size=small, http://localhost:1313/notes/memory_python/images/diagram1.png?size=medium 1.5x, http://localhost:1313/notes/memory_python/images/diagram1.png?size=large 2x&#34; data-title=&#34;/notes/memory_python/images/diagram1.png&#34; style=&#34;--width: 1012px;--aspect-ratio: 1012 / 312;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;внешняя-память&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Внешняя память&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d0%b2%d0%bd%d0%b5%d1%88%d0%bd%d1%8f%d1%8f-%d0%bf%d0%b0%d0%bc%d1%8f%d1%82%d1%8c&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;Назначение внешней памяти компьютера заключается в долговременном хранении информации любого вида. Выключение питания компьютера не приводит к очистке внешней памяти и её объём в тысячи раз больше объёма внутренней памяти. Минус такой памяти в том, что обращение к ней требует гораздо большего времени.&lt;/p&gt;&#xA;&lt;p&gt;К устройствам внешней памяти относятся:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Жёсткие магнитные диски (HDD — Hard Disk Drive)&lt;/li&gt;&#xA;&lt;li&gt;Твердотельные накопители (SSD — Solid State Drive)&lt;/li&gt;&#xA;&lt;li&gt;Оптические диски (CD-ROM, DVD-ROM, Blue-Ray и т.д.)&lt;/li&gt;&#xA;&lt;li&gt;Флеш-накопители&lt;/li&gt;&#xA;&lt;li&gt;Гибкие магнитные диски&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Наиболее распространенный вариант постоянной памяти — жесткие диски HDD. Они представляют собой один или несколько магнитных дисков, вращающихся с огромной скоростью (от 5 до 12 тысяч оборотов в минуту), и головок, предназначенных для считывания и записи информации. HDD являются надежными носителями информации, позволяют записывать и считывать информацию огромное количество раз. Неудобство в том, что они очень медленные и восприимчивы к ударам, падениям и прочим механическим воздействиям, особенно в момент работы.&lt;/p&gt;&#xA;&lt;p&gt;Почти у каждого уверенного пользователя ПК в наши дни скорее найдётся SSD, чем HDD. Их популярность неудивительна, ведь они имеют гораздо более высокую скорость записи и чтения и невосприимчивы к механическим воздействиям. Их можно было бы назвать идеальными накопителями, если бы не ощутимо конечное количество циклов чтения-записи.&lt;/p&gt;&#xA;&lt;h2 id=&#34;centerуправление-памятью-в-pythoncenter&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;&lt;!-- raw HTML omitted --&gt;Управление памятью в Python&lt;!-- raw HTML omitted --&gt;&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#center%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bf%d0%b0%d0%bc%d1%8f%d1%82%d1%8c%d1%8e-%d0%b2-pythoncenter&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Управление памятью — это процесс выделения, распределения и координации памяти таким образом, чтобы все программы работали правильно и могли оптимально получать доступ к различным системным ресурсам. Управление памятью также включает в себя и очистку памяти от объектов, которые больше не нужны.&lt;/p&gt;&#xA;&lt;p&gt;Существует два типа управления памятью: ручное и автоматическое.&lt;/p&gt;&#xA;&lt;p&gt;Ручное управление включает в себя, как правило, три этапа:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Запрос памяти у операционной системы&lt;/li&gt;&#xA;&lt;li&gt;Работа с ней&lt;/li&gt;&#xA;&lt;li&gt;Возвращение памяти обратно в операционную систему&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Ручной подход управления (как в C, C++, Pascal и т.д.) позволяет работать с памятью максимально эффективно. Программист точно знает, сколько памяти ему выделено, зачем он её использует, и т.д. Однако помимо преимуществ такой подход имеет и ряд недостатков. Ключевой из них — сложность. Управлять памятью вручную — сложно и тяжело, поскольку легко забыть вернуть память обратно операционной системе, в результате чего возникает утечка: программа держит неиспользуемую память просто так, не давая применять ее для решения других задач.&lt;/p&gt;&#xA;&lt;p&gt;Автоматическое управление памятью (как в Python, Java, JS, C#, Ruby и т.д.) берет на себя самый сложный этап — возвращение памяти обратно операционной системе, когда она уже не требуется. Восстановленная память может использоваться другими объектами. В определённых случаях это менее эффективно, но позволяет сильно сократить трудозатраты и повысить надежность процесса.&lt;/p&gt;&#xA;&lt;p&gt;Python — это язык с автоматическим управлением памятью. Причем для управления ею он использует несколько механизмов. При запуске Python программы создается новый процесс, в рамках которого операционная система выделяет пул ресурсов, включая виртуальное адресное пространство. В эту память загружается интерпретатор Python вместе со всеми необходимыми ему для работы данными, включая код написанной программы.&lt;/p&gt;&#xA;&lt;p&gt;Оставшаяся свободная виртуальная память может использоваться для хранения информации об объектах Python. Для управления этой памятью в CPython используется специальный механизм, который называется аллокатор. Он используется каждый раз, когда вам нужно создать новый объект.&lt;/p&gt;&#xA;&lt;p&gt;Обычно мы в своих программах не оперируем большими объектами. Большая часть наших данных — это числа, строки и т.д., они занимают не такой уж большой объем в расчёте на одно значение. Но зато мы создаем их достаточно часто. И это приводило бы к проблемам, если бы Python абсолютно все такие вызовы транслировал в операционную систему. Системный вызов на выделение памяти — штука трудозатратная, зачастую связанная с переходом в контекст ядра операционной системы. Поэтому одна из главных задач аллокатора Python — оптимизация количества системных вызовов.&lt;/p&gt;&#xA;&lt;div class=&#34;details admonition info open&#34;&gt;&#xD;&#xA;  &lt;div class=&#34;details-summary admonition-title&#34;&gt;&lt;i class=&#34;icon fa-fw fa-solid fa-circle-info&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;Инфо&lt;i class=&#34;details-icon fa-solid fa-angle-right fa-fw&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/div&gt;&#xD;&#xA;  &lt;div class=&#34;details-content&#34;&gt;&#xD;&#xA;    &lt;div class=&#34;admonition-content&#34;&gt;Для больших объектов (больше 512 байт) Python выделяет память напрямую у ОС. Обычно таких объектов не очень много в рамках программы, и создаются они нечасто. Поэтому накладные расходы на создание таких объектов напрямую в RAM не так высоки.&lt;/div&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Аллокатор для малых объектов (не больше 512 байт) использует три уровня абстракции:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Блок — кусок памяти, используемый для хранения одного объекта.&lt;/li&gt;&#xA;&lt;li&gt;Пул — страница памяти, содержащий блоки (обычно 4 килобайта).&lt;/li&gt;&#xA;&lt;li&gt;Арена — большой непрерывный кусок памяти, содержащий пулы (обычно 256 килобайт).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/memory_python/images/arena_pool_block.png&#34; alt=&#34;/notes/memory_python/images/arena_pool_block.png&#34; srcset=&#34;http://localhost:1313/notes/memory_python/images/arena_pool_block.png?size=small, http://localhost:1313/notes/memory_python/images/arena_pool_block.png?size=medium 1.5x, http://localhost:1313/notes/memory_python/images/arena_pool_block.png?size=large 2x&#34; data-title=&#34;/notes/memory_python/images/arena_pool_block.png&#34; style=&#34;--width: 1132px;--aspect-ratio: 1132 / 626;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;centerблокcenter&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;&lt;!-- raw HTML omitted --&gt;Блок&lt;!-- raw HTML omitted --&gt;&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#center%d0%b1%d0%bb%d0%be%d0%bacenter&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&lt;p&gt;Блок — это кусок памяти, который может содержать только один Python объект фиксированного размера. Размер блока может варьироваться от 8 до 512 байт и должен быть кратен восьми. Все блоки в конкретном пуле имеют одинаковый размер и находятся в одном классе размера, который и определяет размер блока.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;Запрос памяти в байтах&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;Размер блока в байтах&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;Индекс класса размера&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1-8&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;8&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;9-16&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;16&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;17-24&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;24&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;25-32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;32&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;33-40&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;40&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;41-48&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;48&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;5&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&amp;hellip;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&amp;hellip;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;505-512&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;512&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;63&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;Таким образом, если необходимы:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;6 байт, то данные будут помещены в блок размером 8 байт;&lt;/li&gt;&#xA;&lt;li&gt;42 байта, то данные будут помещены в блок размером 48 байт;&lt;/li&gt;&#xA;&lt;li&gt;и т.д.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;centerпулcenter&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;&lt;!-- raw HTML omitted --&gt;Пул&lt;!-- raw HTML omitted --&gt;&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#center%d0%bf%d1%83%d0%bbcenter&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&lt;p&gt;Пулы состоят из блоков одного размера. Каждый пул работает по принципу двухсвязного списка с другими пулами того же размера, поэтому алгоритм может с легкостью найти необходимое место для требуемого размера блока даже среди множества пулов. Размер пула равен 4 килобайта.&lt;/p&gt;&#xA;&lt;div class=&#34;details admonition info open&#34;&gt;&#xD;&#xA;  &lt;div class=&#34;details-summary admonition-title&#34;&gt;&lt;i class=&#34;icon fa-fw fa-solid fa-circle-info&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;Инфо&lt;i class=&#34;details-icon fa-solid fa-angle-right fa-fw&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/div&gt;&#xD;&#xA;  &lt;div class=&#34;details-content&#34;&gt;&#xD;&#xA;    &lt;div class=&#34;admonition-content&#34;&gt;Ограничение пула фиксированным размером блоков помогает с фрагментацией. Если объект уничтожается, аллокатор может заполнить это пространство новым объектом того же размера.&lt;/div&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Для эффективного управления пулами Python использует дополнительный список, который называется &lt;code&gt;usedpools&lt;/code&gt;. Он хранит указатели на пулы, сгруппированные по классам. Как уже известно, все пулы с одинаковым размером блока связаны между собой с помощью двухсвязного списка. Чтобы перебрать их, нужно просто знать начало списка. Если пулов такого размера нет, то при первом запросе памяти будет создан новый.&lt;/p&gt;&#xA;&lt;p&gt;Пулы находятся в трех состояниях:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Используемый (used) — частично заполненный, какие-то блоки заняты, какие-то свободны;&lt;/li&gt;&#xA;&lt;li&gt;Полный (full) — полностью заполненный, все блоки заняты;&lt;/li&gt;&#xA;&lt;li&gt;Пустой (empty) — все блоки свободны и доступны для записи (хранятся в списке пустых пулов &lt;code&gt;freepools&lt;/code&gt;).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Используемый пул содержит блоки, в которые можно записать какую-то информацию. Блоки полного пула все распределены и уже содержат данные. Пустые пулы не содержат данных и могут быть разбиты на какие угодны классы размера при необходимости.&lt;/p&gt;&#xA;&lt;p&gt;Допустим, нашему коду необходимо 8 байт. Если в списке используемых пулов нет пулов с классом размера в 8 байт, то новый пустой пул инициализируется, как хранящий блоки по 8 байт. Затем пустой пул добавляется в список используемых пулов и может быть использован при следующих запросах.&lt;/p&gt;&#xA;&lt;p&gt;Заполненный пул освобождает некоторые блоки, когда эта информация в них уже не нужна. Этот пул добавится в список используемых в соответствии со своим классом размера.&lt;/p&gt;&#xA;&lt;div class=&#34;details admonition info open&#34;&gt;&#xD;&#xA;  &lt;div class=&#34;details-summary admonition-title&#34;&gt;&lt;i class=&#34;icon fa-fw fa-solid fa-circle-info&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;Инфо&lt;i class=&#34;details-icon fa-solid fa-angle-right fa-fw&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/div&gt;&#xD;&#xA;  &lt;div class=&#34;details-content&#34;&gt;&#xD;&#xA;    &lt;div class=&#34;admonition-content&#34;&gt;Пулы и блоки не выделяют память напрямую, вместо этого они используют уже выделенное пространство в аренах.&lt;/div&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/div&gt;&#xA;&lt;h4 id=&#34;centerареныcenter&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;&lt;!-- raw HTML omitted --&gt;Арены&lt;!-- raw HTML omitted --&gt;&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#center%d0%b0%d1%80%d0%b5%d0%bd%d1%8bcenter&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&lt;p&gt;Арена – это кусок памяти размером в 256 килобайт, который обеспечивает память для 64 пулов.&lt;/p&gt;&#xA;&lt;p&gt;Арены, в отличие от пулов, не имеют явных разделений на состояния. Они сами по себе организованы в двухсвязный список &lt;code&gt;usable_arenas&lt;/code&gt;, который отсортирован по количеству свободных пулов. Чем меньше свободных пулов, тем ближе арена к началу списка.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/notes/memory_python/images/arena.png&#34; alt=&#34;/notes/memory_python/images/arena.png&#34; srcset=&#34;http://localhost:1313/notes/memory_python/images/arena.png?size=small, http://localhost:1313/notes/memory_python/images/arena.png?size=medium 1.5x, http://localhost:1313/notes/memory_python/images/arena.png?size=large 2x&#34; data-title=&#34;/notes/memory_python/images/arena.png&#34; style=&#34;--width: 960px;--aspect-ratio: 960 / 540;background: url(/images/loading.min.svg) no-repeat center;&#34; onload=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}this.dataset.lazyloaded=&#39;&#39;;&#34; onerror=&#34;this.title=this.dataset.title;for(const i of [&#39;style&#39;, &#39;data-title&#39;,&#39;onerror&#39;,&#39;onload&#39;]){this.removeAttribute(i);}&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;Поэтому наиболее полная арена будет выбрана для записи еще большего количества данных. Такое расположение арен позволяет снизить объем потребляемой программой памяти. Дело в том, что в некоторых случаях, когда память освобождается, она все еще остается недоступной операционной системе. Процесс Python держит ее распределенной и использует ее позже для новых данных. Полное освобождение памяти возвращает память в пользование операционной системе.&lt;/p&gt;&#xA;&lt;p&gt;Арены — единственные области, которые могут быть полностью освобождены. Таким образом мы понимаем, что те арены, которые находятся в списке ближе к пустому состоянию, должны быть освобождены. В таком случае, область памяти может быть действительно полностью освобождена, и соответственно общий объем памяти Python программы будет уменьшен.&lt;/p&gt;&#xA;&lt;h2 id=&#34;centerочистка-памятиcenter&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;&lt;!-- raw HTML omitted --&gt;Очистка памяти&lt;!-- raw HTML omitted --&gt;&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#center%d0%be%d1%87%d0%b8%d1%81%d1%82%d0%ba%d0%b0-%d0%bf%d0%b0%d0%bc%d1%8f%d1%82%d0%b8center&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;Как мы уже знаем, язык Python является языком с автоматически управляемой памятью, то есть программисту, пишущему код на Python, не нужно беспокоиться о работе с памятью, в частности заниматься ее освобождением. Как только данные программы (объекты в Python) больше не нужны, Python автоматически освобождает память, которую они занимали. Несмотря на это, понимание того, как работает механизм очистки памяти, может помочь писать более качественный и производительный код.&lt;/p&gt;&#xA;&lt;p&gt;Стандартный интерпретатор Python использует сразу два механизма очистки памяти:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Подсчёт ссылок;&lt;/li&gt;&#xA;&lt;li&gt;Сборщик мусора (Garbage Collector, GC).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;подсчёт-ссылок&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Подсчёт ссылок&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d0%bf%d0%be%d0%b4%d1%81%d1%87%d1%91%d1%82-%d1%81%d1%81%d1%8b%d0%bb%d0%be%d0%ba&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;Алгоритм подсчета ссылок — это один из самых простых механизмов очистки памяти. Объекты удаляются как только на них больше нет ссылок.&lt;/p&gt;&#xA;&lt;p&gt;Каждый объект в Python унаследован от базового класса PyObject, который содержит специальное поле &lt;code&gt;Reference Count (ob_refcnt)&lt;/code&gt;, в котором хранится количество ссылок на данный объект. Как только кто-то начинает ссылаться на объект, значение этого поля увеличивается на единицу. Если по какой-то причине ссылка пропадает, то это поле уменьшается на один. При этом если счетчик ссылок для определенного объекта достигает нуля, то интерпретатор запускает процесс уничтожения объекта. Если удаленный объект содержал ссылки на другие объекты, то эти ссылки также удаляются. Таким образом, удаление одного объекта может повлечь за собой удаление других.&lt;/p&gt;&#xA;&lt;div class=&#34;details admonition info open&#34;&gt;&#xD;&#xA;  &lt;div class=&#34;details-summary admonition-title&#34;&gt;&lt;i class=&#34;icon fa-fw fa-solid fa-circle-info&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;Инфо&lt;i class=&#34;details-icon fa-solid fa-angle-right fa-fw&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/div&gt;&#xD;&#xA;  &lt;div class=&#34;details-content&#34;&gt;&#xD;&#xA;    &lt;div class=&#34;admonition-content&#34;&gt;Механизм подсчета ссылок работает в режиме реального времени.&lt;/div&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Четыре основных сценария, увеличивающих количество ссылок на объект:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Создание нового объекта и присвоение его переменной;&lt;/li&gt;&#xA;&lt;li&gt;Присвоение уже существующего объекта переменной;&lt;/li&gt;&#xA;&lt;li&gt;Передача объекта в функцию в качестве аргумента;&lt;/li&gt;&#xA;&lt;li&gt;Добавление объекта в список, множество, словарь и т.д.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Четыре основных сценария, уменьшающих количество ссылок на объект:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Удаление объекта из области видимости функции после ее завершения;&lt;/li&gt;&#xA;&lt;li&gt;Удаление переменной с помощью оператора del;&lt;/li&gt;&#xA;&lt;li&gt;Переприсваивание переменной нового значения;&lt;/li&gt;&#xA;&lt;li&gt;Удаление объекта из списка, множества, словаря и т.д.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Для получения количества ссылок на заданный объект используется функция &lt;code&gt;getrefcount()&lt;/code&gt; из модуля &lt;code&gt;sys&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sys&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getrefcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Вывод: 2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Когда мы вызываем функцию &lt;code&gt;getrefcount()&lt;/code&gt; для получение количества ссылок на объект, мы увеличиваем количество ссылок на объект на один, так как передаем &lt;code&gt;nums&lt;/code&gt; в качестве аргумента в функцию. Поэтому счетчик ссылок равен 2. Это означает, что и переменная &lt;code&gt;nums&lt;/code&gt;, и функция &lt;code&gt;getrefcount()&lt;/code&gt; ссылаются на один и тот же список &lt;code&gt;[1, 2, 3]&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Алгоритм подсчета ссылок очень простой и эффективный, но у него есть один большой недостаток. Он не умеет определять циклические ссылки. Приведённый ниже код создаёт циклические ссылки, так как &lt;code&gt;nums1&lt;/code&gt; содержит ссылку на &lt;code&gt;nums2&lt;/code&gt;, в то время как &lt;code&gt;nums2&lt;/code&gt; содержит ссылку на &lt;code&gt;nums1&lt;/code&gt;. Таким образом, счетчики ссылок у &lt;code&gt;nums1&lt;/code&gt; и &lt;code&gt;nums2&lt;/code&gt; никогда не будут равны нулю.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Именно из-за этого в Python существует дополнительный механизм очистки памяти — сборщик мусора (Garbage Collector, GC), который следит за объектами с потенциальными циклическими ссылками.&lt;/p&gt;&#xA;&lt;div class=&#34;details admonition info open&#34;&gt;&#xD;&#xA;  &lt;div class=&#34;details-summary admonition-title&#34;&gt;&lt;i class=&#34;icon fa-fw fa-solid fa-circle-info&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;Инфо&lt;i class=&#34;details-icon fa-solid fa-angle-right fa-fw&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/div&gt;&#xD;&#xA;  &lt;div class=&#34;details-content&#34;&gt;&#xD;&#xA;    &lt;div class=&#34;admonition-content&#34;&gt;В Python алгоритм подсчета ссылок является фундаментальным и не может быть отключен, тогда как сборщик мусора (GC) опционален и может быть отключен.&lt;/div&gt;&#xD;&#xA;  &lt;/div&gt;&#xD;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Количество ссылок на определенный объект иногда может оказаться заметно больше, чем кажется на первый взгляд. Дело в том, что многие неизменяемые объекты уже используются, например, в реализациях встроенных функций и типов данных. Объекты, относящиеся к изменяемым типам данных данной особенности не подвержены, так как изменение такого объекта в одной части программы привело бы к его изменению в другой части программы.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sys&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getrefcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;# число 0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getrefcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;# число 1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getrefcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;# пустая строка&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getrefcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(()))&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;# пустой кортеж&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Возможный вывод:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;164&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;84&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;58&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1257&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Счетчик ссылок подвержен проблемам в многопоточной среде, которые могут приводить к некорректности обновления этого счетчика из разных потоков и, следовательно, к удалению объектов, на которые еще существуют ссылки. Чтобы этого избежать, CPython использует GIL — Global Interpreter Lock. Каждый раз, когда происходит работа с памятью, GIL — как глобальная блокировка — препятствует выполнению этих действий одновременно из двух потоков. Он гарантирует, что сначала отработает один, потом другой.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;сборщик-мусора&#34; class=&#34;heading-element&#34;&gt;&lt;span&gt;Сборщик мусора&lt;/span&gt;&#xD;&#xA;  &lt;a href=&#34;#%d1%81%d0%b1%d0%be%d1%80%d1%89%d0%b8%d0%ba-%d0%bc%d1%83%d1%81%d0%be%d1%80%d0%b0&#34; class=&#34;heading-mark&#34;&gt;&#xD;&#xA;    &lt;svg class=&#34;octicon octicon-link&#34; viewBox=&#34;0 0 16 16&#34; version=&#34;1.1&#34; width=&#34;16&#34; height=&#34;16&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;В отличие от алгоритма подсчета ссылок, сборщик мусора не работает в режиме реального времени и запускается периодически. Каждый запуск сборщика создаёт микропаузы в работе программы, поэтому Python использует различные эвристики для определения частоты запуска сборщика мусора.&lt;/p&gt;&#xA;&lt;p&gt;Сборщик мусора разделяет все объекты на 3 поколения (нулевое, первое и второе). Новые объекты попадают в нулевое поколение. Если новый объект выживает в процессе сборки мусора, то он перемещается в следующее поколение. Чем старше поколение, тем реже оно сканируется на сборку мусора. Так как новые объекты зачастую имеют очень маленький срок жизни (являются временными), то имеет смысл проверять их чаще, чем те, которые уже прошли через несколько этапов сборки мусора.&lt;/p&gt;&#xA;&lt;p&gt;В каждом поколении есть специальный порог срабатывания, при достижении которого срабатывает процесс сборки мусора. Если сразу несколько поколений преодолели порог, то выбирается наиболее старшее поколение, так как сборка мусора в старших поколениях включает в себя также сборку мусора и в младших поколениях.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;Основной источник:&lt;/strong&gt; &lt;a href=&#34;https://stepik.org/course/82541/syllabus&#34;target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;https://stepik.org/course/82541/syllabus&lt;i class=&#34;fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Дополнительные источники:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://habr.com/ru/companies/domclick/articles/530804/&#34;target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Habr&lt;i class=&#34;fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://market.marvel.ru/blog/komplektuyushchie-i-optsii/kesh-pamyat-protsessora/&#34;target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;Market.Marvel.ru&lt;i class=&#34;fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/python/cpython/blob/7d6ddb96b34b94c1cbdf95baa94492c48426404e/Objects/obmalloc.c&#34;target=&#34;_blank&#34; rel=&#34;external nofollow noopener noreferrer&#34;&gt;GitHub&lt;i class=&#34;fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
