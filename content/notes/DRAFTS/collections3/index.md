---
title: "Коллекции в Python. Часть III"
date: 2024-07-26 00:00:01
type: posts
tags:
  - python
  - datatypes
  - modules
  - collections
  - deque
  - array
categories:
  - python
draft: true
---

Конспект посвящён модулю collections и его составляющим, а именно... Третья часть конспектов про типы данных в Python
<!--more-->
## <center>Deque</center>

Для использования: `from collections import deque`

`deque` (произносится как "deck" — double-ended queue) — низкоуровневая и высоко оптимизированная двусторонняя очередь. Эта коллекция реализована через двусвязный список (т.е. каждый элемент дека содержит указатели на предыдущий и последующий элементы, если таковы имеются), поэтому она поддерживает экономичные с точки зрения памяти и быстрые (примерно O(1)) добавление и удаление элементов на обоих концах структуры данных.

Для создания объекта `deque` можно использовать различные итерируемые объекты. Если ничего не передать, создастся дек с пустым списком внутри. Вторым параметром функции `deque` является `maxlen=None` — он задаёт максимальный размер дека. В случае, если количество элементов будет больше, чем указано в `maxlen`, в коллекции окажутся только последние.
```py
from collections import deque

print(deque(range(1, 6)))

print(deque("abcd", maxlen=2))
```

```
# Вывод:
deque([1, 2, 3, 4, 5])
deque(['c', 'd'], maxlen=2)
```

### Добавление и удаление элементов
У `deque` есть собственные методы `pop` и `append`, которые удаляют и добавляют элементы соответственно с конца дека, в то время как методы `popleft` и `appendleft` делают то же самое, но с начала коллекции. Важно уточнить, что ни один из этих методов не принимает аргументы, например как `pop()` в списке Python, поэтому удалять элементы по индексу таким образом не получится.

![](images/image1.jpeg)

Двусвязные очереди (двусвязные списки), на основе которых реализован дек в Python, упрощают добавление и удаление элементов с обоих концов, поскольку после этих операций приходится обновлять только указатели. Эти же операции с левого конца в `list` Python требуют перемещение всех элементов списка, из-за чего сложность становится O(n). Кроме того, для добавления элементов в правый конец списка Python перераспределяет память и зачастую копирует исходные данные в другую область памяти, чтобы уместить новый список.  
Для наглядности сравним скорости добавления элементов в левый конец `list` и `deque`:
```py
from collections import deque
from time import perf_counter

TIMES = 10_000
a_list = []
a_deque = deque()

def average_time(func, times):
    total = 0.0
    for i in range(times):
        start = perf_counter()
        func(i)
        total += (perf_counter() - start) * 1e9
    return total / times

list_time = average_time(lambda i: a_list.insert(0, i), TIMES)
deque_time = average_time(lambda i: a_deque.appendleft(i), TIMES)
gain = list_time / deque_time

print(f"list.insert()      {list_time:.6} ns")
print(f"deque.appendleft() {deque_time:.6} ns  ({gain:.6}x faster)")
```

```
# Вывод:
list.insert()      2528.63 ns
deque.appendleft() 97.34 ns  (25.9773x faster)
```

{{< admonition error >}}
Разумеется, попытка удаления элемента из пустого дека приведёт к ошибке
{{< /admonition >}}

---
### Доступ к элементам дека
`deque()` возвращает изменяемый объект, работающий подобно списку, соответственно, у них есть схожие методы. Тем не менее, список основан на массиве, в то время как дек — на двусвязном очереди, что делает доступ, вставку и удаление произвольных элементов неэффективными операциями (O(n)).

Дек поддерживает:
* Индексацию;
* `insert(i, value)` — вставляет элемент `value` по индексу `i`, изменяя индексы последующих элементов;
* `remove(value)` — удаляет первый встретившийся элемент `value`;
* `del obj[i]` — удаляет элемент по индексу `i`.
```py
from collections import deque

letters = deque("abded")

print(letters[1])

letters.insert(2, "c")
print(letters)

letters.remove("d")
print(letters)

del letters[2]
print(letters)
```

```
# Вывод:
b
deque(['a', 'b', 'c', 'd', 'e', 'd'])
deque(['a', 'b', 'c', 'e', 'd'])
deque(['a', 'b', 'e', 'd'])
```

{{< admonition info >}}
Хоть `deque` и поддерживает индексацию, он **не поддерживает срезы**.
{{< /admonition >}}

---
### Другие методы `deque`
* `clear()` — очищает дек;
* `reverse()` — "разворачивает" дек;
* `rotate(n)` — последовательно переносит `n` элементов с конца в начало дека (наоборот при отрицательном `n`);
* `extend(iterable)` — добавляет в конец дека элементы итерируемого объекта `iterable`;
* `extendleft(iterable)` — добавляет в начало дека элементы итерируемого объекта `iterable`;
* `copy()` — создаёт поверхностную копию дека;
* `count(x)` — подсчитывает количество вхождений элементов, равных `x`, в деке;
* `index(x)` — возвращает индекс первого элемента в деке, равного `x`.

---
## <center>Array</center>
























---

**Основной источник:** https://stepik.org/course/82541

Дополнительные источники:
* [Real Python](https://realpython.com/)
* [Python Docs](https://docs.python.org/3/library/collections.html)